{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"This document is a usage manual for JEB. The latest version can be found online on the PNF Software web site . JEB is a reverse-engineering platform to perform disassembly, decompilation, debugging, and analysis of code and document files, manually or as part of an analysis pipeline. The first part of this guide is a user manual that covers basic usage related to analyzing, decompiling and debugging applications (Android apps, as well as native binaries). It is not an exhaustive resource. We recommend visiting our blog for additional, pointed resources describing a variety of use cases. The second half is a developer portal for advanced users who will want to use the JEB API to script tasks, develop plugins, or even craft their own front-ends. Alongside these pages, the API reference documentation website will be an indispensable resource. Hint Use the N key to navigate to the next page. Use the P key to navigate to the previous page. Use the S key to focus the search box. Installation # Delivery # JEB is delivered electronically over email. Software updates are also delivered over email. Missing emails? To ensure the software delivery and update emails do not end-up in spam folders, white-list the sender software@pnfsoftware.com . Software Package # The software package is distributed as a zip archive, custom-generated for each registered user. It contains the back-end components as well as the reference front-end implementation for desktop platforms, referred to as the UI client through the rest of this manual. This manual focuses mostly on using JEB through the UI client. The UI client runs on Windows 64-bit , Linux/GTK 64-bit , and macOS 64-bit . Requirements # JEB requires a recent Java SE Development Kit (JDK) , version 8u191 or above. Java and macOS On macOS platforms, we recommend avoiding JDK 13 and beyond. It looks like JEB's UI library is not entirely compatible with those newest-and-greatest versions of Java. Setup # Make sure you have a JRE or JDK installed. The java binary must be accessible from the PATH environment variable. Optionally, you may also want to set a JAVA_HOME environment variable pointing to your Java installation folder. 64-bit OS with 32-bit JRE A common source of problems are 64-bit systems having a 32-bit JRE accessible from the PATH. You may have different versions of Java installed, but always make sure that your PATH or JAVA_HOME refers to one that matches your system specifications. Startup # Next, execute the startup script appropriate for your environment: Windows $ jeb_wincon.bat Linux $ jeb_linux.sh macOS $ jeb_macos.sh The startup script will locate and decrypt the JEB binary file. It may prompt the user and ask for the decryption password, which can be found within the software delivery email issued by PNF Software. Enter the password to allow the startup script to finish the installation process. JEB will start. Note Start-up scripts get overwritten during an update. Therefore, if you wish to customize your start-up script, we recommend you copy it to a separate file, e.g. jeb.sh or jeb.bat . Registration # If it is the first time you are launching a non-floating JEB client (e.g., JEB Pro, JEB Android), you will be asked to accept the end-user license agreement, and generate a license key: If your machine is connected to the Internet, the license key can be automatically generated by clicking \"Generate a Key\". If need be, you may also configure your Proxy settings. If your machine is not connected to the Internet, you will need to generate a manual key. Click \"Manual Key Generation\" and follow the instructions. You will be asked to visit the key generation portal on a separate machine (connected to the Internet), and provide your license data. The license key will be stored in the bin/jeb-client.cfg file, under the .LicenseKey key entry. A key is specific to the user-account and machine configuration on which JEB is running. Do not attempt to reuse a key on another system. Info If you need to deprecate an older key (e.g., because of a machine replacement, user departure, or else), email Licensing . First use # Congratulation! JEB is now running.","title":"Getting Started"},{"location":"index.html#installation","text":"","title":"Installation"},{"location":"index.html#delivery","text":"JEB is delivered electronically over email. Software updates are also delivered over email. Missing emails? To ensure the software delivery and update emails do not end-up in spam folders, white-list the sender software@pnfsoftware.com .","title":"Delivery"},{"location":"index.html#software-package","text":"The software package is distributed as a zip archive, custom-generated for each registered user. It contains the back-end components as well as the reference front-end implementation for desktop platforms, referred to as the UI client through the rest of this manual. This manual focuses mostly on using JEB through the UI client. The UI client runs on Windows 64-bit , Linux/GTK 64-bit , and macOS 64-bit .","title":"Software Package"},{"location":"index.html#requirements","text":"JEB requires a recent Java SE Development Kit (JDK) , version 8u191 or above. Java and macOS On macOS platforms, we recommend avoiding JDK 13 and beyond. It looks like JEB's UI library is not entirely compatible with those newest-and-greatest versions of Java.","title":"Requirements"},{"location":"index.html#setup","text":"Make sure you have a JRE or JDK installed. The java binary must be accessible from the PATH environment variable. Optionally, you may also want to set a JAVA_HOME environment variable pointing to your Java installation folder. 64-bit OS with 32-bit JRE A common source of problems are 64-bit systems having a 32-bit JRE accessible from the PATH. You may have different versions of Java installed, but always make sure that your PATH or JAVA_HOME refers to one that matches your system specifications.","title":"Setup"},{"location":"index.html#startup","text":"Next, execute the startup script appropriate for your environment: Windows $ jeb_wincon.bat Linux $ jeb_linux.sh macOS $ jeb_macos.sh The startup script will locate and decrypt the JEB binary file. It may prompt the user and ask for the decryption password, which can be found within the software delivery email issued by PNF Software. Enter the password to allow the startup script to finish the installation process. JEB will start. Note Start-up scripts get overwritten during an update. Therefore, if you wish to customize your start-up script, we recommend you copy it to a separate file, e.g. jeb.sh or jeb.bat .","title":"Startup"},{"location":"index.html#registration","text":"If it is the first time you are launching a non-floating JEB client (e.g., JEB Pro, JEB Android), you will be asked to accept the end-user license agreement, and generate a license key: If your machine is connected to the Internet, the license key can be automatically generated by clicking \"Generate a Key\". If need be, you may also configure your Proxy settings. If your machine is not connected to the Internet, you will need to generate a manual key. Click \"Manual Key Generation\" and follow the instructions. You will be asked to visit the key generation portal on a separate machine (connected to the Internet), and provide your license data. The license key will be stored in the bin/jeb-client.cfg file, under the .LicenseKey key entry. A key is specific to the user-account and machine configuration on which JEB is running. Do not attempt to reuse a key on another system. Info If you need to deprecate an older key (e.g., because of a machine replacement, user departure, or else), email Licensing .","title":"Registration"},{"location":"index.html#first-use","text":"Congratulation! JEB is now running.","title":"First use"},{"location":"actions.html","text":"The primary use case for JEB is the analysis of binary code. This section focuses on the basics of code analysis and refactoring: Renaming items such as methods or fields Changing the code structure by moving items to packages Commenting Navigating a code base via cross-references Viewing type hierarchies Viewing method overrides Graphing routines (CFG) Replacing items or rebasing immediates Auto-renaming all items In the UI client, many fundamental interactions can be achieved via the Action and Navigation menus. Those actions are implemented by most JEB analysis modules that perform code disassembly. Other action groups such as Native code actions and Debugging actions are detailed in separate sections of this manual. Warning The examples in this section are based on the analysis of a sample Android app using the Android DEX parser. Keep in mind that features and behaviors of Actions depend on the module implementing and performing them. Decompiling # The next section covers decompiling code in depth. Graphing # Users can alternate between the default interactive full disassembly view and the interactive control flow graph of the currently examined method/routine. Press the Space key to go back and forth. In some circumstances, users may prefer graph navigation. CFG fragment of a routine Renaming # An important requirement for analysts is the ability to rename code items such as types, methods and routines, fields and data items, packages, etc. consistently across a code base. Position the caret on the item to be renamed Hit the N key or select Action, Rename Enter the new name and press Enter Tip Within the Rename dialog box, press Ctrl+Space (Command+Space on macOS) to bring up your renaming history. Commenting # When in a code view, press the / (slash) key to add a comment. Warning Comments are attached to addresses or items, therefore make sure to be on a valid address - else no comment can be attached. The caret address is always displayed in the status bar: Navigating # Pressing the Enter key on an item or double-clicking it will bring the caret to the definition of the item. You can navigate backward and forward using the traditional Alt + Arrow Left (or Escape ) and Alt + Arrow Right key combos, or via the Navigation menu. The Next Item and Previous Item command allow you to jump to the similar item after or before the currently selected item. Cross-references # Cross-references on an item allow the examination of items referencing it. Press the X key to visualize them. You can jump to a cross-reference by double-clicking it. The cross-reference dialog generally includes additional information attached to the referenced location. That information is plugin-dependent. Below, the Details column provides the kind of reference (on a field item, in that case), e.g. a GET (read), or something else. Type Hierarchies # Use the T key on a type item (such as a class or an interface) to visualize its ancestors and children. Double-click on a type item to jump to the item definition. Restructuring # The Create Package and Move to Package actions offer powerful refactoring possibilities, especially useful in the case of large obfuscated binary files. If the module supports it, users are able to: Create artificial packages (aka, namespaces) using the K key. Move items, such as types, to existing or artificial packages using the L key. Workflow The following screenshot is an example where the class AppHelp was moved from the com.pnfsoftware.raasta package to a newly created package named com.abc . Info Have a look at our YouTube demo video that demonstrates advanced refactoring and automatic restructuring of a heavily obfuscated Android malware application. Type Hierarchies # The H key allows the examination of type hierarchy, such as parent classes, descendant classes, implemented interfaces, etc. Object Overrides # The O key allows the examination of overrides, such as virtual method redefinitions in the case of object-oriented bytecode files. Rebasing Constants # This feature allows the selection of the radix used to render immediate constant integers. Press the B key repeatedly to cycle through the bases offered by the plugin. Typically, bases 8, 10, 16 are offered. Some plugins may offer additional bases such as base 2, or non-conventional representation modes, such as character-based immediate rendering. Auto-Rename All # This action may be offered by plugins to allow blanket renaming of all items to automatically-generated names. Info The DEX plugin provides this option to auto-rename types, fields, and methods to better names if they have been obfuscated to unreadable or compressed strings. Have a look at the Android section to learn more.","title":"Common Actions"},{"location":"actions.html#decompiling","text":"The next section covers decompiling code in depth.","title":"Decompiling"},{"location":"actions.html#graphing","text":"Users can alternate between the default interactive full disassembly view and the interactive control flow graph of the currently examined method/routine. Press the Space key to go back and forth. In some circumstances, users may prefer graph navigation. CFG fragment of a routine","title":"Graphing"},{"location":"actions.html#renaming","text":"An important requirement for analysts is the ability to rename code items such as types, methods and routines, fields and data items, packages, etc. consistently across a code base. Position the caret on the item to be renamed Hit the N key or select Action, Rename Enter the new name and press Enter Tip Within the Rename dialog box, press Ctrl+Space (Command+Space on macOS) to bring up your renaming history.","title":"Renaming"},{"location":"actions.html#commenting","text":"When in a code view, press the / (slash) key to add a comment. Warning Comments are attached to addresses or items, therefore make sure to be on a valid address - else no comment can be attached. The caret address is always displayed in the status bar:","title":"Commenting"},{"location":"actions.html#navigating","text":"Pressing the Enter key on an item or double-clicking it will bring the caret to the definition of the item. You can navigate backward and forward using the traditional Alt + Arrow Left (or Escape ) and Alt + Arrow Right key combos, or via the Navigation menu. The Next Item and Previous Item command allow you to jump to the similar item after or before the currently selected item.","title":"Navigating"},{"location":"actions.html#cross-references","text":"Cross-references on an item allow the examination of items referencing it. Press the X key to visualize them. You can jump to a cross-reference by double-clicking it. The cross-reference dialog generally includes additional information attached to the referenced location. That information is plugin-dependent. Below, the Details column provides the kind of reference (on a field item, in that case), e.g. a GET (read), or something else.","title":"Cross-references"},{"location":"actions.html#type-hierarchies","text":"Use the T key on a type item (such as a class or an interface) to visualize its ancestors and children. Double-click on a type item to jump to the item definition.","title":"Type Hierarchies"},{"location":"actions.html#restructuring","text":"The Create Package and Move to Package actions offer powerful refactoring possibilities, especially useful in the case of large obfuscated binary files. If the module supports it, users are able to: Create artificial packages (aka, namespaces) using the K key. Move items, such as types, to existing or artificial packages using the L key. Workflow The following screenshot is an example where the class AppHelp was moved from the com.pnfsoftware.raasta package to a newly created package named com.abc . Info Have a look at our YouTube demo video that demonstrates advanced refactoring and automatic restructuring of a heavily obfuscated Android malware application.","title":"Restructuring"},{"location":"actions.html#type-hierarchies_1","text":"The H key allows the examination of type hierarchy, such as parent classes, descendant classes, implemented interfaces, etc.","title":"Type Hierarchies"},{"location":"actions.html#object-overrides","text":"The O key allows the examination of overrides, such as virtual method redefinitions in the case of object-oriented bytecode files.","title":"Object Overrides"},{"location":"actions.html#rebasing-constants","text":"This feature allows the selection of the radix used to render immediate constant integers. Press the B key repeatedly to cycle through the bases offered by the plugin. Typically, bases 8, 10, 16 are offered. Some plugins may offer additional bases such as base 2, or non-conventional representation modes, such as character-based immediate rendering.","title":"Rebasing Constants"},{"location":"actions.html#auto-rename-all","text":"This action may be offered by plugins to allow blanket renaming of all items to automatically-generated names. Info The DEX plugin provides this option to auto-rename types, fields, and methods to better names if they have been obfuscated to unreadable or compressed strings. Have a look at the Android section to learn more.","title":"Auto-Rename All"},{"location":"android-debugging.html","text":"JEB supports debugging Dalvik code via JDWP and Native *.so libraries via gdb/lldb. A debugging session allows seamless transition between debugging the Dalvik VM, jumping into native methods invoked via JNI, debugging native code (arm, x86, else), and switching back to Dalvik. Previous material It is recommended to read the generic debugging page first. Prerequisites # The Android debuggers run on all JEB-supported platforms (Windows, Linux, macOS). Verify the following before attempting to start a debugging session: Make sure to have the Android SDK installed. Ideally, you also want to have either ANDROID_SDK_ROOT or ANDROID_SDK environment variable pointing to the SDK folder. Enable Developer options and allow USB debugging on the intended physical target device. (Debugging is enabled by default on the emulators.) On physical devices running Android 4.2 and above, one way to make sure that USB debugging is enabled is to run the adb devices command. If the device is shown as unauthorized , a pop-up on your phone will appear to request authorization. Fundamentals # There are two types of debuggable entities on Android OS: Android/Linux processes Higher-level Dalvik virtual machines, running inside processes Debugging is generally performed remotely, on a separate computer. Nothing prevents you from debugging on the device itself though. Dalvik VM debugging is done over the Java Debug Wire Protocol (JDWP) protocol. The JDWP server runs inside the process hosting the DVM. JEB implements the JDWP client. Native code debugging is done via ptrace(2) . On device a debugger server process, generally gdb or lldb, runs alongside the target process and controls it via ptrace. JEB implements a gdb/lldb client. The DVM runs inside a native process Debugging non-debuggable apps # Normally, only apps whose Android Manifest explicitly has a debuggable flag set to true are debuggable. However, this is rarely the case when analyzing in-the-wild malware or production applications. In such cases, you have several options: Run the app in an emulator. Emulators have the ro.debuggable property set to 1 (with an exception, see note below). This means they will debug all apps, regardless of the debuggable flag in the Manifest. In several scenarios, this may not be enough since several components, in the OS or the app itself, may check for the Manifest's debuggable flag before or during the app execution. Use a rooted phone. A rooted phone will allow you to modify the ro.debuggable property, and change it from 0 (standard on production devices) to 1. A rooted phone will also allow you to install additional low-level programs to ease debugging and potentially solve problems mentioned in the above bullet point. (The rooting process is out-of-scope here: it is device-specific and rooting instructions can easily be found online.) Repackage your app. This may be the simplest option. Use JEB's built-in tool makeapkdebug to generate a debuggable app. You will have to sign the repacked app using your own key; be aware of the implications if you choose that option. See below for more details. Warning If you choose to debug in a Google-provided emulator image, make sure to use a non \"Google Play image\". Those images are locked down production images. Instead, use a \"Google APIs image\" or a vanilla image (that doesn't ship with Google-specific libs). Native code in non-debuggable apps # When it comes to debugging native code of non-debuggable apps on a rooted phone or emulator, other limitations apply. JEB tries its best at abstracting them away. However, things might be unstable depending on which phone and OS is being used. Do not hesitate to let us know if you encounter issues. Info Some limitations stem from the trusted run-as Android utility, which verifies whether an app is marked debuggable, regardless of the system's overall debuggability. JEB ships with a modified version of the utility, named ranod , which does not perform such checks. Decompiling the x86 build of run-as Note that most of our tests are done on Pixel devices running vanilla Android Oreo. Using similar devices for debugging will likely reduce the chances of running into corner-case problematic situations. Generating a debuggable APK # It is generally easier to debug Android applications explicitly marked debuggable in their Manifest: <application android:debuggable=\"true\" ...>; JEB has built-in utility to rebuild a non-debuggable APK into a debuggable one, while maintaining the entire structure of the application intact, except for its signing data of course. Navigate to your JEB folder, and use the start-up script, e.g. on Windows: $ jeb_wincon.bat -c --makeapkdebug -- file.apk Upon success, file_debuggable.apk will be generated. Sign it using the Android SDK's apksigner , e.g. on Windows: $ apksigner.bat sign -ks SOME_KEYSTORE.JKS file_debuggable.apk Install it on your device, and start debugging. Warning Keep in mind that this solution has shortcomings: Anti-debugging code may check at runtime that the app is not debuggable, as would be expected. More elaborate protections may implement certificate pinning-style checks, where the code verifies that it is signed using a specific certificate. Starting a debugging session # Android debugging sessions can be started when analyzing APK files. If your main artifact is an orphan DEX file, the client will refuse to start a debugging session. First, retrieve your target APK and get the app ready for debugging: Make sure the APK matches the one that will be executed on the target phone. You can download the APK using adb : adb shell pm list packages -f to retrieve a list of packages and the associated path to APK adb pull <pathToAPK> to download the APK Start the app on the phone Via the App Launcher for instance, if attaching to an already running app is an acceptable scenario If you want the app to wait for the debuggers to attach to it before it starts executing any code, you can run something like: adb shell am start -D -S -n <packageName>/<activityName> A pop-up will be displayed on the phone, indicating it is waiting for a debugger to attach to the VM Second, in the UI client: Load the APK file Open a view of a primary DEX unit Once the focus is on the DEX view, open the Debugger menu, and click on Start... The Debugger/Start command, used to start or attach a debugger, is available once the code view of a supported code unit has the focus. Here, the focus was on Dalvik bytecode. In the Attach dialog window: Select the target phone and the target process that matches your app, and click Attach. Unless you tick the \"Suspend all threads\", The app will be immediately be run/resumed after attaching. The process filter is normally filled out with the APK package name. Simply press enter to filter out entries. Heads-up Tick \"Allow children debuggers\" if you wish to debug native code as well. Common problems # Unable to debug native code of an Android app? Make sure to tick the box \"Allow children debuggers\" before attaching. Impossibility to read (most) local vars in Dalvik The issue is very likely to be one affecting Android Pie and Q. We wrote a blog explaining the details of the problem (unfortunately, not a fixable one). If possible, switch to something <=Oreo or upgrade your test device to Android R, since it appears the issue was fixed on R DP1 and above. Cannot attach to a non-debuggable app but the phone is rooted Having a rooted phone is not enough. System components checks for the app's debuggability (i.e., the Manifest's android:debuggable flag) in various places, regardless of whether the image is a locked production image, rooted image, debug or dev build, etc. While it is relatively easy to do JDWP debugging, native debugging is generally more tricky. JEB does a few things to ease settings things up: - It attempts to set the system property ro.debuggable to 1 - It attempts to replace the run-as utility by one that does not check the debuggable flag (more details later in this doc). In order to do any of the above, root privilege is required, and JEB assumes the su tool has been dropped in a standard location ( /bin/su, /sbin/su, /system/bin/su, system/xbin/su, /data/local/su, /data/local/bin/su, /data/local/xbin/su, /system/sd/xbin/su, /system/bin/failsafe/su, /su/bin/su ). Files may have to be dropped in the /system folder. That folder is read-only by default and needs to be remounted read-write. Root privileges may not suffice: if you are using an emulator, configuration may default to a read-only system image. You will need to explicitly specify that the system can be written to, e.g.: $ <SDK>/emulator/emulator -avd [image_folder_name] -writable-system JEB also attempts to disable SEAndroid by issuing a setenforce 0 command. The above may not suffice. Your mileage may vary. Whenever possible, we encourage debugging on the Lolipop-Oreo range (5.0 to 8.1) on vanilla images. Ideally, you'll want to have a debuggable app. Again, it may not be always possible or realistic (e.g., debugging a system app and a custom vendor's locked image), but in many cases (e.g., malware analysis), it is possible. Debugger nodes # After attaching, the app, you should see one or two additional nodes in the Project tree view. One debugger node for Dalvik, an optional debugger node for native code. Two debugger nodes ( VM , Process ) attached to the target Note When a debugger is successfully attached, the corresponding node has a light green background. Additional views and fragments displaying the debuggers' states and commands are added to the workspace: Native threads # Caution Keep in mind that pausing the Process debugger (i.e., suspending the native threads) will freeze the higher-level Dalvik VM! An app's Dalvik VM runs inside a Linux process. Therefore, any action taken using the native debugger (if native debugger was attached) may affect a VM debugging session as well. Dalvik debugging # Active debugger # In the general case, the focused UI fragment will determine which debugger will receive input commands. Therefore, be mindful of which debugger is being controlled when invoking commands (via menu entries, toolbar or keyboard). E.g., if the focus is on a DEX view, the controls are connected to the VM (Dalvik) debugger; if the focus is within a code view connected to the Process debugger, the controls are connected to the Process debugger. Controls # Standard debugger controls can be accessed via the Debugger menu or the toolbar area. They allow: Attaching, detaching, terminating the process Pausing and resuming the process and, possibly, its individual threads Stepping (into, over, out of) Toggling execution breakpoints Not all controls can or are implemented for both debuggers. Currently for instance, pausing individual threads of the Process debugger is not possible. When a control is not available, depending on which control it is and the severity of the failed operation, the user may be unable to activate it (e.g., grayed button), receive an error in the logger, or receive a pop-up error in the client. Setting breakpoints # Breakpoints can be set/unset using the handy Control+B (Command+B on macOS) shortcut. An icon is displayed in the left vertical bar of a code view to represent enabled/disabled breakpoints. Two breakpoints, one is enabled, the other one is disabled Note Toggling breakpoints on and off is currently not available in decompiled views. Registering additions # When starting a debugging session, the debugger attaches to an APK's DEX unit as well as subsequent compatible code units dynamically added to your Project. However, in some cases, the debugger will not automatically pick up and attach to additional DEX units (e.g., nested DEX units). You may ask the debugger to register additional code units via the Debugger, Register Addition action: The handler will be enabled and can be invoked when a debugger fragment has the focus We are attaching classes.jar to the current debugging Views and fragments # Threads # The Threads view displays thread identifiers, status (running, suspended, waiting, etc.) as well as the stackframes when a thread is paused. Depending on the target processor, there may be one or more stackframes, showing the location (program counter register or address) of the current thread. Info Full status list: CREATED, RUNNING, PAUSED (=SUSPENDED), SLEEPING, WAITING, ZOMBIE, MONITOR, TERMINATED. Not all status may be relevant to a given architecture. The default thread can be selected by double-clicking or right-clicking, Set as default thread . By default, when a breakpoint is hit, only the active thread is suspended . The other threads are not. Other threads can be suspended with Terminal commands. A suspended thread after execution hit a breakpoint Breakpoints # The Breakpoints view displays active and inactive code breakpoints. Note The JEB API allows settings breakpoints on instructions and breakpoint on methods (method entry, method exit). Other capabilities exist, not readily available in UI client, e.g. breakpoint on class load event, breakpoint on exception, etc. Two breakpoints, one is enabled, the other one is disabled Locals # The Locals view displays generic variables registers. They can be virtual slots of a VM, registers of a native process, complex variables inferred by the decompiler, etc. For JDWP, what is displayed is: the current this locals of the selected (and paused) thread's top frame; variables for other frames can be examined via Terminal commands Primitives and String values can be updated. click on the cell of the value to be written, in the Value column set the new value and press Enter Updating a String object Note that JEB attempts to maintain the state of this fragment across your debugging sessions, even though variables references, values (and subs) may change as you step through code, etc. JEB does its best at displaying very large arrays efficiently as well. However, keep in mind that adb is slow, and maintaining live variable views up-to-date across a stepping can be costly. Variable types For safety reasons, Dex metadata providing locals types and/or names information is entirely disregarded, since it cannot be trusted and using bad types can crash the DVM server. See the sub-section below about JDWPD caveats. Live overlays # Hover over a variable, register, or field to see its contents. The thread must be paused. Hovering over p0 (equivalent to v7 in the examined method) Other fragments # The Stack and Memory fragments are irrelevant for JDWP debugging JDWP caveats # Info This short section highlights limitations pertaining the Dalvik debugging via JDWP, both on the server (device) and the client (JEB) side. JDWP was specified and designed by Oracle for the Java VM. The Dalvik VM implements parts of the specifications and the Binary Protocol . Capabilities # The Capabilities and CapabilitiesNew commands of the VirtualMachine command set can be used to retrieve the list of features offered by a JDWP server. E.g., register watches are not supported by the Dalvik debugger server. Although the JEB Android debugging modules implement JDWP with regards to what the Dalvik JDWP server provides, not all JDWP are currently exposed through the UI client or even API. E.g., JDWP allows debugger clients to specify if one or all threads should be stopped when a breakpoint is hit; currently, JEB debugger API does not provide a method to control that setting. Variable typing # Why are most locals typed as 'int' by default? The general reason is safety. Caution The Dalvik VM will crash the JDWP server attempts to read a non-reference as a reference; most non-references are obvious (e.g., 1, 2, small ints -> non refs.) but some ints may not be - relying on DEX metadata is also unsafe. However, most variables can be retyped. Click on a type cell to edit contents: Changing the type of v0 to long: type long , press Enter. The resulting value is the long interpretation of {v0,v1} Changing the type of p0 to object: type object , press Enter. If the reference truly is an object, the correct type will be retrieved. If it is not, the VM may crash. Interpreter Commands # The debugger units implement IUnit.getCommandInterpreter method to provide clients with command interpreters used to execute fine-grained debugger commands that may not be readily available in the UI client. All command interpreters are accessible via the Console tab. Once the Android debuggers are attached, switch over to the Console view, and type list . This command will list all command interpreters currently attached to the console: A terminal that can be bound to 3 command interpreters, including two provided by active Debugger units An interpreter has a numeric id as well as the name of the unit that created it. Switch to an interpreter with the use <id|name> command. The special command help , available in all interpreter contexts, lists all commands made available by the interpreter currently in use. > list 3 interpreters available (0) py: Python Interpreter (built on Jython 2.7) (1) VM: Debugger interpreter for VM (2) Process: Debugger interpreter for Process > use 1 VM> help info : Display basic information about the debuggee libs|modules [name-filter] : Display information about the target modules resume [tid] : Run or resume the target, a thread, or the default thread (tid 0) pause : Pause the target detach : Detach the target (if possible) kill|terminate : Kill the target (unstable) threads : List the process threads thread [tid] : Set or get the default thread step|stepi : Step \"into\" one instruction in the default thread stepo : Step \"over\" one instruction in the default thread stepu : Step \"up\"/\"out\" (run until return) in the default thread b|bp [address] : Set or list breakpoints bc [index] : Clear one or all breakpoints frameSlotIndexMode mode : Set the index type used to retrieve thread frames' variables (AUTO, PAR, VAR) classes : List the classes loaded by the VM signature|sig [OPTION]... cid : Information about a specific class fields [OPTION]... cid : List the fields of a type methods [OPTION]... cid : List the methods of a type call|invoke [OPTION]... cid method : invoke a method. read|get [OPTION]... objectId : Read an object or array. set [OPTION]... objectId new_value : Set a method variable or parameter as a typed-value pull remotePath localPath : adb-pull on steroid VM> Warning Many commands can only run when the target or target thread is suspended or paused. Hint Type help <command> to see specific help for that command. Hint Press Enter on a white-line to repeat the previously executed command. There are three types of commands in the VM interpreter: program commands: info, libs, detach, kill, pull thread commands: thread, threads, pause, resume, step, stepo, stepu, b, bc object-interaction commands: classes, sig, fields, methods, call, get, set Program commands # info will provide information about JDWP. Below, Java 8 and JVM-DI 2. VM> info Debuggee is running on ? VM information: JDWP:\"Java Debug Wire Protocol (Reference Implementation) version 1.8 JVM Debug Interface version 1.2 JVM version 8 (Dalvik, )\" v1.8 (VM:Dalvik v8) VM identifier sizes: f=8,m=8,o=8,rt=8,fr=8 libs will always be empty for a JDWP debugger: libraries are not application to Dalvik bytecode running in a VM. Info A native debugger's libs command does provide information. detach will attempt to detach the target without killing it kill will terminate the target process (and therefore detach from it as well) pull is similar to adb pull ... but will make use of the su binary to elevate privileges when necessary (assuming su be present and found on the target device). Thread commands # thread is used to retrieve or set the default thread, i.e. the thread to which most commands will be applied to if no thread id is explicitly provided. threads lists the threads and their states pause suspends the target: all threads will be suspended resume resumes the target: all threads will be resumed. Warning Keep in mind that pausing/resuming actions are stacked. E.g., a a thread X was already suspended, executing pause , then resume , will not resume thread X. step or stepi is used to perform a single-step, and enter methods (Dalvik or Native) if necessary stepo performs a single-step but does not enter methods. stepu will step until the current method returns. b is used to list or add breakpoints, e.g.: VM> b 0 - Lcom/xyz/appcheck/AppCheck;->runTest(Lcom/xyz/appcheck/TestId;)Z+23Ah [enabled: true] 1 - Lcom/xyz/appcheck/AppCheck;->runTest(Lcom/xyz/appcheck/TestId;)Z+246h [enabled: false] 2 - Lcom/xyz/appcheck/AppCheck;->runTest(Lcom/xyz/appcheck/TestId;)Z+240h [enabled: true] VM> b Lcom/xyz/appcheck/AppCheck;->runTest(Lcom/xyz/appcheck/TestId;)Z+218h Lcom/xyz/appcheck/AppCheck;->runTest(Lcom/xyz/appcheck/TestId;)Z+218h (u={Unit:name={Bytecode},type={dex}},a={Lcom/xyz/appcheck/AppCheck;->runTest(Lcom/xyz/appcheck/TestId;)Z+218h}) [enabled=true] bc is used to clear one or all breakpoints. Class/object commands # classes lists all currently loaded classes. Not all classes of an app may be loaded when the command is executed. Info Classes (and generally, types) are referenced by their canonical JVM name or their cid (internal id representing a type during for a given debugging session). A target class can also be inferred from an object reference: this object the object id, prefixed with @ character any object that can be referenced from these ones. sig retrieves information about a particular class fields and methods are used to list the fields of a type, e.g.: VM> methods Ljava/lang/String; sig=Ljava/lang/String;,genSig=Ljava/lang/Object;Ljava/io/Serializable;Ljava/lang/Comparable<Ljava/lang/String;>;Ljava/lang/CharSequence; 98 methods: - id=1876278024,name=<clinit>,sig=()V,genSig=,mod=8h - id=1876278064,name=<init>,sig=()V,genSig=,mod=1h - id=1876278104,name=<init>,sig=(II[C)V,genSig=,mod=0h - id=1876278144,name=<init>,sig=(Ljava/lang/String;)V,genSig=,mod=1h ... VM> methods this.mActionBar sig=Lcom/android/internal/app/WindowDecorActionBar;,genSig= 110 methods: - id=494344081864,name=<clinit>,sig=()V,genSig=,mod=8h - id=494344081904,name=<init>,sig=(Landroid/app/Activity;)V,genSig=,mod=1h - id=494344081944,name=<init>,sig=(Landroid/app/Dialog;)V,genSig=,mod=1h - id=494344081984,name=<init>,sig=(Landroid/view/View;)V,genSig=,mod=1h - id=494344082024,name=access$000,sig=(Lcom/android/internal/app/WindowDecorActionBar;)Z,genSig=,mod=F0001008h - id=494344082064,name=access$100,sig=(Lcom/android/internal/app/WindowDecorActionBar;)Landroid/view/View;,genSig=,mod=F0001008h ... call is used to invoke any method on objects or classes. Arguments must be separated by commas, e.g. VM> call this toString string@9399:\"com.xyz.appcheck.AppCheck@7d6f5da\" Warning Code is executed on the target when using the call command. The target state may be modified. get and set are used to read and write stack-frame local variables (similar to what the Locals view provide), e.g.: VM> set this.vArrayInt [I{1, 2, 3} VM> set this.mystring \"FOOBAR\" VM> get this.mystring string@1234:\"FOOBAR\" Hint The interpreters support auto-completion with the Tab key. Native debugging # Note This section assumes that the app has bytecode and native libraries stored in the standard APK's lib/ folder. To debug native code only (Android or not), you will need to start gdbserver on the target manually, and connect remotely ( Debugger, Attach, Remote tab). Native debugging of Android apps is done remotely over the gdb protocol and the lldb extensions. JEB implements a gdb/lddb client and connects to the on-device gdb-server/lldb-server. By default, lldb-server is the preferred debugger server dropped on the target. Warning When attaching to the target app, remember to tick \"Allow Children Debuggers\". Needless to say, it is worth getting familiar with x86 and arm assembly (preferably their 64-bit variants, for which getting acquainted with their 32-bit parent if necessary). Active Debugger # Focus a fragment related to native debugging to ensure debugging commands are issued to the native debugger. If the Terminal is opened, the prompt will change to Process to reflect the change as well: interpreter commands will be issued to the gdbserver. Issue an info command, you should see basic target information, e.g.: Process> info Debuggee is running on ARM64 (LITTLE_ENDIAN) Target process id: 19218 Target is being debugged by lldb-server A breakpoint was hit in a SO file, and all native threads are paused Native threads vs VM threads # Warning Always remember that the Dalvik VM runs within the Native process, and that VM threads are backed by Native threads. That includes the JDWP server thread as well! If you pause Native threads, the VM threads will freeze as well, despite what the Dalvik debugger fragments may indicate. This \"nested debuggers\" situation, if not managed properly, can lead to strange situations, and in fine, the JDWP debugger may lose control of the target. Rules of thumb: when debugging native code, do not attempt to interact with the JDWP debugger make sure the Native process is not paused when issuing JDWP commands, e.g., unless necessary/wanted, you should disable Native breakpoints that may be hit and interrupt a VM debugging session abruptly Java to Native code transitions # Dalvik code can call into Native code by invoking methods with that have the Java modifier (attribute) native . Set a breakpoint on the dispatch instruction, not on the Java native method itself. When the breakpoint is hit, issue a Step Into command to auto-switch to Native code debugging Be patient, native code analysis is taking place as you're switching code The native breakpoint was automatically created and will be automatically released upon returning to Dalvik Resume native debugging to go back to Dalvik; the code will auto-break on return from invoke-xxx Example: Source: Java code: package com.xyz.appcheck ; class AppCheck { static { System . loadLibrary ( \"somelib\" ); } ... String foo () { ... return getPlatform (); } public native String getPlatform (); } ... C code: jstring Java_com_xyz_appcheck_AppCheck_getPlatform ( JNIEnv * env , jobject thiz ) { ... } Transition in JEB: How was Java's com.xyz.appcheck.AppCheck.getPlatform linked to C's Java_com_xyz_appcheck_AppCheck_getPlatform ? The process of binding Java methods to native methods (in the case above, binding was done automatically), as well as input and output object conversions and the library code to manipulate them while executing native code, is defined in the Java Native Interfaces specifications. JNI basics # Method linking and dispatching is an important aspect of JNI, which reverse-engineers should understand in order to work around difficult cases, including Java methods statically linked. Dynamic linking # When a native Java method is executed, the VM will look for a native method having: the following name: Short_Form= \"Java_\" + mangled_classname + \"_\" + mangled_methodname or, if the method is overloaded, the following name: Long_Form = Short_Form + \"__\" + mangled_argsigs The mangling scheme is the following: . => _ / => _ _ => _1 ; => _2 [ => _3 \\uXXXX => _0xxxx (unicode char.) Types names for mangled_argsigs are using the canonical JVM convention: boolean => Z byte => B char => C short => S int => I long => J float => F double => D classname => La/b/c/SomeClass; Details For additional details, refer to this part of the official specifications. Examples for auto-binding: void f(int x) in class com.xyz.A => short form: Java_com_xyz_A_f => long form: Java_com_xyz_A_f__I void g(long array[], String s) in class com.\\x4f60\\x597d => short form: Java_com__04f60_0597d_g => long form: Java_com__04f60_0597d_g___3JLjava_lang_String_2 Static linking # Native libraries can use the JNI function RegisterNatives to manually bind native methods to Java counterparts, while not adhering to the JNI naming convention used for dynamic linking. RegisterNatives can be called anywhere. Example In the snippet, a Java method a.b.c.Foo.methodX()V is bound to a static, non-exported native method routineX . jint JNI_OnLoad ( JavaVM * vm , void * reserved ) { JNIEnv * env = NULL ; if ( vm -> GetEnv ( & env , JNI_VERSION_1_4 ) != JNI_OK ) { return - 1 ; } if ( registerNatives ( env ) != JNI_TRUE ) { return - 1 ; } return JNI_VERSION_1_4 ; } int registerNatives ( JNIEnv * env ) { if ( ! registerNativeMethods ( env , classPathName , methods , sizeof ( methods ) / sizeof ( methods [ 0 ]))) { return JNI_FALSE ; } return JNI_TRUE ; } int registerNativeMethods ( JNIEnv * env , const char * className , JNINativeMethod * gMethods , int numMethods ) { jclass clazz = env -> FindClass ( className ); if ( clazz == NULL ) { return JNI_FALSE ; } if ( env -> RegisterNatives ( clazz , gMethods , numMethods ) < 0 ) { return JNI_FALSE ; } return JNI_TRUE ; } static const char * classPathName = \"a/b/c/Foo\" ; static JNINativeMethod methods [] = { { \"methodX\" , \"()V\" , ( void * ) routineX }, }; // bound to Java method: a.b.c.Foo.methodX()V static jint JNICALL routineX ( JNIEnv * env , jobject thiz , jint a , jint b , jint c ) { //... } Additional views # On top of the usual debugger fragment that were described in the Dalvik debugger section (threads, breakpoints, locals), native debuggers provide additional fragments. Memory code # The memory fragment displays the data and instructions located at any address within the target process. It is helpful in many situations, such as: - simple memory exploration and scanning - snooping around Dalvik VM internal structures, and modifying them - single-stepping over code outside the analyzed .so files contained in the app's lib/ folder A situation where the third scenario arises is when entering library code located somewhere in the process memory, outside a pre-analyzed so file. The execution will seem to have stalled in the main view (fixed blue line). Switch to the Memory Code fragment to see what is being executed. Stack # The stack view is similar to the memory fragment: it represents words of memory located at around the standard stack pointer on the target architecture (esp, rsp, r13, x31, etc.). Additional interpreter commands # ... Settings # The Android debuggers offer options to control low-level debugger parameters, such as ports and timeouts. Filter on dbug_apk and dbug_elf in the Engines options: The full documentation of each option can be found on this page . API, Scripts, Plugins # Debugger modules in implement the set of interfaces contained in the com.pnfsoftware.jeb.core.units.code.debug package. The principal interface in this package is IDebuggerUnit . Plugins, scripts, or third-party clients wishing to automate the usage of debuggers can use these well-defined interfaces. The official UI client uses this public API as well. Anything that the UI client does can be done and/or automated by third-party code. Example Check out our blog post on Android crypto primitives hooking to see how the API can be used to retrieve pre-encryption or post-decryption data on the fly. Further Reading # A note on debugging caveats with recent Android versions (p, Q): Debugging Android apps on Android Pie and above API/Scripting: Crypto Monitoring with the Android Debuggers API Use-case, obfuscation: Defeating AppSolid Android application protector Use-case, dynamic dex: Debugging Dynamically Loaded DEX Bytecode Files JNI debugging helper: Dynamic JNI Detection Plugin Reference: List to all blog articles on debugging","title":"Android Debugging"},{"location":"android-debugging.html#prerequisites","text":"The Android debuggers run on all JEB-supported platforms (Windows, Linux, macOS). Verify the following before attempting to start a debugging session: Make sure to have the Android SDK installed. Ideally, you also want to have either ANDROID_SDK_ROOT or ANDROID_SDK environment variable pointing to the SDK folder. Enable Developer options and allow USB debugging on the intended physical target device. (Debugging is enabled by default on the emulators.) On physical devices running Android 4.2 and above, one way to make sure that USB debugging is enabled is to run the adb devices command. If the device is shown as unauthorized , a pop-up on your phone will appear to request authorization.","title":"Prerequisites"},{"location":"android-debugging.html#fundamentals","text":"There are two types of debuggable entities on Android OS: Android/Linux processes Higher-level Dalvik virtual machines, running inside processes Debugging is generally performed remotely, on a separate computer. Nothing prevents you from debugging on the device itself though. Dalvik VM debugging is done over the Java Debug Wire Protocol (JDWP) protocol. The JDWP server runs inside the process hosting the DVM. JEB implements the JDWP client. Native code debugging is done via ptrace(2) . On device a debugger server process, generally gdb or lldb, runs alongside the target process and controls it via ptrace. JEB implements a gdb/lldb client. The DVM runs inside a native process","title":"Fundamentals"},{"location":"android-debugging.html#debugging-non-debuggable-apps","text":"Normally, only apps whose Android Manifest explicitly has a debuggable flag set to true are debuggable. However, this is rarely the case when analyzing in-the-wild malware or production applications. In such cases, you have several options: Run the app in an emulator. Emulators have the ro.debuggable property set to 1 (with an exception, see note below). This means they will debug all apps, regardless of the debuggable flag in the Manifest. In several scenarios, this may not be enough since several components, in the OS or the app itself, may check for the Manifest's debuggable flag before or during the app execution. Use a rooted phone. A rooted phone will allow you to modify the ro.debuggable property, and change it from 0 (standard on production devices) to 1. A rooted phone will also allow you to install additional low-level programs to ease debugging and potentially solve problems mentioned in the above bullet point. (The rooting process is out-of-scope here: it is device-specific and rooting instructions can easily be found online.) Repackage your app. This may be the simplest option. Use JEB's built-in tool makeapkdebug to generate a debuggable app. You will have to sign the repacked app using your own key; be aware of the implications if you choose that option. See below for more details. Warning If you choose to debug in a Google-provided emulator image, make sure to use a non \"Google Play image\". Those images are locked down production images. Instead, use a \"Google APIs image\" or a vanilla image (that doesn't ship with Google-specific libs).","title":"Debugging non-debuggable apps"},{"location":"android-debugging.html#native-code-in-non-debuggable-apps","text":"When it comes to debugging native code of non-debuggable apps on a rooted phone or emulator, other limitations apply. JEB tries its best at abstracting them away. However, things might be unstable depending on which phone and OS is being used. Do not hesitate to let us know if you encounter issues. Info Some limitations stem from the trusted run-as Android utility, which verifies whether an app is marked debuggable, regardless of the system's overall debuggability. JEB ships with a modified version of the utility, named ranod , which does not perform such checks. Decompiling the x86 build of run-as Note that most of our tests are done on Pixel devices running vanilla Android Oreo. Using similar devices for debugging will likely reduce the chances of running into corner-case problematic situations.","title":"Native code in non-debuggable apps"},{"location":"android-debugging.html#generating-a-debuggable-apk","text":"It is generally easier to debug Android applications explicitly marked debuggable in their Manifest: <application android:debuggable=\"true\" ...>; JEB has built-in utility to rebuild a non-debuggable APK into a debuggable one, while maintaining the entire structure of the application intact, except for its signing data of course. Navigate to your JEB folder, and use the start-up script, e.g. on Windows: $ jeb_wincon.bat -c --makeapkdebug -- file.apk Upon success, file_debuggable.apk will be generated. Sign it using the Android SDK's apksigner , e.g. on Windows: $ apksigner.bat sign -ks SOME_KEYSTORE.JKS file_debuggable.apk Install it on your device, and start debugging. Warning Keep in mind that this solution has shortcomings: Anti-debugging code may check at runtime that the app is not debuggable, as would be expected. More elaborate protections may implement certificate pinning-style checks, where the code verifies that it is signed using a specific certificate.","title":"Generating a debuggable APK"},{"location":"android-debugging.html#starting-a-debugging-session","text":"Android debugging sessions can be started when analyzing APK files. If your main artifact is an orphan DEX file, the client will refuse to start a debugging session. First, retrieve your target APK and get the app ready for debugging: Make sure the APK matches the one that will be executed on the target phone. You can download the APK using adb : adb shell pm list packages -f to retrieve a list of packages and the associated path to APK adb pull <pathToAPK> to download the APK Start the app on the phone Via the App Launcher for instance, if attaching to an already running app is an acceptable scenario If you want the app to wait for the debuggers to attach to it before it starts executing any code, you can run something like: adb shell am start -D -S -n <packageName>/<activityName> A pop-up will be displayed on the phone, indicating it is waiting for a debugger to attach to the VM Second, in the UI client: Load the APK file Open a view of a primary DEX unit Once the focus is on the DEX view, open the Debugger menu, and click on Start... The Debugger/Start command, used to start or attach a debugger, is available once the code view of a supported code unit has the focus. Here, the focus was on Dalvik bytecode. In the Attach dialog window: Select the target phone and the target process that matches your app, and click Attach. Unless you tick the \"Suspend all threads\", The app will be immediately be run/resumed after attaching. The process filter is normally filled out with the APK package name. Simply press enter to filter out entries. Heads-up Tick \"Allow children debuggers\" if you wish to debug native code as well.","title":"Starting a debugging session"},{"location":"android-debugging.html#common-problems","text":"Unable to debug native code of an Android app? Make sure to tick the box \"Allow children debuggers\" before attaching. Impossibility to read (most) local vars in Dalvik The issue is very likely to be one affecting Android Pie and Q. We wrote a blog explaining the details of the problem (unfortunately, not a fixable one). If possible, switch to something <=Oreo or upgrade your test device to Android R, since it appears the issue was fixed on R DP1 and above. Cannot attach to a non-debuggable app but the phone is rooted Having a rooted phone is not enough. System components checks for the app's debuggability (i.e., the Manifest's android:debuggable flag) in various places, regardless of whether the image is a locked production image, rooted image, debug or dev build, etc. While it is relatively easy to do JDWP debugging, native debugging is generally more tricky. JEB does a few things to ease settings things up: - It attempts to set the system property ro.debuggable to 1 - It attempts to replace the run-as utility by one that does not check the debuggable flag (more details later in this doc). In order to do any of the above, root privilege is required, and JEB assumes the su tool has been dropped in a standard location ( /bin/su, /sbin/su, /system/bin/su, system/xbin/su, /data/local/su, /data/local/bin/su, /data/local/xbin/su, /system/sd/xbin/su, /system/bin/failsafe/su, /su/bin/su ). Files may have to be dropped in the /system folder. That folder is read-only by default and needs to be remounted read-write. Root privileges may not suffice: if you are using an emulator, configuration may default to a read-only system image. You will need to explicitly specify that the system can be written to, e.g.: $ <SDK>/emulator/emulator -avd [image_folder_name] -writable-system JEB also attempts to disable SEAndroid by issuing a setenforce 0 command. The above may not suffice. Your mileage may vary. Whenever possible, we encourage debugging on the Lolipop-Oreo range (5.0 to 8.1) on vanilla images. Ideally, you'll want to have a debuggable app. Again, it may not be always possible or realistic (e.g., debugging a system app and a custom vendor's locked image), but in many cases (e.g., malware analysis), it is possible.","title":"Common problems"},{"location":"android-debugging.html#debugger-nodes","text":"After attaching, the app, you should see one or two additional nodes in the Project tree view. One debugger node for Dalvik, an optional debugger node for native code. Two debugger nodes ( VM , Process ) attached to the target Note When a debugger is successfully attached, the corresponding node has a light green background. Additional views and fragments displaying the debuggers' states and commands are added to the workspace:","title":"Debugger nodes"},{"location":"android-debugging.html#native-threads","text":"Caution Keep in mind that pausing the Process debugger (i.e., suspending the native threads) will freeze the higher-level Dalvik VM! An app's Dalvik VM runs inside a Linux process. Therefore, any action taken using the native debugger (if native debugger was attached) may affect a VM debugging session as well.","title":"Native threads"},{"location":"android-debugging.html#dalvik-debugging","text":"","title":"Dalvik debugging"},{"location":"android-debugging.html#active-debugger","text":"In the general case, the focused UI fragment will determine which debugger will receive input commands. Therefore, be mindful of which debugger is being controlled when invoking commands (via menu entries, toolbar or keyboard). E.g., if the focus is on a DEX view, the controls are connected to the VM (Dalvik) debugger; if the focus is within a code view connected to the Process debugger, the controls are connected to the Process debugger.","title":"Active debugger"},{"location":"android-debugging.html#controls","text":"Standard debugger controls can be accessed via the Debugger menu or the toolbar area. They allow: Attaching, detaching, terminating the process Pausing and resuming the process and, possibly, its individual threads Stepping (into, over, out of) Toggling execution breakpoints Not all controls can or are implemented for both debuggers. Currently for instance, pausing individual threads of the Process debugger is not possible. When a control is not available, depending on which control it is and the severity of the failed operation, the user may be unable to activate it (e.g., grayed button), receive an error in the logger, or receive a pop-up error in the client.","title":"Controls"},{"location":"android-debugging.html#setting-breakpoints","text":"Breakpoints can be set/unset using the handy Control+B (Command+B on macOS) shortcut. An icon is displayed in the left vertical bar of a code view to represent enabled/disabled breakpoints. Two breakpoints, one is enabled, the other one is disabled Note Toggling breakpoints on and off is currently not available in decompiled views.","title":"Setting breakpoints"},{"location":"android-debugging.html#registering-additions","text":"When starting a debugging session, the debugger attaches to an APK's DEX unit as well as subsequent compatible code units dynamically added to your Project. However, in some cases, the debugger will not automatically pick up and attach to additional DEX units (e.g., nested DEX units). You may ask the debugger to register additional code units via the Debugger, Register Addition action: The handler will be enabled and can be invoked when a debugger fragment has the focus We are attaching classes.jar to the current debugging","title":"Registering additions"},{"location":"android-debugging.html#views-and-fragments","text":"","title":"Views and fragments"},{"location":"android-debugging.html#threads","text":"The Threads view displays thread identifiers, status (running, suspended, waiting, etc.) as well as the stackframes when a thread is paused. Depending on the target processor, there may be one or more stackframes, showing the location (program counter register or address) of the current thread. Info Full status list: CREATED, RUNNING, PAUSED (=SUSPENDED), SLEEPING, WAITING, ZOMBIE, MONITOR, TERMINATED. Not all status may be relevant to a given architecture. The default thread can be selected by double-clicking or right-clicking, Set as default thread . By default, when a breakpoint is hit, only the active thread is suspended . The other threads are not. Other threads can be suspended with Terminal commands. A suspended thread after execution hit a breakpoint","title":"Threads"},{"location":"android-debugging.html#breakpoints","text":"The Breakpoints view displays active and inactive code breakpoints. Note The JEB API allows settings breakpoints on instructions and breakpoint on methods (method entry, method exit). Other capabilities exist, not readily available in UI client, e.g. breakpoint on class load event, breakpoint on exception, etc. Two breakpoints, one is enabled, the other one is disabled","title":"Breakpoints"},{"location":"android-debugging.html#locals","text":"The Locals view displays generic variables registers. They can be virtual slots of a VM, registers of a native process, complex variables inferred by the decompiler, etc. For JDWP, what is displayed is: the current this locals of the selected (and paused) thread's top frame; variables for other frames can be examined via Terminal commands Primitives and String values can be updated. click on the cell of the value to be written, in the Value column set the new value and press Enter Updating a String object Note that JEB attempts to maintain the state of this fragment across your debugging sessions, even though variables references, values (and subs) may change as you step through code, etc. JEB does its best at displaying very large arrays efficiently as well. However, keep in mind that adb is slow, and maintaining live variable views up-to-date across a stepping can be costly. Variable types For safety reasons, Dex metadata providing locals types and/or names information is entirely disregarded, since it cannot be trusted and using bad types can crash the DVM server. See the sub-section below about JDWPD caveats.","title":"Locals"},{"location":"android-debugging.html#live-overlays","text":"Hover over a variable, register, or field to see its contents. The thread must be paused. Hovering over p0 (equivalent to v7 in the examined method)","title":"Live overlays"},{"location":"android-debugging.html#other-fragments","text":"The Stack and Memory fragments are irrelevant for JDWP debugging","title":"Other fragments"},{"location":"android-debugging.html#jdwp-caveats","text":"Info This short section highlights limitations pertaining the Dalvik debugging via JDWP, both on the server (device) and the client (JEB) side. JDWP was specified and designed by Oracle for the Java VM. The Dalvik VM implements parts of the specifications and the Binary Protocol .","title":"JDWP caveats"},{"location":"android-debugging.html#capabilities","text":"The Capabilities and CapabilitiesNew commands of the VirtualMachine command set can be used to retrieve the list of features offered by a JDWP server. E.g., register watches are not supported by the Dalvik debugger server. Although the JEB Android debugging modules implement JDWP with regards to what the Dalvik JDWP server provides, not all JDWP are currently exposed through the UI client or even API. E.g., JDWP allows debugger clients to specify if one or all threads should be stopped when a breakpoint is hit; currently, JEB debugger API does not provide a method to control that setting.","title":"Capabilities"},{"location":"android-debugging.html#variable-typing","text":"Why are most locals typed as 'int' by default? The general reason is safety. Caution The Dalvik VM will crash the JDWP server attempts to read a non-reference as a reference; most non-references are obvious (e.g., 1, 2, small ints -> non refs.) but some ints may not be - relying on DEX metadata is also unsafe. However, most variables can be retyped. Click on a type cell to edit contents: Changing the type of v0 to long: type long , press Enter. The resulting value is the long interpretation of {v0,v1} Changing the type of p0 to object: type object , press Enter. If the reference truly is an object, the correct type will be retrieved. If it is not, the VM may crash.","title":"Variable typing"},{"location":"android-debugging.html#interpreter-commands","text":"The debugger units implement IUnit.getCommandInterpreter method to provide clients with command interpreters used to execute fine-grained debugger commands that may not be readily available in the UI client. All command interpreters are accessible via the Console tab. Once the Android debuggers are attached, switch over to the Console view, and type list . This command will list all command interpreters currently attached to the console: A terminal that can be bound to 3 command interpreters, including two provided by active Debugger units An interpreter has a numeric id as well as the name of the unit that created it. Switch to an interpreter with the use <id|name> command. The special command help , available in all interpreter contexts, lists all commands made available by the interpreter currently in use. > list 3 interpreters available (0) py: Python Interpreter (built on Jython 2.7) (1) VM: Debugger interpreter for VM (2) Process: Debugger interpreter for Process > use 1 VM> help info : Display basic information about the debuggee libs|modules [name-filter] : Display information about the target modules resume [tid] : Run or resume the target, a thread, or the default thread (tid 0) pause : Pause the target detach : Detach the target (if possible) kill|terminate : Kill the target (unstable) threads : List the process threads thread [tid] : Set or get the default thread step|stepi : Step \"into\" one instruction in the default thread stepo : Step \"over\" one instruction in the default thread stepu : Step \"up\"/\"out\" (run until return) in the default thread b|bp [address] : Set or list breakpoints bc [index] : Clear one or all breakpoints frameSlotIndexMode mode : Set the index type used to retrieve thread frames' variables (AUTO, PAR, VAR) classes : List the classes loaded by the VM signature|sig [OPTION]... cid : Information about a specific class fields [OPTION]... cid : List the fields of a type methods [OPTION]... cid : List the methods of a type call|invoke [OPTION]... cid method : invoke a method. read|get [OPTION]... objectId : Read an object or array. set [OPTION]... objectId new_value : Set a method variable or parameter as a typed-value pull remotePath localPath : adb-pull on steroid VM> Warning Many commands can only run when the target or target thread is suspended or paused. Hint Type help <command> to see specific help for that command. Hint Press Enter on a white-line to repeat the previously executed command. There are three types of commands in the VM interpreter: program commands: info, libs, detach, kill, pull thread commands: thread, threads, pause, resume, step, stepo, stepu, b, bc object-interaction commands: classes, sig, fields, methods, call, get, set","title":"Interpreter Commands"},{"location":"android-debugging.html#program-commands","text":"info will provide information about JDWP. Below, Java 8 and JVM-DI 2. VM> info Debuggee is running on ? VM information: JDWP:\"Java Debug Wire Protocol (Reference Implementation) version 1.8 JVM Debug Interface version 1.2 JVM version 8 (Dalvik, )\" v1.8 (VM:Dalvik v8) VM identifier sizes: f=8,m=8,o=8,rt=8,fr=8 libs will always be empty for a JDWP debugger: libraries are not application to Dalvik bytecode running in a VM. Info A native debugger's libs command does provide information. detach will attempt to detach the target without killing it kill will terminate the target process (and therefore detach from it as well) pull is similar to adb pull ... but will make use of the su binary to elevate privileges when necessary (assuming su be present and found on the target device).","title":"Program commands"},{"location":"android-debugging.html#thread-commands","text":"thread is used to retrieve or set the default thread, i.e. the thread to which most commands will be applied to if no thread id is explicitly provided. threads lists the threads and their states pause suspends the target: all threads will be suspended resume resumes the target: all threads will be resumed. Warning Keep in mind that pausing/resuming actions are stacked. E.g., a a thread X was already suspended, executing pause , then resume , will not resume thread X. step or stepi is used to perform a single-step, and enter methods (Dalvik or Native) if necessary stepo performs a single-step but does not enter methods. stepu will step until the current method returns. b is used to list or add breakpoints, e.g.: VM> b 0 - Lcom/xyz/appcheck/AppCheck;->runTest(Lcom/xyz/appcheck/TestId;)Z+23Ah [enabled: true] 1 - Lcom/xyz/appcheck/AppCheck;->runTest(Lcom/xyz/appcheck/TestId;)Z+246h [enabled: false] 2 - Lcom/xyz/appcheck/AppCheck;->runTest(Lcom/xyz/appcheck/TestId;)Z+240h [enabled: true] VM> b Lcom/xyz/appcheck/AppCheck;->runTest(Lcom/xyz/appcheck/TestId;)Z+218h Lcom/xyz/appcheck/AppCheck;->runTest(Lcom/xyz/appcheck/TestId;)Z+218h (u={Unit:name={Bytecode},type={dex}},a={Lcom/xyz/appcheck/AppCheck;->runTest(Lcom/xyz/appcheck/TestId;)Z+218h}) [enabled=true] bc is used to clear one or all breakpoints.","title":"Thread commands"},{"location":"android-debugging.html#classobject-commands","text":"classes lists all currently loaded classes. Not all classes of an app may be loaded when the command is executed. Info Classes (and generally, types) are referenced by their canonical JVM name or their cid (internal id representing a type during for a given debugging session). A target class can also be inferred from an object reference: this object the object id, prefixed with @ character any object that can be referenced from these ones. sig retrieves information about a particular class fields and methods are used to list the fields of a type, e.g.: VM> methods Ljava/lang/String; sig=Ljava/lang/String;,genSig=Ljava/lang/Object;Ljava/io/Serializable;Ljava/lang/Comparable<Ljava/lang/String;>;Ljava/lang/CharSequence; 98 methods: - id=1876278024,name=<clinit>,sig=()V,genSig=,mod=8h - id=1876278064,name=<init>,sig=()V,genSig=,mod=1h - id=1876278104,name=<init>,sig=(II[C)V,genSig=,mod=0h - id=1876278144,name=<init>,sig=(Ljava/lang/String;)V,genSig=,mod=1h ... VM> methods this.mActionBar sig=Lcom/android/internal/app/WindowDecorActionBar;,genSig= 110 methods: - id=494344081864,name=<clinit>,sig=()V,genSig=,mod=8h - id=494344081904,name=<init>,sig=(Landroid/app/Activity;)V,genSig=,mod=1h - id=494344081944,name=<init>,sig=(Landroid/app/Dialog;)V,genSig=,mod=1h - id=494344081984,name=<init>,sig=(Landroid/view/View;)V,genSig=,mod=1h - id=494344082024,name=access$000,sig=(Lcom/android/internal/app/WindowDecorActionBar;)Z,genSig=,mod=F0001008h - id=494344082064,name=access$100,sig=(Lcom/android/internal/app/WindowDecorActionBar;)Landroid/view/View;,genSig=,mod=F0001008h ... call is used to invoke any method on objects or classes. Arguments must be separated by commas, e.g. VM> call this toString string@9399:\"com.xyz.appcheck.AppCheck@7d6f5da\" Warning Code is executed on the target when using the call command. The target state may be modified. get and set are used to read and write stack-frame local variables (similar to what the Locals view provide), e.g.: VM> set this.vArrayInt [I{1, 2, 3} VM> set this.mystring \"FOOBAR\" VM> get this.mystring string@1234:\"FOOBAR\" Hint The interpreters support auto-completion with the Tab key.","title":"Class/object commands"},{"location":"android-debugging.html#native-debugging","text":"Note This section assumes that the app has bytecode and native libraries stored in the standard APK's lib/ folder. To debug native code only (Android or not), you will need to start gdbserver on the target manually, and connect remotely ( Debugger, Attach, Remote tab). Native debugging of Android apps is done remotely over the gdb protocol and the lldb extensions. JEB implements a gdb/lddb client and connects to the on-device gdb-server/lldb-server. By default, lldb-server is the preferred debugger server dropped on the target. Warning When attaching to the target app, remember to tick \"Allow Children Debuggers\". Needless to say, it is worth getting familiar with x86 and arm assembly (preferably their 64-bit variants, for which getting acquainted with their 32-bit parent if necessary).","title":"Native debugging"},{"location":"android-debugging.html#active-debugger_1","text":"Focus a fragment related to native debugging to ensure debugging commands are issued to the native debugger. If the Terminal is opened, the prompt will change to Process to reflect the change as well: interpreter commands will be issued to the gdbserver. Issue an info command, you should see basic target information, e.g.: Process> info Debuggee is running on ARM64 (LITTLE_ENDIAN) Target process id: 19218 Target is being debugged by lldb-server A breakpoint was hit in a SO file, and all native threads are paused","title":"Active Debugger"},{"location":"android-debugging.html#native-threads-vs-vm-threads","text":"Warning Always remember that the Dalvik VM runs within the Native process, and that VM threads are backed by Native threads. That includes the JDWP server thread as well! If you pause Native threads, the VM threads will freeze as well, despite what the Dalvik debugger fragments may indicate. This \"nested debuggers\" situation, if not managed properly, can lead to strange situations, and in fine, the JDWP debugger may lose control of the target. Rules of thumb: when debugging native code, do not attempt to interact with the JDWP debugger make sure the Native process is not paused when issuing JDWP commands, e.g., unless necessary/wanted, you should disable Native breakpoints that may be hit and interrupt a VM debugging session abruptly","title":"Native threads vs VM threads"},{"location":"android-debugging.html#java-to-native-code-transitions","text":"Dalvik code can call into Native code by invoking methods with that have the Java modifier (attribute) native . Set a breakpoint on the dispatch instruction, not on the Java native method itself. When the breakpoint is hit, issue a Step Into command to auto-switch to Native code debugging Be patient, native code analysis is taking place as you're switching code The native breakpoint was automatically created and will be automatically released upon returning to Dalvik Resume native debugging to go back to Dalvik; the code will auto-break on return from invoke-xxx Example: Source: Java code: package com.xyz.appcheck ; class AppCheck { static { System . loadLibrary ( \"somelib\" ); } ... String foo () { ... return getPlatform (); } public native String getPlatform (); } ... C code: jstring Java_com_xyz_appcheck_AppCheck_getPlatform ( JNIEnv * env , jobject thiz ) { ... } Transition in JEB: How was Java's com.xyz.appcheck.AppCheck.getPlatform linked to C's Java_com_xyz_appcheck_AppCheck_getPlatform ? The process of binding Java methods to native methods (in the case above, binding was done automatically), as well as input and output object conversions and the library code to manipulate them while executing native code, is defined in the Java Native Interfaces specifications.","title":"Java to Native code transitions"},{"location":"android-debugging.html#jni-basics","text":"Method linking and dispatching is an important aspect of JNI, which reverse-engineers should understand in order to work around difficult cases, including Java methods statically linked.","title":"JNI basics"},{"location":"android-debugging.html#dynamic-linking","text":"When a native Java method is executed, the VM will look for a native method having: the following name: Short_Form= \"Java_\" + mangled_classname + \"_\" + mangled_methodname or, if the method is overloaded, the following name: Long_Form = Short_Form + \"__\" + mangled_argsigs The mangling scheme is the following: . => _ / => _ _ => _1 ; => _2 [ => _3 \\uXXXX => _0xxxx (unicode char.) Types names for mangled_argsigs are using the canonical JVM convention: boolean => Z byte => B char => C short => S int => I long => J float => F double => D classname => La/b/c/SomeClass; Details For additional details, refer to this part of the official specifications. Examples for auto-binding: void f(int x) in class com.xyz.A => short form: Java_com_xyz_A_f => long form: Java_com_xyz_A_f__I void g(long array[], String s) in class com.\\x4f60\\x597d => short form: Java_com__04f60_0597d_g => long form: Java_com__04f60_0597d_g___3JLjava_lang_String_2","title":"Dynamic linking"},{"location":"android-debugging.html#static-linking","text":"Native libraries can use the JNI function RegisterNatives to manually bind native methods to Java counterparts, while not adhering to the JNI naming convention used for dynamic linking. RegisterNatives can be called anywhere. Example In the snippet, a Java method a.b.c.Foo.methodX()V is bound to a static, non-exported native method routineX . jint JNI_OnLoad ( JavaVM * vm , void * reserved ) { JNIEnv * env = NULL ; if ( vm -> GetEnv ( & env , JNI_VERSION_1_4 ) != JNI_OK ) { return - 1 ; } if ( registerNatives ( env ) != JNI_TRUE ) { return - 1 ; } return JNI_VERSION_1_4 ; } int registerNatives ( JNIEnv * env ) { if ( ! registerNativeMethods ( env , classPathName , methods , sizeof ( methods ) / sizeof ( methods [ 0 ]))) { return JNI_FALSE ; } return JNI_TRUE ; } int registerNativeMethods ( JNIEnv * env , const char * className , JNINativeMethod * gMethods , int numMethods ) { jclass clazz = env -> FindClass ( className ); if ( clazz == NULL ) { return JNI_FALSE ; } if ( env -> RegisterNatives ( clazz , gMethods , numMethods ) < 0 ) { return JNI_FALSE ; } return JNI_TRUE ; } static const char * classPathName = \"a/b/c/Foo\" ; static JNINativeMethod methods [] = { { \"methodX\" , \"()V\" , ( void * ) routineX }, }; // bound to Java method: a.b.c.Foo.methodX()V static jint JNICALL routineX ( JNIEnv * env , jobject thiz , jint a , jint b , jint c ) { //... }","title":"Static linking"},{"location":"android-debugging.html#additional-views","text":"On top of the usual debugger fragment that were described in the Dalvik debugger section (threads, breakpoints, locals), native debuggers provide additional fragments.","title":"Additional views"},{"location":"android-debugging.html#memory-code","text":"The memory fragment displays the data and instructions located at any address within the target process. It is helpful in many situations, such as: - simple memory exploration and scanning - snooping around Dalvik VM internal structures, and modifying them - single-stepping over code outside the analyzed .so files contained in the app's lib/ folder A situation where the third scenario arises is when entering library code located somewhere in the process memory, outside a pre-analyzed so file. The execution will seem to have stalled in the main view (fixed blue line). Switch to the Memory Code fragment to see what is being executed.","title":"Memory code"},{"location":"android-debugging.html#stack","text":"The stack view is similar to the memory fragment: it represents words of memory located at around the standard stack pointer on the target architecture (esp, rsp, r13, x31, etc.).","title":"Stack"},{"location":"android-debugging.html#additional-interpreter-commands","text":"...","title":"Additional interpreter commands"},{"location":"android-debugging.html#settings","text":"The Android debuggers offer options to control low-level debugger parameters, such as ports and timeouts. Filter on dbug_apk and dbug_elf in the Engines options: The full documentation of each option can be found on this page .","title":"Settings"},{"location":"android-debugging.html#api-scripts-plugins","text":"Debugger modules in implement the set of interfaces contained in the com.pnfsoftware.jeb.core.units.code.debug package. The principal interface in this package is IDebuggerUnit . Plugins, scripts, or third-party clients wishing to automate the usage of debuggers can use these well-defined interfaces. The official UI client uses this public API as well. Anything that the UI client does can be done and/or automated by third-party code. Example Check out our blog post on Android crypto primitives hooking to see how the API can be used to retrieve pre-encryption or post-decryption data on the fly.","title":"API, Scripts, Plugins"},{"location":"android-debugging.html#further-reading","text":"A note on debugging caveats with recent Android versions (p, Q): Debugging Android apps on Android Pie and above API/Scripting: Crypto Monitoring with the Android Debuggers API Use-case, obfuscation: Defeating AppSolid Android application protector Use-case, dynamic dex: Debugging Dynamically Loaded DEX Bytecode Files JNI debugging helper: Dynamic JNI Detection Plugin Reference: List to all blog articles on debugging","title":"Further Reading"},{"location":"android.html","text":"Previous material We recommend the reader to be familiar with the platform-agnostic sections Actions , Views , and Decompiling before proceeding with Android-specific contents. JEB is a well-known industry tool used to reverse-engineer and audit Android applications. You will be able to: Analyze APK files and their contents, including DEX files, Certificates, Resources, Assets, Native Library code, etc. Examine encoded resource files and manifests, including resources with obfuscated names and locations. Examine app certificates (legacy, v2, and v3) Decompile DEX bytecode, with full-support for multi-DEX reconstruction. Analyze native library code: more on the Native code analysis section Debug Android applications (Dalvik and Native - x86, arm, mips - code) and transition seamlessly from Dalvik to Native, and vice-versa. Write your own extensions using the API (client scripts in Python, back-end plugins in Java). Plugins # The plugins used to analyze Android apps consist of: The APK plugin is responsible for processing APK files. Encoded resources (arsc) are decoded by this plugin. Other jobs, such as analyzing dex files, analyzing certificates, processing asset files, analyzing binary files, etc. are delegated to appropriate plugins. The DEX plugins: DEX analyzer (DEX parsing and merging, Dalvik disassembling, etc.), DEX decompiler, DEX debuggers. Native code analyzers: disassemblers, decompilers, etc. A handful of other plugins, such as Certificate parsers, XML/HTML/JSON/etc. parsers. This section mostly focuses on the APK plugin and the DEX analyzer. Other plugins are documented in separate sections of this manual. Technical Blogs # Our blog is filled with technical posts that will help you make the most of JEB. It is the ideal companion to this manual. Link: All PNF Software blog posts tagged Android. API Levels # API levels are regularly mentioned throughout this document. Here is a list of \"recent\" Android versions, their corresponding API levels, as well as notable changes regarding security. Codename Version API level Date New security features R ( DP3 ) 11 30 2020 Privacy updates, APK Signature Scheme v4 Q 10 29 2019 Permissions for privacy, BiometricPrompt Pie 9 28 2018 ART: Vdex with Cdex, AS-FBE, biometric API, lockdown mode, APK Signature Scheme v3 Oreo 8, 8.1 26, 27 2017 ART: OAT with Vdex (oat w/o dex, separate vdex with dex'es), Google Play Protect Nougat 7, 7.1 24, 25 2016 APK Signature Scheme v2, File Based Encryption (FBE - and consequently, DirectBoot), AS-FDE, Android Things Marshmallow 6 23 2015 Adoptable Storage (AS), granular permissions and permission levels (NORMAL, DANGEROUS), Doze & App Standby, Android Wear Lollipop 5, 5.1 21, 22 2014 ART: OAT with dex'es in .rodata, 64-bit support (x86_64, arm64-v8a), Android Auto KitKat 4.4, 4.4W 19, 20 2013 ART (optional), VerifiedBoot, Full Disk Encryption (FDE) Jelly Bean 4.1, 4.2, 4.3 4.4, 4.4W 2012 SELinux introduction, multi-users Android Versions Reference APK Structure # This section is a short primer on the Android Package file (APK). It is assumed that the reader is already familiar with the structure of an APK. Good introduction material can be found on the official Android developer portal . An Android app is a zip file containing application code, data, and metadata. Code: Dalvik (bytecode), Native (*.so libs) Data: resources (structured), assets (unstructured) Metadata= manifest (what), certificates (who) When JEB processes an APK, the resulting structure in the Project tree will differ from a raw ZIP tree view. The range of differences goes from slightly for regular apps, to significantly for obfuscated or complex apps. The picture below shows a side-by-side comparison of processing an app as a ZIP file vs processing it as an APK: Manifest: encoded VS decoded Certificates: v1 (visible, in file MANIFEST.MF), v2/v3 (in ZIP) VS parsed certificates Bytecode: spread over classes.dex, classes1.dex, ..., classesN.dex VS virtual merged DEX unit Resources: encoded and scattered in resources.arsc, res/, elsewhere (anywhere) VS decoded and reorganized resources Native libs: 1-to-1 Assets: 1-to-1 Certificates # As of Android 11, four types of signatures are in place to sign APKs, versions 1 through 4. Version 1 # Version 1 is the legacy scheme supported by all versions of Android: standard Jar signing (Oracle) signing data goes in META-INF/ each individual file in the archive is signed MANIFEST.MF: list of hashes of all files xxx.SF: hash of hash entries in MANIFEST.MF xxx.{RSA,DSA,...}: signature of xxx.SF + signer certificate (= what JEB displays) note that xxx='CERT', usually The apk/zip itself is not signed: this scheme is both inefficient and incomplete when the goal is to verify the APK as a whole Versions 2/3 # Versions 2 and 3 are specific to Android: What is signed is the APK as a whole Uses a twist in zip format specifications The global signing block is inserted just before the zip Central Directory (and can be located by looking for a magic number) V3 = V2 + support for key rotation What is displayed in the Certificate fragment is the signer's certificate, just like V1's review the reference documentation for additional details Version 4 # The APK signature scheme version 4 scheme is being introduced with Android 11 (R) to ease development of larger applications. The signature of the APK is done incrementally via a Merkle tree. The signing data is stored separately in an <APKNAME>.idsig file. Note Version 4 signatures do not seem to be designed for release purposes. At the moment, JEB does not parse idsig files. JEB parses v1/v2/v3 signing data. The certificate is displayed as a tree in the UI client: API To retrieve this data programmatically: refer to IApkUnit , methods getSignatureSchemeVersionFlags and getSignatureSchemeV{2,3}Block Manifest # AndroidManifest.xml defines the Android application to whoever interacts with it, from building, to deployment, to execution. Important parts of the Manifest: Package name (fully qualified Java name) Requirements to run the app (API level, hardware configs) Permissions required by the app (not all may be granted by the system at t0) Components must be declared in apps - except for Broadcast receivers, which can be registered dynamically Activities (UI elements) Services (background execution) Broadcast Receivers (receive and process events from apps/system) Content Providers (offer data to other apps/system) Declares whether the app is debuggable on a production device <application android:debuggable=\"false|true\" ... For example, the simple manifest below... declares a app named (internal package name) com.xyz.appcheck requiring at least and ideally API 26 (Android P) wants read+write access to storage the App is debuggable it declares one main activity (visible on launcher) as well as one implicit broadcast receiver Note Manifests can be very complex and lengthy. For example, the primary Facebook app ( com.facebook.katana ) manifest is well over 2000 lines, mostly Activity descriptions. About Permissions # Permissions provide an indirect insight into what \"functions\" the app needs to perform. They are granted by the user at install and/or runtime: Before API 23, permissions were all granted at install time. A pop-up would display which dangerous permission groups are being requested. With API levels 23+, permissions are granular, and dangerous permissions are granted at run-time unless the Manifest declares targetSdk<23 ! the user will be shown a system pop-up permissions can also be revoked in settings Permissions - whether related code requiring them is used, whether they are granted explicitly or implicitly -, MUST all be declared in the Manifest , i.e. an app cannot programmatically request a permission that was not declared in the Manifest in the first place. Structured Resources # Structured resources of an app consist of XML files (e.g., app layouts, strings, etc.), image files, icons, etc. XML resources are encoded using a binary format called arsc . The manifest, an XML resource, is encoded as well. Common resources\u2019 information goes into the app resources.arsc file Resources references resources.arsc items by id They can also reference Android Framework and other vendor-installed framework resources by id (refer to the section 'Third-party Frameworks') JEB always ships with the latest official Android Framework Note For additional information on Resources: high-level information can be found in the official doc lower-level details of the arsc format can be found by going through the main implementation of the encoder and decoder, on the AOSP's platform/frameworks/base repository. The newest ResourceTypes.h is located here . Oddities and Obfuscation # Resources on Android can be mangled in several ways. JEB unmangles them to the best of its ability. Below, we briefly describe two commonly found obfuscation techniques. Name removal # Resource items are normally identified by a name as well as an id. Several application protectors remove resource names from the compiled resources.arsc file when they reference well-known framework resources. E.g., the manifest below had resource names removed. Note that most XML attribute names are missing. <?xml version=\"1.0\" encoding=\"utf-8\"?> <manifest xmlns:android= \"http://schemas.android.com/apk/res/android\" := \"1.1\" android:versionCode= \"2\" platformBuildVersionName= \"6.0-5078647\" platformBuildVersionCode= \"23\" package= \"com.virginoff.player\" > <uses-sdk := \"7\" := \"23\" /> <uses-permission := \"android.permission.ACCESS_NETWORK_STATE\" /> <uses-permission := \"android.permission.SEND_SMS\" /> <uses-permission := \"android.permission.INTERNET\" /> <uses-permission := \"android.permission.WRITE_EXTERNAL_STORAGE\" /> <uses-permission := \"android.permission.WAKE_LOCK\" /> <application := \"@style/Theme.NoTitleBar.Fullscreen\" := \"Anal Sex Video\" := \"@drawable/ic_launcher\" := \".Application\" := \"false\" > <activity := \".activity.WrapperActivity\" := \"true\" > <intent-filter> <action android:name= \"android.intent.action.MAIN\" /> <category android:name= \"android.intent.category.LAUNCHER\" /> </intent-filter> </activity> <activity := \"o.\u03df\" := \"0\" := \"a0\" /> <activity := \"o.\u022d\" := \"0\" := \"a0\" /> <service := \"o.\u0182\" /> </application> </manifest> Dump the manifest using aapt to see the actual ids: $ aapt dump xmltree 1 .apk AndroidManifest.xml N: android = http://schemas.android.com/apk/res/android E: manifest ( line = 0 ) A: : ( 0x0101021c )= \"1.1\" ( Raw: \"1.1\" ) A: android:versionCode ( 0x0101021b )=( type 0x10 ) 0x2 A: platformBuildVersionName = \"6.0-5078647\" ( Raw: \"6.0-5078647\" ) A: platformBuildVersionCode =( type 0x10 ) 0x17 A: package = \"com.virginoff.player\" ( Raw: \"com.virginoff.player\" ) E: uses-sdk ( line = 0 ) A: : ( 0x0101020c )=( type 0x10 ) 0x7 A: : ( 0x01010270 )=( type 0x10 ) 0x17 E: uses-permission ( line = 0 ) A: : ( 0x01010003 )= \"android.permission.ACCESS_NETWORK_STATE\" ( Raw: \"android.permission.ACCESS_NETWORK_STATE\" ) ... Above, we can see that the uses-permission tag, for example, specifies the use of an attribute whose id is 0x01010003. Attributes of an Android Manifest are well-known resources and stored as such in the Android framework. You can use aapt on the Android framework file to see them: $ aapt dump --values resources ~/.jeb-android-frameworks/1.apk Package Groups (1) Package Group 0 id=0x01 packageCount=1 name=android Package 0 id=0x01 name=android type 0 configCount=1 entryCount=1543 spec resource 0x01010000 android:attr/theme: flags=0x40000000 spec resource 0x01010001 android:attr/label: flags=0x40000000 spec resource 0x01010002 android:attr/icon: flags=0x40000000 ---> spec resource 0x01010003 android:attr/name: flags=0x40000000 spec resource 0x01010004 android:attr/manageSpaceActivity: flags=0x40000000 spec resource 0x01010005 android:attr/allowClearUserData: flags=0x40000000 ... So, that tag could be restored to: <uses-permission name= \"android.permission.ACCESS_NETWORK_STATE\" /> Note The Android framework contains all base system resources for a given version of Android - it is located in the /system/framework/framework-res.apk (resources only) on a device, or the platforms/<APILEVEL>/android.jar in the Android SDK. JEB also drops the latest stable framework to your HOME folder's jeb-android-frameworks/1.apk The above process is automated by JEB to restore XML files to a human-readable states. Flattened hierarchy # Although most structured resources (with the notable exception of the Manifest) are typically stored hierarchically under the res folder, they do not have to be. Some application protectors take advantage of this fact to flatten the resources tree, and for example, store them in the APK's root folder. E.g., in the file below (a protected online banking app), most resource files were renamed to mangled names and stored alongside the Manifest; the res/ folder is present and contains only a handful of resources. JEB restores both the hierarchy and names of those resource files. Decoding problems # Other oddities exist, they can be found in apps stretching the limits of the arsc format specifications to their boundaries. They can be used, voluntarily or not, to thwart and crash various open-source tools. We won't detail them here, but you can find additional information here and there on our blog as well as the Apktool's GitHub issue tracker , a prime source to find weird parsing cases. As an example, here is aapt2 (version around spring 2019) failing on a version of the Facebook app: $ aapt2 dump Facebook_v153.0.0.54.88.apk error: trying to add resource 'com.facebook.katana:id/(name removed)' with ID 0x7f090001 but resource already has ID 0x7f090000. Assets # Assets are unstructured resources. They can be of any type and stored anywhere in the APK archive. However, the assets/ directory is standard, and used by the Android AssetManager object. Assets stored in the Resources folder res/raw are stored as-is (in particular, XML files are not encoded), and yet, are accessible in code by id, using the R class, just like any other standard resource. The asset file below, edd.bin , is holding encrypted data Native Code # Android applications often contain native code, compiled as ELF library .so files. They can be located anywhere in the app. SO files can be loaded from bytecode via System.loadLibrary(simpleName) and System.load(path) . A common location for SO files is the app's lib/ folder. Libraries stored in this folder and adhering to the JNI naming convention allow the Android system to unpack appropriate SO to the device folder /data/data/<app>/lib , and make it easier for high-level code to load them, i.e. there is no need to implement the logic of figuring out which underlying platform the device is running on. Location: [APK]/lib/<abi>/lib<name>.so Example: high-level request System.loadLibrary(\"native-lib\") on an aarch64 device => lib/arm64-v8a/libnative-lib.so on a Pixel phone with an Arm64 CPU Info For more information on native code analysis, debugging and decompilation, refer to the manual pages relative to native code . Bytecode # Refer to the DEX sub-section below . Dex Bytecode # Dex (or DEX , throughout this section), short for Dalvik Executable , is an object container for Dalvik code. It is Android's equivalent of ELF, PE, COFF, etc. containers for native code. The primary dex file of an app is named classes.dex , located in the app's root folder. This file is present in the vast majority of apps, although it is optional: apps can be purely native. DEX splitting # Additional DEX files may be present: classes2.dex , classes3.dex , etc. The reason behind code splitting is a Dalvik VM legacy limitation called the \"64K reference limit\": many items present in a DEX file are referenced by an id stored on a 16-bit integer, e.g. it is the case for methods and fields references. To overcome the limitation, compilers such as d8 (or its predecessor dx ) split the code over additional DEX files classesN.dex , where N>=2. Additional references are created to reference definitions located in other DEX files. JEB merges all classesN.dex in a single, virtual DEX unit. Note that in practice, such DEX units could not be converted back to a single DEX file. Also keep in mind that apps may artificially split their code over multiple DEX files; the 64Krefs limit is not a hard requirement. This app was split over 7 dex files: Warning On pre-API 21 (Android 5) systems, it is the responsibility of the app to load additional files - i.e., the DEX splitting mechanism is not something baked into the Dalvik VM itself. Apps can extend the support class MultiDexApplication to avoid implementing their own DEX loader, as the vast majority of the apps do. However, keep in mind that this is in no way mandatory. Malware files or protected files can implement multi-dex loading facility however they see fit. On API 21 and above, with the advent of the new Android ART runtime, files names classesN.dex are scanned and pre-compiled along with classes.dex . However, this mechanism does not preclude apps to use additional DEX loading facility as well. DEX execution # There are two general types of dex files: regular dex files contain generic code, use standard Dalvik instructions, meant to run on all Android devices odex files, on the other hand - a generic term for \"optimized DEX\" - contain device specific instructions. Optimized dex (odex) # The DEX file(s) located in your app is not the code executed on device - except when debugging. DEX code is executed by a runtime: The legacy runtime (pre-API 21 Lollipop) uses a JIT (just-in-time) compiler and generate odex files on first run. The current runtime is named ART (short for Android Runtime ) and makes use of AOT (ahead-of-time) compilation of Dalvik to native (x86 or ARM) at install time Note The format of optimized DEX files has evolved over time (\"dey\" magic, OAT files with DEX or DEX-like entries, VDEX and CDEX, etc.). The process of reconstructing a DEX from an optimized-DEX is systematic and implemented in several tools, such as baksmali deodex or vdexExtractor . Refer to additional references, such as Lief's notes on OAT and ART , for more information on odex. Link: List of odex instructions . DEX format # This section quickly summarizes important facts about the DEX format. Refer to the official specifications for additional details: DEX format Bytecode format List of instructions . Structure of a DEX file The format can be linearly represented as: In Header: DEX magic, DEX version: dex\\n0NN\\0 where NN= 35: up to Android 7- 37: Android 7, invoke-virtual and invoke-super accept interface methods ids (support for Java 8's default methods) 38: Android 8, added invoke-polymorphic , invoke-custom , call sites and method handles entries ( details ) 39: Android 9, added const-method-handle , const-method-type ( details ) Tables are ordered alphabetically and do not allow duplicates Note that the map section was purely redundant until DEX 38 and the introduction of method handles and call sites. The three links above cannot be overlooked: any Android reverser should strive for Dex and Dalvik proficiency. That being said, below is a list of lesser-known or overlooked details about about Dalvik: Strings are encoded using a variant of CESU-8 called MUTF-8 (modified UTF-8) 1- 2- 3-byte encoding (whereas UTF-8 allows up to 4-byte) Surrogates: 2x3-byte for chars \\u010000 to \\u10FFFF (whereas canonical representations of UTF-8 does not use surrogates; UTF-16 does) \\u0000 is encoded as \\x00\\x00 (whereas UTF-8 uses \\x00) Special byte \\x00 indicates string end (there is no EOS concept with UTF-X) Some 32-bit integers are encoded using the variable encoding scheme LEB128 and its variants Types use Strings: type definition= index into string pool Prototypes use Strings and Types Shorty definition= index into string pool Full prototype definition = list of indices into type pool The Dalvik bytecode is stored in Code items Call Sites and Method Handles were introduced in DEX 38 The DEX header remained unchanged and does not directly reference those pools; instead, they are referenced in the Map area (which largely remained unused until those items were introduced) Learn more about DEX 38 on our blog Dalvik # Dalvik is the name of the low-level bytecode stored in DEX files. Dalvik bytecode is interpreted by a Virtual Machine (DVM). Generation: Source language: smali (low-level), Java (high-level), Kotlin (very high-level) Java -> javac -> classfiles (Java bytecode) -> dx/d8 -> classes.dex (Dalvik bc) Characteristics: Register-based machine: 65,536 32-bit registers, numbered v0 to v65535 65,535 64-bit registers, \"emulated\" by using consecutive 32-bit registers [v0,v1], [v1,v2], ..., [vN,vN+1] No \"special\" register is accessible: no flag register, no PC register, no current-frame register, etc. Fixed frames (stack is N/A, no stack pointer), size declared in Code items Pointer= object reference ~= fits on a single register (32-bit) Regular instructions range from 2 to 10 bytes (=1 to 5 words) Instruction opcode encoded on a single byte; the second byte of the first word is generally used to encode register indices nop (1w), const-wide v1, 0x1122334455667788L (5w) The generally accepted convention is to represent Dalvik disassembly in smali or a variant of smali. By default, JEB uses a variant of Smali, slightly less verbose (more readable and better suited to be displayed and manipulated in an interactive fragment). Method bodies live in isolation, the concept of \"jump far\" (unstructured dispatch) is irrelevant. Dispatching execution to other methods is done via invoke-xxx instructions only Jumps are always relative to the current PC Retrieving the returned value of a function is done via a move-result-xxx instruction, located right after the invoke-xxx instruction Arithmetic instructions have no side-effects / there is no flag register Data in bytecode is legal: Immediates: Some instructions store literals inline (i.e., within the instruction code), e.g. const-xxx N-way branching instruction: switch-xxx : the jump table is stored within the bytecode Small array initialization: fill-array-data-payload : array data is stored within the bytecode Calling convention # The DVM runs managed code and uses a no-side effect, no cleaning calling convention : every function gets a clean register slate upon execution; the parameters are stored at the bottom of the declared frame. Registers are 32-bit wide and noted vX , 0-indexed. The alternate notation pX is used to address registers used to store input method parameters: its indexing start from frame_size - input_slot_counts . Example 1: Method: void foo(int a, char b, bool c, Object d) The CodeItem declares a frame of size 5 v0 v1 <- parameter 0: p0 (a) v2 <- parameter 1: p1 (b) v3 <- parameter 2: p2 (c) v4 <- parameter 3: p3 (d) ------- end of method frame v5 v6 ... v65535 Example 2: Method: void bar(double a, long b, float c) The CodeItem declares a frame of size 8 v0 v1 v2 v3 <- parameter 0: p0 (a) v4 <- parameter 1: p1 (b, lower part) v5 <- parameter 1: p2 (b, higher part) v6 <- parameter 2: p3 (c, lower part) v7 <- parameter 2: p4 (c, higher part) ------- end of method frame v8 v9 ... v65535 The default settings instruct JEB to use the pX notation when rendering parameter registers: It can be disabled (DEX plugin option, also controlled in the UI by right-clicking, Rendering Properties , untick 'Use p for parameters') Smali and variants # The JEB notation is made possible because of the interactivity layer (as opposed to deadcode listing). Two notable differences: For readability, the names are simple names, no longer fully-qualified Invoke opcodes place the arguments after the method: invoke-xxx callsite, args instead of invoke-xxx {args}, fully_qualified_callsite Below, the default assembly code representation used by JEB (smali variant): Official smali code can be generated (it is useful if code needs to be exported, and later on compiled using smali.jar): Application components # The application and its main components (activities, broadcast receivers, services, content providers) must be declared in the Manifest, even if they are not meant to be exported (i.e., the external attribute is set to false). Warning There is one exception: broadcast receivers can be registered dynamically, via one of the Context.registerReceiver() methods. The name attribute of a component is the name of the corresponding class that will be instantiated and whose methods are to be called back by the Android system (for exported components). Example: the Manifest below declares an Activity class com.xyz.appcheck.AppCheck , among other components. Entry points # The exported components of an APK can be equated to the entry-points of the application. Therefore, unlike types of executable programs, an Android application can have multiple entry-points. The true entry-point of a non-native application is the application's static initializer ( Application.<clinit> ). If the application being analyzed declares its own Application class in the manifest (instead of reusing android.app.Application), then that class's static initializer, if any, should be looked at first, followed by the constructors. Similarly, the static initializers and constructors of activities, receivers, services and providers are also entry-points. Finally, all API-defined callback methods of those five components can be called back by the system. Typically, the main activity's onCreate() method is the practical entry-point to an application, akin to a regular program's main() routine. Note JEB's disassembly view recaps the most important features of the APK at the top of the code listing. The important components, in particular any custom Application object, will be mentioned there: Activities # Activities are activated by Intent . Exported activities (by default, any unfiltered activity is exported) are first-class entry-points. The following methods should be carefully examined: constructor (although the object state is uncertain) well-known callbacks, e.g. attachBaseContext (used to set up a delegate Activity), onCreate , onResume , etc. Pseudo activities # Be mindful of activity aliases. They are not true components, however, they can and will override their target component's characteristics, such as intent filters. Services # Services are activated by Intent . Services are started by Activity code or Receiver code (after receiving a particular event). Most won't be easily started by the user, except for a few of them, such as Input services. Therefore, they should not be considered first-class entry-points from the point of view of code analysis. Broadcast Receivers # Broadcast receivers are activated by Intent . The intent handler for ACTION_BOOT_COMPLETED is a common entry-point, commonly used by malicious code as a way to automatically start after the phone has booted up. Many more exist though (e.g., battery plugged, message received, phone lifted, etc.) Caveats: API 21+ (Lollipop) - need a wake lock API 26+ (Oreo) - need a JobIntentService Content Providers # Content providers are activated by ContentResolver . Intents # Intents are the primary method for inter-process and inter-app communication. Other IPC means exist, e.g. sockets, files, etc. Intents are used to activate components, e.g. start an activity. Reference Dalvik and Disassembly # Plugins generate IUnit objects. Units can generate documents abiding to a standard interface, making them easy to render by clients implementing the JEB API. The primary document generated by an IDexUnit is a text document representing the disassembly of the input DEX files - or merged DEX files. Auto dex merging # Merging is done automatically, regardless of index limitations in place that may have required dex-splitting in the first place. In rare cases, you may want to disable merging. Upon loading an APK, several APK plugin options will be presented to you. Untick Merge multi-dex to disable auto-merging: DEX parsing options # DEX plugin options are accessible in the Engines options UI panel. Filter on \"dex.\" to list them. The user will also be presented a Processing Properties dialog box when opening a new file, giving the user a chance to adjust the default options stored in your jeb-engines.cfg files. Addressing # All addresses to types, methods and fields uses the canonical JVM notation, e.g.: type Blah in package com.abc: Lcom/abc/Blah; method foo(int):void in the type com.abc.Blah: Lcom/abc/Blah;->foo(I)V field name:String in the type com.abc.Blah: Lcom/abc/Blah;->name:Ljava/lang/String JEB extends the method notation to reference code locations via a suffix +OFFSET . Reference the instruction at offset 0x20 in the internal method foo(): Lcom/abc/Blah;->foo(I)V+20h Types Naming Conventions # Historically, addressing in Java can be quite confusing. There exists three types of notations: The JVM notation (canonical representation) is the one used by DEX's TypeDescriptors , e.g. Ljava/lang/Object; . JEB's DEX plugins use and provide JVM canonical names. Two JLS notations : binary form, uses dots to separate package names, e.g.: java.lang.Object internal binary (or just, 'internal') uses slashes, e.g.: java/lang/Object The java.lang.Class API uses inconsistent representations, mostly the binary form. Android plugins use the JVM notation internally and externally (public API). Example: to reference a method void foo(String) in package a.b.c , its JVM address should be provided: La/b/c;->foo(Ljava/lang/String;)V . API methods using DEX addresses expect canonical addresses. The graphical client is less strict: although it expects canonical addresses by default as well, fall-back mechanisms are implemented to determine which address the user may have intended to use, and attempt to see if it's a match. See our Reference Document. Disassembly # The default output uses modified smali (as explained in the previous section). TODO This section is a work-in-progress. Renaming and Refactoring # The DEX plugin provides smart renaming capabilities: renaming of items is done consistently throughout the code base. Most internal items can be renamed (internal items are those defined in the DEX, as opposed to external items, simply referenced in the DEX, but whose definition is located elsewhere). What can be renamed: class names (as well as interfaces and enums defined in the DEX) method names field names labels (addresses) package names variables (in decompiled units) In the UI client, Renaming can be done via the Action menu. Renaming Methods # Proper refactoring is especially important when renaming non-static methods (virtual methods, interface methods) which may be part of a hierarchy of other methods, overridden parents or overriding children. Example: renaming B:a() should also rename A.a() and C.a() A.a():Object | B.a():String | C.a():String Renaming must also take into account indirect references to methods, something common when invoking virtual methods located in other classes, but which can be used to obfuscate a program further. A.a() | B.a() - within B: invoke-virtual A.a() -> actually refers to B.a() Things can get relatively complicated when hierarchies involve multiple inheritance through one or more interfaces. Renaming Fields # To some degree, the same applies to fields. Unlike methods, fields cannot be overridden; they are always accessed in a direct way, i.e. resolution is entirely determined at compile-time. However, field masking adds complications. A.i:int public | B.i:int public - this field masks A.i Shall a rename action of A.i also rename B.i? Conversely, shall renaming B.i also rename A.i? Theoretically, no. Those two fields are not related. However, at the moment, the DEX plugin renames both fields to maintain some degree of visual consistency with the original binary, regardless of whether field masking was done voluntarily or not, with obfuscating intent or not. This is likely to change with the addition of an option to let users decide how they want to perform renaming. Reorganizing code # Packages can also be renamed. Users can also create additional packages and move packages and classes to other packages. This feature can come in handy when dealing with obfuscated code for which entire type hierarchies were flattened out into a handful (sometimes single) set of packages. Most obfuscators, including the ubiquitous Proguard and its now equivalent r8, can do that. If you want to explore refactoring further, in particular hierarchy reconstruction, have a look at our sample script DexCluster.py . Auto-rename # Auto-renaming is an optional standard Action also implemented by the DEX plugin. As its name implies, it can perform automatic blanket renaming of all items of a unit. In the case of DEX units, they include types, methods, fields, etc. The action is semi-customizable by each plugin, as can be seen in the API . In the case of the DEX plugin, three policies are implemented. Each policy defines a set of legal characters for items. The loosest policy permits all characters in the printable ascii range (something already relatively strict considering the actual legal character ranges for Java identifiers); the strictest considers all current names (except those that were already defined) invalid, and therefore, will rename everything. The obfuscation applied below is using right-to-left unicode characters to complicate rendering: After auto-renaming (standard policy): Cross-references in Dalvik # Refer to the generic xrefs section of the manual. TODO The documentation of DEX specificities regarding xrefs are a WIP. Decompilation to Java # Note Make sure to read the generic Decompilation section of the manual. Decompiling classes # By default, the Decompile action in the UI menu triggers the decompilation of an entire class and its constituents (fields, methods, member classes, etc.). Fresh decompilation: With the current options set up in your Engines context: Use Action, Decompile or press the Tab key . With custom options: use Action, Decompile with Options or press the CMD1+Tab . Re-decompile (e.g., after changing options) Execute a \"Decompile with Options\" action as described above. The current decompilation of the class, if it existed, will be discarded, and a new decompilation will take place. Generic decryption and deobfuscation # The decompiler attempts to automatically performs data decryption and code unreflection. This process is done automatically by several method optimizers managed by the decompiler, with the help of code emulation in a built-in sandbox. Sample malware code decompilation: light-blue methods have been unreflected; Purple strings are the result of generic decryptions While the emulator and sandbox are currently not available in the API, a few key parameters of the emulator can be customized via the coreplugins/dexdec-emu.cfg file. Copy the file dexdec-emu.cfg.TEMPLATE to dexdec-emu.cfg Edit dexdec-emu.cfg The changes will take effect at the next decompilation Currently, the configuration file allows users to specify: maximum emulation times emulation policy for external methods (by groups, restricted lists, whitelists, and blacklists - e.g., a user can forbid the emulation of any time/date-related method) Note As of April 2020, data decryption combined with unreflection yields very effective results against most classes of Dalvik obfuscators. You will find examples of this on our blog . Known support # As of April 2020 , the following well-known obfuscators were tested (*) and their output verified to be deobfuscated or partially deobfuscated: appguard arxan dash-o dexguard dexprotector several vendor-specific custom protectors several custom protectors used by malicious applications, e.g. Joker many java classfile (as opposed to targeting dex specifically) protectors, e.g. allatori (*) The \"test process\" is not well-defined or exhaustive. It is partly automated as well as user-guided (therefore, feel free to reach out to us if you're seeing the generic decryptor chocking up on some obfuscation that you think should or could be supported.) Exceptional control flow # The decompilation of code protected in try blocks ( try/catch+/finally? ) is enabled by default. However, reconstruction of try-with-resources (also known as ARM , for Automatic Resource Management ) is more limited. This very-high level Java construct translates into complicated, lengthy, compiler-generated optimized code. Note Better support for try-with-resources reconstruction is a planned addition. Recovering enums # Enumerations in Java are a high-level construct that translate into multiple classes and synthetic methods. JEB attempts to discover and re-sugar those enumeration artifacts into the original enum. On failure, regular classes extending java.lang.Enum will be generated. Note Enum reconstruction can be disabled in the Options. Enums are great candidates for obfuscation, and most Android protectors do obfuscate them. That process destroys important synthetic fields and structures that would allow simple recovery heuristics to work. However, support should function reasonably well, even on enumeration data that was intentionally shuffled to generate decompilation errors. Note that enumerated fields can be renamed . Renaming is done consistently over the code base, including over reconstructed switches making use of such enums. Decompiled enums in android.arch.lifecycle . Renaming and cross-referencing enumerated constants is supported. Custom enumerated constants should also be properly reconstructed, including: Field annotations Custom initializers (see below) Additional methods and method overrides In this complex enumeration, the red block shows a custom initializer. Other interesting bits are the use of overrides and custom methods, annotations, as well as default and non-default constructors. Recovering switches # The detection and reconstruction on switch-on-enum and switch-on-string is supported. Reconstruction of switch-on-string can be very complicated depending on how the compiler has generated and optimized the code, and therefore, is limited to simple cases. This successfully reconstructed switch-on-string is implemented as a double-switch idiom by dx (a sparse switch on hashCode/equals to generate custom indices i, followed by a packed-switch on i). Not all switches are implemented like this. Regular if-conditional trees may be strategically generated by optimizing compilers. Note Better support for switch-on-string reconstruction is a planned addition. Member classes and arguments capturing # Properly rendering non-trivial member classes (particularly non-static named classes or anonymous classes) is made difficult by the fact that some of their arguments are captured from the outer class(es). Properly rendering anonymous constructors, with exact argument types and position, is also challenging. In the example below, an anonymous class initializer is used to hide string decryption code: The anonymous class extends Android\u2019s OnActivityResultListener, instantiates the object, and tosses it immediately. Decryption code takes place in the initializer. Note the captured arguments from the outer container method __m : i , _b . Access to other private class fields is made via synthetic accessor calls that were re-sugared into seemingly direct field access ( BA._b ). Pseudo-moot anonymous class with an instance initializer attempting to conceal string decryption code. Lambdas generation # By default, JEB will try to recover and reconstruct lambdas . Desugared Lambdas # Recovery and reconstruction does not rely on any type of metadata 1, such as special prefixes -$$Lambda$ for classes and methods implementing desugared lambdas in dex 37-. You may therefore see constructs like this: This DEX file contains desugared, non-obfuscated lambdas. This DEX file contained desugared, obfuscated lambdas API In the above cases, the underlying Java AST may be a IJavaNew or IJavaStaticField node. This is not the case for real (not desugared) lambdas. They will map to an IJavaCall node. Lambda reconstruction can be disabled in the options. Lambda rendering can also be disabled in the options, as well as on-demand by right-clicking a decompiled view, Rendering Options . Lambdas options Real Lambdas # Lambda reconstruction also takes place when the code has not been desugared (which is rare!), i.e. code relying on dex38\u2019s invoke-custom and invoke-polymorphic . This DEX file contains real lambdas implemented via invoke-custom API Such lambdas map to an IJavaCall node for which isLambdaCall() will return true. Dynamic invocation opcodes # The translation of invoke-custom whose bootstrap method is LambdaMetafactory.metafactory(...) allows the decompiler to generate proper Java code with lambda constructs. However, this is just one (albeit one of the most important) cases of dynamic dispatch. invoke-custom and related opcodes ( const-method-handle , const-method-type ) cannot be as \"easily\" translated into intermediate representations - and later on, AST. For that reason, those opcodes are translated to regular invocation to artificial methods. Artificial classes in jeb.synthetic # Classes in the jeb.synthetic package are generated automatically by the DEX decompiler: InvokeCustoms contains static methods representing dynamic dispatch to a method handle's callsite done via an invoke-custom opcode: jeb.synthetic.InvokeCustoms.CallSite<INDEX>_<DynamicName>(DynamicPrototype) PooledMethodHandles contains static getters of method handles stored in a DEX pool and retrieved via a const-method-handle opcode: jeb.synthetic.PooledMethodHandles.Entry<INDEX>_<MethodName|FieldName>() : java.lang.invoke.MethodHandle PooledMethodTypes contains static getters of method types stored in a DEX pool and retrieved via a const-method-type opcode: jeb.synthetic.PooledMethodTypes.Entry<INDEX>() : java.lang.invoke.MethodType Decompiling Java Bytecode # JEB supports JLS bytecode decompilation for *.class files and *.jar -like archives ( jar , war , ear , etc.). The Java bytecode is converted to Dalvik using Android's dx by default. It falls-back to using d8 if a problem occurred. Users may choose to use d8 first instead by selecting so in the Options. The resulting DEX file(s) are processed as usual. You may use this to decompile Android Library files ( *.aar files) in JEB. Examining the android-arch-core-runtime library Debugging Apps # Refer to the next section, Android Debugging . Miscellaneous # Bulk decompilation and Export # Bulk decompilation and export to *.java files on disk can be done in the UI client via the menu command File, Export, DEX Fast Decompilation . You may also provide a regular expression filter if you'd like to restrict decompilation to a package and its sub-packages, e.g. com\\.xyz\\..* will decompile all classes in com.xyz and its sub-packages. Refer to this note for generic details on exporting output. Callgraph fragment # The callgraph fragment is not specific to Android (most code analysis can ask to generate one). It is an experimental feature designed to represent trimmed callgraphs of the most important routines and most important invocations between those routines. The fragment is located in the lower right-hand corner of a standard workspace. The callgraph is not generated by default: Empty callgraph Click on the fragment to generate it. The navigation shortcuts are similar to those used in the CFG fragment ('\\' to center, '[' and ']' or zoom in and out, etc.). Click a node to set the focus on the associated routine and their connections. Double-click a node to jump to that routine in the disassembly listing. A generated callgraph Displaying synthetic items # How to always display synthetic fields and methods in decompiled views? In the vast majority of the cases, synthetic accessors used by inner classes need not be displayed as they are re-optimized into direct, seamless outer class field access or method invocation. However, if you wish to display them: In a decompiled view, right-click, \"Rendering Options\" and tick the boxes \"Generate synthetic fields\" and \"Generate synthetic methods\". You may also change this setting once and for all in the Engines option (Edit, Options, Engines). Example: forcing rendering of Synthetic Fields Third-party Frameworks # When analyzing applications using resources located in other frameworks that the Android Framework (e.g. the Samsung framework), follow those steps: Retrieve the custom framework archive using apt pull . It is normally stored somewhere in the device's /system/framework/ folder. Let's call it framework.zip. Run aapt2 dump framework.zip and retrieve the first line, which will be something like Package name=xxxxxxx id=N . Note the id, N . Navigate to the folder listed in your .parsers.apk.FrameworksDirectory engines property. Typically, it will be the HOME_FOLDER/.jeb-android-frameworks folder Copy framework.zip into this folder, and rename it to N.zip JEB should now be able to pick up that framework and use its resources when needed Note 1.zip in the FrameworksDirectory folder is the Android framework itself, which has id 1.","title":"Android Analysis"},{"location":"android.html#plugins","text":"The plugins used to analyze Android apps consist of: The APK plugin is responsible for processing APK files. Encoded resources (arsc) are decoded by this plugin. Other jobs, such as analyzing dex files, analyzing certificates, processing asset files, analyzing binary files, etc. are delegated to appropriate plugins. The DEX plugins: DEX analyzer (DEX parsing and merging, Dalvik disassembling, etc.), DEX decompiler, DEX debuggers. Native code analyzers: disassemblers, decompilers, etc. A handful of other plugins, such as Certificate parsers, XML/HTML/JSON/etc. parsers. This section mostly focuses on the APK plugin and the DEX analyzer. Other plugins are documented in separate sections of this manual.","title":"Plugins"},{"location":"android.html#technical-blogs","text":"Our blog is filled with technical posts that will help you make the most of JEB. It is the ideal companion to this manual. Link: All PNF Software blog posts tagged Android.","title":"Technical Blogs"},{"location":"android.html#api-levels","text":"API levels are regularly mentioned throughout this document. Here is a list of \"recent\" Android versions, their corresponding API levels, as well as notable changes regarding security. Codename Version API level Date New security features R ( DP3 ) 11 30 2020 Privacy updates, APK Signature Scheme v4 Q 10 29 2019 Permissions for privacy, BiometricPrompt Pie 9 28 2018 ART: Vdex with Cdex, AS-FBE, biometric API, lockdown mode, APK Signature Scheme v3 Oreo 8, 8.1 26, 27 2017 ART: OAT with Vdex (oat w/o dex, separate vdex with dex'es), Google Play Protect Nougat 7, 7.1 24, 25 2016 APK Signature Scheme v2, File Based Encryption (FBE - and consequently, DirectBoot), AS-FDE, Android Things Marshmallow 6 23 2015 Adoptable Storage (AS), granular permissions and permission levels (NORMAL, DANGEROUS), Doze & App Standby, Android Wear Lollipop 5, 5.1 21, 22 2014 ART: OAT with dex'es in .rodata, 64-bit support (x86_64, arm64-v8a), Android Auto KitKat 4.4, 4.4W 19, 20 2013 ART (optional), VerifiedBoot, Full Disk Encryption (FDE) Jelly Bean 4.1, 4.2, 4.3 4.4, 4.4W 2012 SELinux introduction, multi-users Android Versions Reference","title":"API Levels"},{"location":"android.html#apk-structure","text":"This section is a short primer on the Android Package file (APK). It is assumed that the reader is already familiar with the structure of an APK. Good introduction material can be found on the official Android developer portal . An Android app is a zip file containing application code, data, and metadata. Code: Dalvik (bytecode), Native (*.so libs) Data: resources (structured), assets (unstructured) Metadata= manifest (what), certificates (who) When JEB processes an APK, the resulting structure in the Project tree will differ from a raw ZIP tree view. The range of differences goes from slightly for regular apps, to significantly for obfuscated or complex apps. The picture below shows a side-by-side comparison of processing an app as a ZIP file vs processing it as an APK: Manifest: encoded VS decoded Certificates: v1 (visible, in file MANIFEST.MF), v2/v3 (in ZIP) VS parsed certificates Bytecode: spread over classes.dex, classes1.dex, ..., classesN.dex VS virtual merged DEX unit Resources: encoded and scattered in resources.arsc, res/, elsewhere (anywhere) VS decoded and reorganized resources Native libs: 1-to-1 Assets: 1-to-1","title":"APK Structure"},{"location":"android.html#certificates","text":"As of Android 11, four types of signatures are in place to sign APKs, versions 1 through 4.","title":"Certificates"},{"location":"android.html#version-1","text":"Version 1 is the legacy scheme supported by all versions of Android: standard Jar signing (Oracle) signing data goes in META-INF/ each individual file in the archive is signed MANIFEST.MF: list of hashes of all files xxx.SF: hash of hash entries in MANIFEST.MF xxx.{RSA,DSA,...}: signature of xxx.SF + signer certificate (= what JEB displays) note that xxx='CERT', usually The apk/zip itself is not signed: this scheme is both inefficient and incomplete when the goal is to verify the APK as a whole","title":"Version 1"},{"location":"android.html#versions-23","text":"Versions 2 and 3 are specific to Android: What is signed is the APK as a whole Uses a twist in zip format specifications The global signing block is inserted just before the zip Central Directory (and can be located by looking for a magic number) V3 = V2 + support for key rotation What is displayed in the Certificate fragment is the signer's certificate, just like V1's review the reference documentation for additional details","title":"Versions 2/3"},{"location":"android.html#version-4","text":"The APK signature scheme version 4 scheme is being introduced with Android 11 (R) to ease development of larger applications. The signature of the APK is done incrementally via a Merkle tree. The signing data is stored separately in an <APKNAME>.idsig file. Note Version 4 signatures do not seem to be designed for release purposes. At the moment, JEB does not parse idsig files. JEB parses v1/v2/v3 signing data. The certificate is displayed as a tree in the UI client: API To retrieve this data programmatically: refer to IApkUnit , methods getSignatureSchemeVersionFlags and getSignatureSchemeV{2,3}Block","title":"Version 4"},{"location":"android.html#manifest","text":"AndroidManifest.xml defines the Android application to whoever interacts with it, from building, to deployment, to execution. Important parts of the Manifest: Package name (fully qualified Java name) Requirements to run the app (API level, hardware configs) Permissions required by the app (not all may be granted by the system at t0) Components must be declared in apps - except for Broadcast receivers, which can be registered dynamically Activities (UI elements) Services (background execution) Broadcast Receivers (receive and process events from apps/system) Content Providers (offer data to other apps/system) Declares whether the app is debuggable on a production device <application android:debuggable=\"false|true\" ... For example, the simple manifest below... declares a app named (internal package name) com.xyz.appcheck requiring at least and ideally API 26 (Android P) wants read+write access to storage the App is debuggable it declares one main activity (visible on launcher) as well as one implicit broadcast receiver Note Manifests can be very complex and lengthy. For example, the primary Facebook app ( com.facebook.katana ) manifest is well over 2000 lines, mostly Activity descriptions.","title":"Manifest"},{"location":"android.html#about-permissions","text":"Permissions provide an indirect insight into what \"functions\" the app needs to perform. They are granted by the user at install and/or runtime: Before API 23, permissions were all granted at install time. A pop-up would display which dangerous permission groups are being requested. With API levels 23+, permissions are granular, and dangerous permissions are granted at run-time unless the Manifest declares targetSdk<23 ! the user will be shown a system pop-up permissions can also be revoked in settings Permissions - whether related code requiring them is used, whether they are granted explicitly or implicitly -, MUST all be declared in the Manifest , i.e. an app cannot programmatically request a permission that was not declared in the Manifest in the first place.","title":"About Permissions"},{"location":"android.html#structured-resources","text":"Structured resources of an app consist of XML files (e.g., app layouts, strings, etc.), image files, icons, etc. XML resources are encoded using a binary format called arsc . The manifest, an XML resource, is encoded as well. Common resources\u2019 information goes into the app resources.arsc file Resources references resources.arsc items by id They can also reference Android Framework and other vendor-installed framework resources by id (refer to the section 'Third-party Frameworks') JEB always ships with the latest official Android Framework Note For additional information on Resources: high-level information can be found in the official doc lower-level details of the arsc format can be found by going through the main implementation of the encoder and decoder, on the AOSP's platform/frameworks/base repository. The newest ResourceTypes.h is located here .","title":"Structured Resources"},{"location":"android.html#oddities-and-obfuscation","text":"Resources on Android can be mangled in several ways. JEB unmangles them to the best of its ability. Below, we briefly describe two commonly found obfuscation techniques.","title":"Oddities and Obfuscation"},{"location":"android.html#name-removal","text":"Resource items are normally identified by a name as well as an id. Several application protectors remove resource names from the compiled resources.arsc file when they reference well-known framework resources. E.g., the manifest below had resource names removed. Note that most XML attribute names are missing. <?xml version=\"1.0\" encoding=\"utf-8\"?> <manifest xmlns:android= \"http://schemas.android.com/apk/res/android\" := \"1.1\" android:versionCode= \"2\" platformBuildVersionName= \"6.0-5078647\" platformBuildVersionCode= \"23\" package= \"com.virginoff.player\" > <uses-sdk := \"7\" := \"23\" /> <uses-permission := \"android.permission.ACCESS_NETWORK_STATE\" /> <uses-permission := \"android.permission.SEND_SMS\" /> <uses-permission := \"android.permission.INTERNET\" /> <uses-permission := \"android.permission.WRITE_EXTERNAL_STORAGE\" /> <uses-permission := \"android.permission.WAKE_LOCK\" /> <application := \"@style/Theme.NoTitleBar.Fullscreen\" := \"Anal Sex Video\" := \"@drawable/ic_launcher\" := \".Application\" := \"false\" > <activity := \".activity.WrapperActivity\" := \"true\" > <intent-filter> <action android:name= \"android.intent.action.MAIN\" /> <category android:name= \"android.intent.category.LAUNCHER\" /> </intent-filter> </activity> <activity := \"o.\u03df\" := \"0\" := \"a0\" /> <activity := \"o.\u022d\" := \"0\" := \"a0\" /> <service := \"o.\u0182\" /> </application> </manifest> Dump the manifest using aapt to see the actual ids: $ aapt dump xmltree 1 .apk AndroidManifest.xml N: android = http://schemas.android.com/apk/res/android E: manifest ( line = 0 ) A: : ( 0x0101021c )= \"1.1\" ( Raw: \"1.1\" ) A: android:versionCode ( 0x0101021b )=( type 0x10 ) 0x2 A: platformBuildVersionName = \"6.0-5078647\" ( Raw: \"6.0-5078647\" ) A: platformBuildVersionCode =( type 0x10 ) 0x17 A: package = \"com.virginoff.player\" ( Raw: \"com.virginoff.player\" ) E: uses-sdk ( line = 0 ) A: : ( 0x0101020c )=( type 0x10 ) 0x7 A: : ( 0x01010270 )=( type 0x10 ) 0x17 E: uses-permission ( line = 0 ) A: : ( 0x01010003 )= \"android.permission.ACCESS_NETWORK_STATE\" ( Raw: \"android.permission.ACCESS_NETWORK_STATE\" ) ... Above, we can see that the uses-permission tag, for example, specifies the use of an attribute whose id is 0x01010003. Attributes of an Android Manifest are well-known resources and stored as such in the Android framework. You can use aapt on the Android framework file to see them: $ aapt dump --values resources ~/.jeb-android-frameworks/1.apk Package Groups (1) Package Group 0 id=0x01 packageCount=1 name=android Package 0 id=0x01 name=android type 0 configCount=1 entryCount=1543 spec resource 0x01010000 android:attr/theme: flags=0x40000000 spec resource 0x01010001 android:attr/label: flags=0x40000000 spec resource 0x01010002 android:attr/icon: flags=0x40000000 ---> spec resource 0x01010003 android:attr/name: flags=0x40000000 spec resource 0x01010004 android:attr/manageSpaceActivity: flags=0x40000000 spec resource 0x01010005 android:attr/allowClearUserData: flags=0x40000000 ... So, that tag could be restored to: <uses-permission name= \"android.permission.ACCESS_NETWORK_STATE\" /> Note The Android framework contains all base system resources for a given version of Android - it is located in the /system/framework/framework-res.apk (resources only) on a device, or the platforms/<APILEVEL>/android.jar in the Android SDK. JEB also drops the latest stable framework to your HOME folder's jeb-android-frameworks/1.apk The above process is automated by JEB to restore XML files to a human-readable states.","title":"Name removal"},{"location":"android.html#flattened-hierarchy","text":"Although most structured resources (with the notable exception of the Manifest) are typically stored hierarchically under the res folder, they do not have to be. Some application protectors take advantage of this fact to flatten the resources tree, and for example, store them in the APK's root folder. E.g., in the file below (a protected online banking app), most resource files were renamed to mangled names and stored alongside the Manifest; the res/ folder is present and contains only a handful of resources. JEB restores both the hierarchy and names of those resource files.","title":"Flattened hierarchy"},{"location":"android.html#decoding-problems","text":"Other oddities exist, they can be found in apps stretching the limits of the arsc format specifications to their boundaries. They can be used, voluntarily or not, to thwart and crash various open-source tools. We won't detail them here, but you can find additional information here and there on our blog as well as the Apktool's GitHub issue tracker , a prime source to find weird parsing cases. As an example, here is aapt2 (version around spring 2019) failing on a version of the Facebook app: $ aapt2 dump Facebook_v153.0.0.54.88.apk error: trying to add resource 'com.facebook.katana:id/(name removed)' with ID 0x7f090001 but resource already has ID 0x7f090000.","title":"Decoding problems"},{"location":"android.html#assets","text":"Assets are unstructured resources. They can be of any type and stored anywhere in the APK archive. However, the assets/ directory is standard, and used by the Android AssetManager object. Assets stored in the Resources folder res/raw are stored as-is (in particular, XML files are not encoded), and yet, are accessible in code by id, using the R class, just like any other standard resource. The asset file below, edd.bin , is holding encrypted data","title":"Assets"},{"location":"android.html#native-code","text":"Android applications often contain native code, compiled as ELF library .so files. They can be located anywhere in the app. SO files can be loaded from bytecode via System.loadLibrary(simpleName) and System.load(path) . A common location for SO files is the app's lib/ folder. Libraries stored in this folder and adhering to the JNI naming convention allow the Android system to unpack appropriate SO to the device folder /data/data/<app>/lib , and make it easier for high-level code to load them, i.e. there is no need to implement the logic of figuring out which underlying platform the device is running on. Location: [APK]/lib/<abi>/lib<name>.so Example: high-level request System.loadLibrary(\"native-lib\") on an aarch64 device => lib/arm64-v8a/libnative-lib.so on a Pixel phone with an Arm64 CPU Info For more information on native code analysis, debugging and decompilation, refer to the manual pages relative to native code .","title":"Native Code"},{"location":"android.html#bytecode","text":"Refer to the DEX sub-section below .","title":"Bytecode"},{"location":"android.html#dex-bytecode","text":"Dex (or DEX , throughout this section), short for Dalvik Executable , is an object container for Dalvik code. It is Android's equivalent of ELF, PE, COFF, etc. containers for native code. The primary dex file of an app is named classes.dex , located in the app's root folder. This file is present in the vast majority of apps, although it is optional: apps can be purely native.","title":"Dex Bytecode"},{"location":"android.html#dex-splitting","text":"Additional DEX files may be present: classes2.dex , classes3.dex , etc. The reason behind code splitting is a Dalvik VM legacy limitation called the \"64K reference limit\": many items present in a DEX file are referenced by an id stored on a 16-bit integer, e.g. it is the case for methods and fields references. To overcome the limitation, compilers such as d8 (or its predecessor dx ) split the code over additional DEX files classesN.dex , where N>=2. Additional references are created to reference definitions located in other DEX files. JEB merges all classesN.dex in a single, virtual DEX unit. Note that in practice, such DEX units could not be converted back to a single DEX file. Also keep in mind that apps may artificially split their code over multiple DEX files; the 64Krefs limit is not a hard requirement. This app was split over 7 dex files: Warning On pre-API 21 (Android 5) systems, it is the responsibility of the app to load additional files - i.e., the DEX splitting mechanism is not something baked into the Dalvik VM itself. Apps can extend the support class MultiDexApplication to avoid implementing their own DEX loader, as the vast majority of the apps do. However, keep in mind that this is in no way mandatory. Malware files or protected files can implement multi-dex loading facility however they see fit. On API 21 and above, with the advent of the new Android ART runtime, files names classesN.dex are scanned and pre-compiled along with classes.dex . However, this mechanism does not preclude apps to use additional DEX loading facility as well.","title":"DEX splitting"},{"location":"android.html#dex-execution","text":"There are two general types of dex files: regular dex files contain generic code, use standard Dalvik instructions, meant to run on all Android devices odex files, on the other hand - a generic term for \"optimized DEX\" - contain device specific instructions.","title":"DEX execution"},{"location":"android.html#optimized-dex-odex","text":"The DEX file(s) located in your app is not the code executed on device - except when debugging. DEX code is executed by a runtime: The legacy runtime (pre-API 21 Lollipop) uses a JIT (just-in-time) compiler and generate odex files on first run. The current runtime is named ART (short for Android Runtime ) and makes use of AOT (ahead-of-time) compilation of Dalvik to native (x86 or ARM) at install time Note The format of optimized DEX files has evolved over time (\"dey\" magic, OAT files with DEX or DEX-like entries, VDEX and CDEX, etc.). The process of reconstructing a DEX from an optimized-DEX is systematic and implemented in several tools, such as baksmali deodex or vdexExtractor . Refer to additional references, such as Lief's notes on OAT and ART , for more information on odex. Link: List of odex instructions .","title":"Optimized dex (odex)"},{"location":"android.html#dex-format","text":"This section quickly summarizes important facts about the DEX format. Refer to the official specifications for additional details: DEX format Bytecode format List of instructions . Structure of a DEX file The format can be linearly represented as: In Header: DEX magic, DEX version: dex\\n0NN\\0 where NN= 35: up to Android 7- 37: Android 7, invoke-virtual and invoke-super accept interface methods ids (support for Java 8's default methods) 38: Android 8, added invoke-polymorphic , invoke-custom , call sites and method handles entries ( details ) 39: Android 9, added const-method-handle , const-method-type ( details ) Tables are ordered alphabetically and do not allow duplicates Note that the map section was purely redundant until DEX 38 and the introduction of method handles and call sites. The three links above cannot be overlooked: any Android reverser should strive for Dex and Dalvik proficiency. That being said, below is a list of lesser-known or overlooked details about about Dalvik: Strings are encoded using a variant of CESU-8 called MUTF-8 (modified UTF-8) 1- 2- 3-byte encoding (whereas UTF-8 allows up to 4-byte) Surrogates: 2x3-byte for chars \\u010000 to \\u10FFFF (whereas canonical representations of UTF-8 does not use surrogates; UTF-16 does) \\u0000 is encoded as \\x00\\x00 (whereas UTF-8 uses \\x00) Special byte \\x00 indicates string end (there is no EOS concept with UTF-X) Some 32-bit integers are encoded using the variable encoding scheme LEB128 and its variants Types use Strings: type definition= index into string pool Prototypes use Strings and Types Shorty definition= index into string pool Full prototype definition = list of indices into type pool The Dalvik bytecode is stored in Code items Call Sites and Method Handles were introduced in DEX 38 The DEX header remained unchanged and does not directly reference those pools; instead, they are referenced in the Map area (which largely remained unused until those items were introduced) Learn more about DEX 38 on our blog","title":"DEX format"},{"location":"android.html#dalvik","text":"Dalvik is the name of the low-level bytecode stored in DEX files. Dalvik bytecode is interpreted by a Virtual Machine (DVM). Generation: Source language: smali (low-level), Java (high-level), Kotlin (very high-level) Java -> javac -> classfiles (Java bytecode) -> dx/d8 -> classes.dex (Dalvik bc) Characteristics: Register-based machine: 65,536 32-bit registers, numbered v0 to v65535 65,535 64-bit registers, \"emulated\" by using consecutive 32-bit registers [v0,v1], [v1,v2], ..., [vN,vN+1] No \"special\" register is accessible: no flag register, no PC register, no current-frame register, etc. Fixed frames (stack is N/A, no stack pointer), size declared in Code items Pointer= object reference ~= fits on a single register (32-bit) Regular instructions range from 2 to 10 bytes (=1 to 5 words) Instruction opcode encoded on a single byte; the second byte of the first word is generally used to encode register indices nop (1w), const-wide v1, 0x1122334455667788L (5w) The generally accepted convention is to represent Dalvik disassembly in smali or a variant of smali. By default, JEB uses a variant of Smali, slightly less verbose (more readable and better suited to be displayed and manipulated in an interactive fragment). Method bodies live in isolation, the concept of \"jump far\" (unstructured dispatch) is irrelevant. Dispatching execution to other methods is done via invoke-xxx instructions only Jumps are always relative to the current PC Retrieving the returned value of a function is done via a move-result-xxx instruction, located right after the invoke-xxx instruction Arithmetic instructions have no side-effects / there is no flag register Data in bytecode is legal: Immediates: Some instructions store literals inline (i.e., within the instruction code), e.g. const-xxx N-way branching instruction: switch-xxx : the jump table is stored within the bytecode Small array initialization: fill-array-data-payload : array data is stored within the bytecode","title":"Dalvik"},{"location":"android.html#calling-convention","text":"The DVM runs managed code and uses a no-side effect, no cleaning calling convention : every function gets a clean register slate upon execution; the parameters are stored at the bottom of the declared frame. Registers are 32-bit wide and noted vX , 0-indexed. The alternate notation pX is used to address registers used to store input method parameters: its indexing start from frame_size - input_slot_counts . Example 1: Method: void foo(int a, char b, bool c, Object d) The CodeItem declares a frame of size 5 v0 v1 <- parameter 0: p0 (a) v2 <- parameter 1: p1 (b) v3 <- parameter 2: p2 (c) v4 <- parameter 3: p3 (d) ------- end of method frame v5 v6 ... v65535 Example 2: Method: void bar(double a, long b, float c) The CodeItem declares a frame of size 8 v0 v1 v2 v3 <- parameter 0: p0 (a) v4 <- parameter 1: p1 (b, lower part) v5 <- parameter 1: p2 (b, higher part) v6 <- parameter 2: p3 (c, lower part) v7 <- parameter 2: p4 (c, higher part) ------- end of method frame v8 v9 ... v65535 The default settings instruct JEB to use the pX notation when rendering parameter registers: It can be disabled (DEX plugin option, also controlled in the UI by right-clicking, Rendering Properties , untick 'Use p for parameters')","title":"Calling convention"},{"location":"android.html#smali-and-variants","text":"The JEB notation is made possible because of the interactivity layer (as opposed to deadcode listing). Two notable differences: For readability, the names are simple names, no longer fully-qualified Invoke opcodes place the arguments after the method: invoke-xxx callsite, args instead of invoke-xxx {args}, fully_qualified_callsite Below, the default assembly code representation used by JEB (smali variant): Official smali code can be generated (it is useful if code needs to be exported, and later on compiled using smali.jar):","title":"Smali and variants"},{"location":"android.html#application-components","text":"The application and its main components (activities, broadcast receivers, services, content providers) must be declared in the Manifest, even if they are not meant to be exported (i.e., the external attribute is set to false). Warning There is one exception: broadcast receivers can be registered dynamically, via one of the Context.registerReceiver() methods. The name attribute of a component is the name of the corresponding class that will be instantiated and whose methods are to be called back by the Android system (for exported components). Example: the Manifest below declares an Activity class com.xyz.appcheck.AppCheck , among other components.","title":"Application components"},{"location":"android.html#entry-points","text":"The exported components of an APK can be equated to the entry-points of the application. Therefore, unlike types of executable programs, an Android application can have multiple entry-points. The true entry-point of a non-native application is the application's static initializer ( Application.<clinit> ). If the application being analyzed declares its own Application class in the manifest (instead of reusing android.app.Application), then that class's static initializer, if any, should be looked at first, followed by the constructors. Similarly, the static initializers and constructors of activities, receivers, services and providers are also entry-points. Finally, all API-defined callback methods of those five components can be called back by the system. Typically, the main activity's onCreate() method is the practical entry-point to an application, akin to a regular program's main() routine. Note JEB's disassembly view recaps the most important features of the APK at the top of the code listing. The important components, in particular any custom Application object, will be mentioned there:","title":"Entry points"},{"location":"android.html#activities","text":"Activities are activated by Intent . Exported activities (by default, any unfiltered activity is exported) are first-class entry-points. The following methods should be carefully examined: constructor (although the object state is uncertain) well-known callbacks, e.g. attachBaseContext (used to set up a delegate Activity), onCreate , onResume , etc.","title":"Activities"},{"location":"android.html#pseudo-activities","text":"Be mindful of activity aliases. They are not true components, however, they can and will override their target component's characteristics, such as intent filters.","title":"Pseudo activities"},{"location":"android.html#services","text":"Services are activated by Intent . Services are started by Activity code or Receiver code (after receiving a particular event). Most won't be easily started by the user, except for a few of them, such as Input services. Therefore, they should not be considered first-class entry-points from the point of view of code analysis.","title":"Services"},{"location":"android.html#broadcast-receivers","text":"Broadcast receivers are activated by Intent . The intent handler for ACTION_BOOT_COMPLETED is a common entry-point, commonly used by malicious code as a way to automatically start after the phone has booted up. Many more exist though (e.g., battery plugged, message received, phone lifted, etc.) Caveats: API 21+ (Lollipop) - need a wake lock API 26+ (Oreo) - need a JobIntentService","title":"Broadcast Receivers"},{"location":"android.html#content-providers","text":"Content providers are activated by ContentResolver .","title":"Content Providers"},{"location":"android.html#intents","text":"Intents are the primary method for inter-process and inter-app communication. Other IPC means exist, e.g. sockets, files, etc. Intents are used to activate components, e.g. start an activity. Reference","title":"Intents"},{"location":"android.html#dalvik-and-disassembly","text":"Plugins generate IUnit objects. Units can generate documents abiding to a standard interface, making them easy to render by clients implementing the JEB API. The primary document generated by an IDexUnit is a text document representing the disassembly of the input DEX files - or merged DEX files.","title":"Dalvik and Disassembly"},{"location":"android.html#auto-dex-merging","text":"Merging is done automatically, regardless of index limitations in place that may have required dex-splitting in the first place. In rare cases, you may want to disable merging. Upon loading an APK, several APK plugin options will be presented to you. Untick Merge multi-dex to disable auto-merging:","title":"Auto dex merging"},{"location":"android.html#dex-parsing-options","text":"DEX plugin options are accessible in the Engines options UI panel. Filter on \"dex.\" to list them. The user will also be presented a Processing Properties dialog box when opening a new file, giving the user a chance to adjust the default options stored in your jeb-engines.cfg files.","title":"DEX parsing options"},{"location":"android.html#addressing","text":"All addresses to types, methods and fields uses the canonical JVM notation, e.g.: type Blah in package com.abc: Lcom/abc/Blah; method foo(int):void in the type com.abc.Blah: Lcom/abc/Blah;->foo(I)V field name:String in the type com.abc.Blah: Lcom/abc/Blah;->name:Ljava/lang/String JEB extends the method notation to reference code locations via a suffix +OFFSET . Reference the instruction at offset 0x20 in the internal method foo(): Lcom/abc/Blah;->foo(I)V+20h","title":"Addressing"},{"location":"android.html#types-naming-conventions","text":"Historically, addressing in Java can be quite confusing. There exists three types of notations: The JVM notation (canonical representation) is the one used by DEX's TypeDescriptors , e.g. Ljava/lang/Object; . JEB's DEX plugins use and provide JVM canonical names. Two JLS notations : binary form, uses dots to separate package names, e.g.: java.lang.Object internal binary (or just, 'internal') uses slashes, e.g.: java/lang/Object The java.lang.Class API uses inconsistent representations, mostly the binary form. Android plugins use the JVM notation internally and externally (public API). Example: to reference a method void foo(String) in package a.b.c , its JVM address should be provided: La/b/c;->foo(Ljava/lang/String;)V . API methods using DEX addresses expect canonical addresses. The graphical client is less strict: although it expects canonical addresses by default as well, fall-back mechanisms are implemented to determine which address the user may have intended to use, and attempt to see if it's a match. See our Reference Document.","title":"Types Naming Conventions"},{"location":"android.html#disassembly","text":"The default output uses modified smali (as explained in the previous section). TODO This section is a work-in-progress.","title":"Disassembly"},{"location":"android.html#renaming-and-refactoring","text":"The DEX plugin provides smart renaming capabilities: renaming of items is done consistently throughout the code base. Most internal items can be renamed (internal items are those defined in the DEX, as opposed to external items, simply referenced in the DEX, but whose definition is located elsewhere). What can be renamed: class names (as well as interfaces and enums defined in the DEX) method names field names labels (addresses) package names variables (in decompiled units) In the UI client, Renaming can be done via the Action menu.","title":"Renaming and Refactoring"},{"location":"android.html#renaming-methods","text":"Proper refactoring is especially important when renaming non-static methods (virtual methods, interface methods) which may be part of a hierarchy of other methods, overridden parents or overriding children. Example: renaming B:a() should also rename A.a() and C.a() A.a():Object | B.a():String | C.a():String Renaming must also take into account indirect references to methods, something common when invoking virtual methods located in other classes, but which can be used to obfuscate a program further. A.a() | B.a() - within B: invoke-virtual A.a() -> actually refers to B.a() Things can get relatively complicated when hierarchies involve multiple inheritance through one or more interfaces.","title":"Renaming Methods"},{"location":"android.html#renaming-fields","text":"To some degree, the same applies to fields. Unlike methods, fields cannot be overridden; they are always accessed in a direct way, i.e. resolution is entirely determined at compile-time. However, field masking adds complications. A.i:int public | B.i:int public - this field masks A.i Shall a rename action of A.i also rename B.i? Conversely, shall renaming B.i also rename A.i? Theoretically, no. Those two fields are not related. However, at the moment, the DEX plugin renames both fields to maintain some degree of visual consistency with the original binary, regardless of whether field masking was done voluntarily or not, with obfuscating intent or not. This is likely to change with the addition of an option to let users decide how they want to perform renaming.","title":"Renaming Fields"},{"location":"android.html#reorganizing-code","text":"Packages can also be renamed. Users can also create additional packages and move packages and classes to other packages. This feature can come in handy when dealing with obfuscated code for which entire type hierarchies were flattened out into a handful (sometimes single) set of packages. Most obfuscators, including the ubiquitous Proguard and its now equivalent r8, can do that. If you want to explore refactoring further, in particular hierarchy reconstruction, have a look at our sample script DexCluster.py .","title":"Reorganizing code"},{"location":"android.html#auto-rename","text":"Auto-renaming is an optional standard Action also implemented by the DEX plugin. As its name implies, it can perform automatic blanket renaming of all items of a unit. In the case of DEX units, they include types, methods, fields, etc. The action is semi-customizable by each plugin, as can be seen in the API . In the case of the DEX plugin, three policies are implemented. Each policy defines a set of legal characters for items. The loosest policy permits all characters in the printable ascii range (something already relatively strict considering the actual legal character ranges for Java identifiers); the strictest considers all current names (except those that were already defined) invalid, and therefore, will rename everything. The obfuscation applied below is using right-to-left unicode characters to complicate rendering: After auto-renaming (standard policy):","title":"Auto-rename"},{"location":"android.html#cross-references-in-dalvik","text":"Refer to the generic xrefs section of the manual. TODO The documentation of DEX specificities regarding xrefs are a WIP.","title":"Cross-references in Dalvik"},{"location":"android.html#decompilation-to-java","text":"Note Make sure to read the generic Decompilation section of the manual.","title":"Decompilation to Java"},{"location":"android.html#decompiling-classes","text":"By default, the Decompile action in the UI menu triggers the decompilation of an entire class and its constituents (fields, methods, member classes, etc.). Fresh decompilation: With the current options set up in your Engines context: Use Action, Decompile or press the Tab key . With custom options: use Action, Decompile with Options or press the CMD1+Tab . Re-decompile (e.g., after changing options) Execute a \"Decompile with Options\" action as described above. The current decompilation of the class, if it existed, will be discarded, and a new decompilation will take place.","title":"Decompiling classes"},{"location":"android.html#generic-decryption-and-deobfuscation","text":"The decompiler attempts to automatically performs data decryption and code unreflection. This process is done automatically by several method optimizers managed by the decompiler, with the help of code emulation in a built-in sandbox. Sample malware code decompilation: light-blue methods have been unreflected; Purple strings are the result of generic decryptions While the emulator and sandbox are currently not available in the API, a few key parameters of the emulator can be customized via the coreplugins/dexdec-emu.cfg file. Copy the file dexdec-emu.cfg.TEMPLATE to dexdec-emu.cfg Edit dexdec-emu.cfg The changes will take effect at the next decompilation Currently, the configuration file allows users to specify: maximum emulation times emulation policy for external methods (by groups, restricted lists, whitelists, and blacklists - e.g., a user can forbid the emulation of any time/date-related method) Note As of April 2020, data decryption combined with unreflection yields very effective results against most classes of Dalvik obfuscators. You will find examples of this on our blog .","title":"Generic decryption and deobfuscation"},{"location":"android.html#known-support","text":"As of April 2020 , the following well-known obfuscators were tested (*) and their output verified to be deobfuscated or partially deobfuscated: appguard arxan dash-o dexguard dexprotector several vendor-specific custom protectors several custom protectors used by malicious applications, e.g. Joker many java classfile (as opposed to targeting dex specifically) protectors, e.g. allatori (*) The \"test process\" is not well-defined or exhaustive. It is partly automated as well as user-guided (therefore, feel free to reach out to us if you're seeing the generic decryptor chocking up on some obfuscation that you think should or could be supported.)","title":"Known support"},{"location":"android.html#exceptional-control-flow","text":"The decompilation of code protected in try blocks ( try/catch+/finally? ) is enabled by default. However, reconstruction of try-with-resources (also known as ARM , for Automatic Resource Management ) is more limited. This very-high level Java construct translates into complicated, lengthy, compiler-generated optimized code. Note Better support for try-with-resources reconstruction is a planned addition.","title":"Exceptional control flow"},{"location":"android.html#recovering-enums","text":"Enumerations in Java are a high-level construct that translate into multiple classes and synthetic methods. JEB attempts to discover and re-sugar those enumeration artifacts into the original enum. On failure, regular classes extending java.lang.Enum will be generated. Note Enum reconstruction can be disabled in the Options. Enums are great candidates for obfuscation, and most Android protectors do obfuscate them. That process destroys important synthetic fields and structures that would allow simple recovery heuristics to work. However, support should function reasonably well, even on enumeration data that was intentionally shuffled to generate decompilation errors. Note that enumerated fields can be renamed . Renaming is done consistently over the code base, including over reconstructed switches making use of such enums. Decompiled enums in android.arch.lifecycle . Renaming and cross-referencing enumerated constants is supported. Custom enumerated constants should also be properly reconstructed, including: Field annotations Custom initializers (see below) Additional methods and method overrides In this complex enumeration, the red block shows a custom initializer. Other interesting bits are the use of overrides and custom methods, annotations, as well as default and non-default constructors.","title":"Recovering enums"},{"location":"android.html#recovering-switches","text":"The detection and reconstruction on switch-on-enum and switch-on-string is supported. Reconstruction of switch-on-string can be very complicated depending on how the compiler has generated and optimized the code, and therefore, is limited to simple cases. This successfully reconstructed switch-on-string is implemented as a double-switch idiom by dx (a sparse switch on hashCode/equals to generate custom indices i, followed by a packed-switch on i). Not all switches are implemented like this. Regular if-conditional trees may be strategically generated by optimizing compilers. Note Better support for switch-on-string reconstruction is a planned addition.","title":"Recovering switches"},{"location":"android.html#member-classes-and-arguments-capturing","text":"Properly rendering non-trivial member classes (particularly non-static named classes or anonymous classes) is made difficult by the fact that some of their arguments are captured from the outer class(es). Properly rendering anonymous constructors, with exact argument types and position, is also challenging. In the example below, an anonymous class initializer is used to hide string decryption code: The anonymous class extends Android\u2019s OnActivityResultListener, instantiates the object, and tosses it immediately. Decryption code takes place in the initializer. Note the captured arguments from the outer container method __m : i , _b . Access to other private class fields is made via synthetic accessor calls that were re-sugared into seemingly direct field access ( BA._b ). Pseudo-moot anonymous class with an instance initializer attempting to conceal string decryption code.","title":"Member classes and arguments capturing"},{"location":"android.html#lambdas-generation","text":"By default, JEB will try to recover and reconstruct lambdas .","title":"Lambdas generation"},{"location":"android.html#desugared-lambdas","text":"Recovery and reconstruction does not rely on any type of metadata 1, such as special prefixes -$$Lambda$ for classes and methods implementing desugared lambdas in dex 37-. You may therefore see constructs like this: This DEX file contains desugared, non-obfuscated lambdas. This DEX file contained desugared, obfuscated lambdas API In the above cases, the underlying Java AST may be a IJavaNew or IJavaStaticField node. This is not the case for real (not desugared) lambdas. They will map to an IJavaCall node. Lambda reconstruction can be disabled in the options. Lambda rendering can also be disabled in the options, as well as on-demand by right-clicking a decompiled view, Rendering Options . Lambdas options","title":"Desugared Lambdas"},{"location":"android.html#real-lambdas","text":"Lambda reconstruction also takes place when the code has not been desugared (which is rare!), i.e. code relying on dex38\u2019s invoke-custom and invoke-polymorphic . This DEX file contains real lambdas implemented via invoke-custom API Such lambdas map to an IJavaCall node for which isLambdaCall() will return true.","title":"Real Lambdas"},{"location":"android.html#dynamic-invocation-opcodes","text":"The translation of invoke-custom whose bootstrap method is LambdaMetafactory.metafactory(...) allows the decompiler to generate proper Java code with lambda constructs. However, this is just one (albeit one of the most important) cases of dynamic dispatch. invoke-custom and related opcodes ( const-method-handle , const-method-type ) cannot be as \"easily\" translated into intermediate representations - and later on, AST. For that reason, those opcodes are translated to regular invocation to artificial methods.","title":"Dynamic invocation opcodes"},{"location":"android.html#artificial-classes-in-jebsynthetic","text":"Classes in the jeb.synthetic package are generated automatically by the DEX decompiler: InvokeCustoms contains static methods representing dynamic dispatch to a method handle's callsite done via an invoke-custom opcode: jeb.synthetic.InvokeCustoms.CallSite<INDEX>_<DynamicName>(DynamicPrototype) PooledMethodHandles contains static getters of method handles stored in a DEX pool and retrieved via a const-method-handle opcode: jeb.synthetic.PooledMethodHandles.Entry<INDEX>_<MethodName|FieldName>() : java.lang.invoke.MethodHandle PooledMethodTypes contains static getters of method types stored in a DEX pool and retrieved via a const-method-type opcode: jeb.synthetic.PooledMethodTypes.Entry<INDEX>() : java.lang.invoke.MethodType","title":"Artificial classes in jeb.synthetic"},{"location":"android.html#decompiling-java-bytecode","text":"JEB supports JLS bytecode decompilation for *.class files and *.jar -like archives ( jar , war , ear , etc.). The Java bytecode is converted to Dalvik using Android's dx by default. It falls-back to using d8 if a problem occurred. Users may choose to use d8 first instead by selecting so in the Options. The resulting DEX file(s) are processed as usual. You may use this to decompile Android Library files ( *.aar files) in JEB. Examining the android-arch-core-runtime library","title":"Decompiling Java Bytecode"},{"location":"android.html#debugging-apps","text":"Refer to the next section, Android Debugging .","title":"Debugging Apps"},{"location":"android.html#miscellaneous","text":"","title":"Miscellaneous"},{"location":"android.html#bulk-decompilation-and-export","text":"Bulk decompilation and export to *.java files on disk can be done in the UI client via the menu command File, Export, DEX Fast Decompilation . You may also provide a regular expression filter if you'd like to restrict decompilation to a package and its sub-packages, e.g. com\\.xyz\\..* will decompile all classes in com.xyz and its sub-packages. Refer to this note for generic details on exporting output.","title":"Bulk decompilation and Export"},{"location":"android.html#callgraph-fragment","text":"The callgraph fragment is not specific to Android (most code analysis can ask to generate one). It is an experimental feature designed to represent trimmed callgraphs of the most important routines and most important invocations between those routines. The fragment is located in the lower right-hand corner of a standard workspace. The callgraph is not generated by default: Empty callgraph Click on the fragment to generate it. The navigation shortcuts are similar to those used in the CFG fragment ('\\' to center, '[' and ']' or zoom in and out, etc.). Click a node to set the focus on the associated routine and their connections. Double-click a node to jump to that routine in the disassembly listing. A generated callgraph","title":"Callgraph fragment"},{"location":"android.html#displaying-synthetic-items","text":"How to always display synthetic fields and methods in decompiled views? In the vast majority of the cases, synthetic accessors used by inner classes need not be displayed as they are re-optimized into direct, seamless outer class field access or method invocation. However, if you wish to display them: In a decompiled view, right-click, \"Rendering Options\" and tick the boxes \"Generate synthetic fields\" and \"Generate synthetic methods\". You may also change this setting once and for all in the Engines option (Edit, Options, Engines). Example: forcing rendering of Synthetic Fields","title":"Displaying synthetic items"},{"location":"android.html#third-party-frameworks","text":"When analyzing applications using resources located in other frameworks that the Android Framework (e.g. the Samsung framework), follow those steps: Retrieve the custom framework archive using apt pull . It is normally stored somewhere in the device's /system/framework/ folder. Let's call it framework.zip. Run aapt2 dump framework.zip and retrieve the first line, which will be something like Package name=xxxxxxx id=N . Note the id, N . Navigate to the folder listed in your .parsers.apk.FrameworksDirectory engines property. Typically, it will be the HOME_FOLDER/.jeb-android-frameworks folder Copy framework.zip into this folder, and rename it to N.zip JEB should now be able to pick up that framework and use its resources when needed Note 1.zip in the FrameworksDirectory folder is the Android framework itself, which has id 1.","title":"Third-party Frameworks"},{"location":"client-configuration.html","text":"The UI client stores its client configuration , also known as the front-end configuration, in bin/jeb-client.cfg . The configuration file is a key-value store where keys are fully-qualified identifiers that start with a leading dot. The public keys can safely be changed by a user. They are accessible in the Options dialog, Advanced mode, panel Client . .CheckUpdates # Description : Let JEB automatically check for software updates (requires an Internet connection) Type and Default : Boolean(true) .DevelopmentMode # Description : Increase verbosity and error messages. Recommended when developing JEB Extensions (plugins or scripts). Type and Default : Boolean(false) .NetworkProxy # Description : Network proxy settings for JEB client components. The format of this property is: 'type|hostname|port|user|pass|whitelist'. type can be direct (no proxy), http, or socks hostname and port are mandatory for non-direct proxy types user and password are optional (needed only if your proxy requires authentication) whitelist is an optional list of domains/IPs (with support for the wildcard character *) for which no proxy connection should be used (always direct connect) Type and Default : String(\"\") .ScriptsFolder # Description : Folder containing JEB client scripts written in Python Type and Default : Path(\"$JEB_HOME/scripts\") .UpdateChannel # Description : Most unstable channel on which software updates are downloaded: 0= RELEASE (default value, i.e. stable updates only) 1= RELEASE, BETA 2= RELEASE, BETA, ALPHA (all channels) Type and Default : Integer(0){0+} .UploadErrorLogs # Description : Securely upload error logs to PNF Software error server Type and Default : Boolean(true) .ui.AlwaysLoadFragments # Description : Always load view fragments (leave to false to let lazy fragments load their data only they are visualized by the user) Type and Default : Boolean(false) .ui.AutoOpenDefaultUnit # Description : Upon processing a new file artifact, the default unit (internal rule set) will be opened - and the default fragment potentially opened as well Type and Default : Boolean(true) .ui.DoNotReplaceViews # Description : Create a new fragment when visualizing a type of document already opened in the workspace (instead of replacing it) Type and Default : Boolean(true) .ui.ExpandTreeNodesOnFiltering # Description : Expand matching tree nodes when applying a string filter Type and Default : Boolean(true) .ui.KeyboardShortcutsFile # Description : Location of the custom keyboard shortcuts file Type and Default : Path(\"jeb-shortcuts.cfg\") .ui.LoggerMaxLength # Description : Maximum log buffer size in characters (older logger lines get discarded) Type and Default : Integer(524288){0+} .ui.PreferRealAddressesInDialogs # Description : In dialogs displaying addresses (eg, cross-references), always display real (internal) addresses over user-friendly addresses that may be provided by plugins Type and Default : Boolean(false) .ui.ProjectUnitSync # Description : Keep the unit that generated the currently visualized item visible in the Project tree Type and Default : Boolean(false) .ui.ShowWarningNotificationsInStatus # Description : Show important notifications by flashing a Warning sign in the status bar Type and Default : Boolean(true) .ui.graphs.AutoGenerate # Description : Auto-generate the global graph upon processing a binary file Type and Default : Boolean(false) .ui.graphs.KeepInMainDock # Description : Keep the global graph docked in the main shell instead of being in a floating modeless dialog Type and Default : Boolean(true) .ui.graphs.LockView # Description : Lock the global graph: prevent auto-moving/sync'ing with the currently active method or code item Type and Default : Boolean(false) .ui.native.DisableTypePreparsing # Description : Disable native type pre-parsing (syntax validation) in type edition dialogs Type and Default : Boolean(false) .ui.state.MainShellBounds # Description : Bounds of the main shell. Leave blank for default; else: -1=maximized, or a set of \"x,y,w,h\" to remember position and size) Type and Default : String(\"\") .ui.text.AllowLineWrapping # Description : Wrap overly long lines Type and Default : Boolean(false) .ui.text.CharactersPerLineMax # Description : Maximum number of characters per line before forcing a line-wrap (whether or not line wrapping is enabled) Type and Default : Integer(4000){0+} .ui.text.CharactersWrap # Description : Limit of a line before wrapping, if line wrap is enabled Type and Default : Integer(-1) .ui.text.DisplayEolAtEod # Description : Display an extra line at the end of a text document Type and Default : Boolean(true) .ui.text.NavigationBarPosition # Description : Position of the navigation bar: 1=top, 2=right (default), 3=bottom, 4=left Type and Default : Integer(2){0-4} .ui.text.ScrollLineSize # Description : Number of lines scrolled on a mouse-whell scroll action Type and Default : Integer(2) .ui.text.cfg.ShowAddresses # Description : Show addresses in control flow graph views Type and Default : Boolean(false) .ui.text.cfg.ShowBytesCount # Description : Show bytes in control flow graph views Type and Default : Integer(0) .ui.tree.BucketFlatMaxElements # Description : Maximum number of elements in a single artificial bucket Type and Default : Integer(500){0+} .ui.tree.BucketFlatThreshold # Description : Element count threshold that will trigger the creation of buckets in tree viewers with flat structures (eg, native code hierarchies) Type and Default : Integer(2000){0+} .ui.tree.BucketTreeMaxElements # Description : Maximum number of elements in a single artificial bucket Type and Default : Integer(200){0+} .ui.tree.BucketTreeThreshold # Description : Element count threshold that will trigger the creation of buckets in tree viewers with hierarchical structures (eg, Dalvik hierarchies) Type and Default : Integer(200){0+} .ui.tree.UseExplicitDefaultPackage # Description : Use a default package when artificial buckets in tree viewers are created Type and Default : Boolean(true) .ui.tree.code.AlwaysShowExtraColumns # Description : Always show additional columns in code hierarchies, to display sizes, addresses, etc. (if available) Type and Default : Boolean(false)","title":"Client Configuration"},{"location":"client-configuration.html#checkupdates","text":"Description : Let JEB automatically check for software updates (requires an Internet connection) Type and Default : Boolean(true)","title":".CheckUpdates"},{"location":"client-configuration.html#developmentmode","text":"Description : Increase verbosity and error messages. Recommended when developing JEB Extensions (plugins or scripts). Type and Default : Boolean(false)","title":".DevelopmentMode"},{"location":"client-configuration.html#networkproxy","text":"Description : Network proxy settings for JEB client components. The format of this property is: 'type|hostname|port|user|pass|whitelist'. type can be direct (no proxy), http, or socks hostname and port are mandatory for non-direct proxy types user and password are optional (needed only if your proxy requires authentication) whitelist is an optional list of domains/IPs (with support for the wildcard character *) for which no proxy connection should be used (always direct connect) Type and Default : String(\"\")","title":".NetworkProxy"},{"location":"client-configuration.html#scriptsfolder","text":"Description : Folder containing JEB client scripts written in Python Type and Default : Path(\"$JEB_HOME/scripts\")","title":".ScriptsFolder"},{"location":"client-configuration.html#updatechannel","text":"Description : Most unstable channel on which software updates are downloaded: 0= RELEASE (default value, i.e. stable updates only) 1= RELEASE, BETA 2= RELEASE, BETA, ALPHA (all channels) Type and Default : Integer(0){0+}","title":".UpdateChannel"},{"location":"client-configuration.html#uploaderrorlogs","text":"Description : Securely upload error logs to PNF Software error server Type and Default : Boolean(true)","title":".UploadErrorLogs"},{"location":"client-configuration.html#uialwaysloadfragments","text":"Description : Always load view fragments (leave to false to let lazy fragments load their data only they are visualized by the user) Type and Default : Boolean(false)","title":".ui.AlwaysLoadFragments"},{"location":"client-configuration.html#uiautoopendefaultunit","text":"Description : Upon processing a new file artifact, the default unit (internal rule set) will be opened - and the default fragment potentially opened as well Type and Default : Boolean(true)","title":".ui.AutoOpenDefaultUnit"},{"location":"client-configuration.html#uidonotreplaceviews","text":"Description : Create a new fragment when visualizing a type of document already opened in the workspace (instead of replacing it) Type and Default : Boolean(true)","title":".ui.DoNotReplaceViews"},{"location":"client-configuration.html#uiexpandtreenodesonfiltering","text":"Description : Expand matching tree nodes when applying a string filter Type and Default : Boolean(true)","title":".ui.ExpandTreeNodesOnFiltering"},{"location":"client-configuration.html#uikeyboardshortcutsfile","text":"Description : Location of the custom keyboard shortcuts file Type and Default : Path(\"jeb-shortcuts.cfg\")","title":".ui.KeyboardShortcutsFile"},{"location":"client-configuration.html#uiloggermaxlength","text":"Description : Maximum log buffer size in characters (older logger lines get discarded) Type and Default : Integer(524288){0+}","title":".ui.LoggerMaxLength"},{"location":"client-configuration.html#uipreferrealaddressesindialogs","text":"Description : In dialogs displaying addresses (eg, cross-references), always display real (internal) addresses over user-friendly addresses that may be provided by plugins Type and Default : Boolean(false)","title":".ui.PreferRealAddressesInDialogs"},{"location":"client-configuration.html#uiprojectunitsync","text":"Description : Keep the unit that generated the currently visualized item visible in the Project tree Type and Default : Boolean(false)","title":".ui.ProjectUnitSync"},{"location":"client-configuration.html#uishowwarningnotificationsinstatus","text":"Description : Show important notifications by flashing a Warning sign in the status bar Type and Default : Boolean(true)","title":".ui.ShowWarningNotificationsInStatus"},{"location":"client-configuration.html#uigraphsautogenerate","text":"Description : Auto-generate the global graph upon processing a binary file Type and Default : Boolean(false)","title":".ui.graphs.AutoGenerate"},{"location":"client-configuration.html#uigraphskeepinmaindock","text":"Description : Keep the global graph docked in the main shell instead of being in a floating modeless dialog Type and Default : Boolean(true)","title":".ui.graphs.KeepInMainDock"},{"location":"client-configuration.html#uigraphslockview","text":"Description : Lock the global graph: prevent auto-moving/sync'ing with the currently active method or code item Type and Default : Boolean(false)","title":".ui.graphs.LockView"},{"location":"client-configuration.html#uinativedisabletypepreparsing","text":"Description : Disable native type pre-parsing (syntax validation) in type edition dialogs Type and Default : Boolean(false)","title":".ui.native.DisableTypePreparsing"},{"location":"client-configuration.html#uistatemainshellbounds","text":"Description : Bounds of the main shell. Leave blank for default; else: -1=maximized, or a set of \"x,y,w,h\" to remember position and size) Type and Default : String(\"\")","title":".ui.state.MainShellBounds"},{"location":"client-configuration.html#uitextallowlinewrapping","text":"Description : Wrap overly long lines Type and Default : Boolean(false)","title":".ui.text.AllowLineWrapping"},{"location":"client-configuration.html#uitextcharactersperlinemax","text":"Description : Maximum number of characters per line before forcing a line-wrap (whether or not line wrapping is enabled) Type and Default : Integer(4000){0+}","title":".ui.text.CharactersPerLineMax"},{"location":"client-configuration.html#uitextcharacterswrap","text":"Description : Limit of a line before wrapping, if line wrap is enabled Type and Default : Integer(-1)","title":".ui.text.CharactersWrap"},{"location":"client-configuration.html#uitextdisplayeolateod","text":"Description : Display an extra line at the end of a text document Type and Default : Boolean(true)","title":".ui.text.DisplayEolAtEod"},{"location":"client-configuration.html#uitextnavigationbarposition","text":"Description : Position of the navigation bar: 1=top, 2=right (default), 3=bottom, 4=left Type and Default : Integer(2){0-4}","title":".ui.text.NavigationBarPosition"},{"location":"client-configuration.html#uitextscrolllinesize","text":"Description : Number of lines scrolled on a mouse-whell scroll action Type and Default : Integer(2)","title":".ui.text.ScrollLineSize"},{"location":"client-configuration.html#uitextcfgshowaddresses","text":"Description : Show addresses in control flow graph views Type and Default : Boolean(false)","title":".ui.text.cfg.ShowAddresses"},{"location":"client-configuration.html#uitextcfgshowbytescount","text":"Description : Show bytes in control flow graph views Type and Default : Integer(0)","title":".ui.text.cfg.ShowBytesCount"},{"location":"client-configuration.html#uitreebucketflatmaxelements","text":"Description : Maximum number of elements in a single artificial bucket Type and Default : Integer(500){0+}","title":".ui.tree.BucketFlatMaxElements"},{"location":"client-configuration.html#uitreebucketflatthreshold","text":"Description : Element count threshold that will trigger the creation of buckets in tree viewers with flat structures (eg, native code hierarchies) Type and Default : Integer(2000){0+}","title":".ui.tree.BucketFlatThreshold"},{"location":"client-configuration.html#uitreebuckettreemaxelements","text":"Description : Maximum number of elements in a single artificial bucket Type and Default : Integer(200){0+}","title":".ui.tree.BucketTreeMaxElements"},{"location":"client-configuration.html#uitreebuckettreethreshold","text":"Description : Element count threshold that will trigger the creation of buckets in tree viewers with hierarchical structures (eg, Dalvik hierarchies) Type and Default : Integer(200){0+}","title":".ui.tree.BucketTreeThreshold"},{"location":"client-configuration.html#uitreeuseexplicitdefaultpackage","text":"Description : Use a default package when artificial buckets in tree viewers are created Type and Default : Boolean(true)","title":".ui.tree.UseExplicitDefaultPackage"},{"location":"client-configuration.html#uitreecodealwaysshowextracolumns","text":"Description : Always show additional columns in code hierarchies, to display sizes, addresses, etc. (if available) Type and Default : Boolean(false)","title":".ui.tree.code.AlwaysShowExtraColumns"},{"location":"debugging.html","text":"Debugging Android apps Looking to dive head-first into Android application debugging? Read on and then head to the Android Debugging section. Debuggers are special modules that attach to existing code units. They do not produce additional units; instead, they provide specialized actions , accessible graphically via the Debugger menu in the UI client. An example of two debugger units (Dalvik and native) connected to an Android app Scripting Debugger modules offer a rich API. UI clients can only reflect those functionality partly. Visit the Resources sub-section for more information on how to use the debuggers API to perform advanced dynamic analysis of applications. Availability # JEB ships with debuggers for: Android DEX bytecode: the debugger implements JDWP Machine code (x86/x86-64, ARM/ARM64, MIPS, etc.): the debugger implements the gdb/lldb protocol Attaching to a Target # Open a code view representing the code unit to be debugged. Execute Debugger/Attach Select the target machine and target process Click Attach Attaching to a local target One or more debugger unit(s) will be created, depending on your target application. Views # The UI client will also open automatically open views that represent the debugger units. Those views are: Threads Breakpoints Local variables and registers Memory and live disassembly (if applicable) Current stack (if applicable) Log view An ongoing debugging session You may want to switch to a custom layout to better accommodate those additional views. The above pictures shows an on-going debugging session of an Android app. A custom layout is used: the bytecode debugger views are in the top-right hand quadrant the process code debugger views are in the bottom-right hand quadrant A breakpoint can also be seen, as well as the about-to-be-executed line of code. Basic Commands # The basic commands are accessible from the Debugger menu. Detach from or restart the debugging session Pause, resume, or terminate the target Suspend or resume threads Set breakpoints Step execution (into, over, or out of a routine) etc. The live values of variables and registers can also be examined by hovering over an item representing them. Advanced Commands # Advanced debugging commands can be used via the Console view. This view is linked to command interpreters offered by the currently focused unit. Debuggers offer command interpreter to perform advanced tasks such as: Searching patterns in memory Examining objects Creating objects or invoking methods Custom tasks specific to a given debugger that cannot be generically represented by the UI client An expanded Console view with an interpreter connected to the Dalvik Bytecode debugger Learn more A detailed overview of the interpreters' features can be found on our blog . Android Debugging # Learn more about Android application debugging by going through this next manual page .","title":"Debugging"},{"location":"debugging.html#availability","text":"JEB ships with debuggers for: Android DEX bytecode: the debugger implements JDWP Machine code (x86/x86-64, ARM/ARM64, MIPS, etc.): the debugger implements the gdb/lldb protocol","title":"Availability"},{"location":"debugging.html#attaching-to-a-target","text":"Open a code view representing the code unit to be debugged. Execute Debugger/Attach Select the target machine and target process Click Attach Attaching to a local target One or more debugger unit(s) will be created, depending on your target application.","title":"Attaching to a Target"},{"location":"debugging.html#views","text":"The UI client will also open automatically open views that represent the debugger units. Those views are: Threads Breakpoints Local variables and registers Memory and live disassembly (if applicable) Current stack (if applicable) Log view An ongoing debugging session You may want to switch to a custom layout to better accommodate those additional views. The above pictures shows an on-going debugging session of an Android app. A custom layout is used: the bytecode debugger views are in the top-right hand quadrant the process code debugger views are in the bottom-right hand quadrant A breakpoint can also be seen, as well as the about-to-be-executed line of code.","title":"Views"},{"location":"debugging.html#basic-commands","text":"The basic commands are accessible from the Debugger menu. Detach from or restart the debugging session Pause, resume, or terminate the target Suspend or resume threads Set breakpoints Step execution (into, over, or out of a routine) etc. The live values of variables and registers can also be examined by hovering over an item representing them.","title":"Basic Commands"},{"location":"debugging.html#advanced-commands","text":"Advanced debugging commands can be used via the Console view. This view is linked to command interpreters offered by the currently focused unit. Debuggers offer command interpreter to perform advanced tasks such as: Searching patterns in memory Examining objects Creating objects or invoking methods Custom tasks specific to a given debugger that cannot be generically represented by the UI client An expanded Console view with an interpreter connected to the Dalvik Bytecode debugger Learn more A detailed overview of the interpreters' features can be found on our blog .","title":"Advanced Commands"},{"location":"debugging.html#android-debugging","text":"Learn more about Android application debugging by going through this next manual page .","title":"Android Debugging"},{"location":"decompiling.html","text":"Decompilers are special modules that work on units as input instead of artifacts. They produce units as well, representing portions of decompiled source code. Decompilers # JEB Pro ships with decompilers for: Dalvik (Android DEX files) Java (classfile) WebAssembly modules (wasm) Ethereum contracts (EVM code) Intel x86 32-bit (all x86 - x87/mmx/sse/avx support coming in JEB 4) Intel x86 64-bit (all x86 - x87/mmx/sse/avx support coming in JEB 4) ARM 32-bit (and common ISA extensions) ARM 64-bit (v8 / aarch64) MIPS 32-bit The following picture shows a child decompiler unit, as well as a suite of decompiled classes units. Internals # Currently, JEB relies on two separate decompiler pipelines: DEXDEC is the DEX/Dalvik (as well as Java) decompiler. This decompiler works exclusively with Dalvik input. The primary interface to the reference implementation is IDexDecompilerUnit . GENDEC is the Generic decompilation pipeline, which can handle all types of code, native code, managed code, or else. GENDEC is more modular and open than DEXDEC. All native (x86, arm, etc.) as well as no-native (Ethereum, WebAssembly) decompiler plugins are built on GENDEC. How to Decompile # In the assembly view, position your caret on the area of code you would like to decompile. Hit the Tab key to decompile code (you can customize this, see the Keyboard Shortcuts section in the Settings page ) If a decompiler unit can be created for the current code unit, a new decompiled code unit will be created The decompiled code unit will receive focus and the caret positioned on the area of code that most closely corresponds to the low-level bytecode or machine code Decompiling with Options # Decompiling with Options is also offered in the Action menu. The default keyboard shortcut is MOD1+Tab. (On most platforms, MOD1 is the Control key; on macOS, it is the Command key.) When the current settings of your decompiler plugin are not exactly what you want to decompile a particular code item, use Decompile with Options to temporarily modify your settings. This action also allows users to force the re-decompilation of an already decompiled code item. (A clunkier alternative would be to find the corresponding decompiled unit node in the project Hierarchy, remove it, and then decompile again.) Back to the Assembly # Conversely, you can go back to the assembly from a decompiled view by using the Tab . Managing Views # By default, a view representing a portion of decompiled code (e.g., a class) will be replaced by the next class being decompiled. This default behavior is to avoid cluttering the workspace with tens of views representing various decompiled artifacts. However, if you would like to open every piece of decompiled code in a separate view, you may do so by checking the Navigation, do not replace Views menu option. Actions and Interactivity # Generally, when it comes to interactivity, decompilation plugins proxy requests to their corresponding parent code unit. That means that the actions set offered is essentially the same. The consistency between views is maintained.","title":"Decompiling"},{"location":"decompiling.html#decompilers","text":"JEB Pro ships with decompilers for: Dalvik (Android DEX files) Java (classfile) WebAssembly modules (wasm) Ethereum contracts (EVM code) Intel x86 32-bit (all x86 - x87/mmx/sse/avx support coming in JEB 4) Intel x86 64-bit (all x86 - x87/mmx/sse/avx support coming in JEB 4) ARM 32-bit (and common ISA extensions) ARM 64-bit (v8 / aarch64) MIPS 32-bit The following picture shows a child decompiler unit, as well as a suite of decompiled classes units.","title":"Decompilers"},{"location":"decompiling.html#internals","text":"Currently, JEB relies on two separate decompiler pipelines: DEXDEC is the DEX/Dalvik (as well as Java) decompiler. This decompiler works exclusively with Dalvik input. The primary interface to the reference implementation is IDexDecompilerUnit . GENDEC is the Generic decompilation pipeline, which can handle all types of code, native code, managed code, or else. GENDEC is more modular and open than DEXDEC. All native (x86, arm, etc.) as well as no-native (Ethereum, WebAssembly) decompiler plugins are built on GENDEC.","title":"Internals"},{"location":"decompiling.html#how-to-decompile","text":"In the assembly view, position your caret on the area of code you would like to decompile. Hit the Tab key to decompile code (you can customize this, see the Keyboard Shortcuts section in the Settings page ) If a decompiler unit can be created for the current code unit, a new decompiled code unit will be created The decompiled code unit will receive focus and the caret positioned on the area of code that most closely corresponds to the low-level bytecode or machine code","title":"How to Decompile"},{"location":"decompiling.html#decompiling-with-options","text":"Decompiling with Options is also offered in the Action menu. The default keyboard shortcut is MOD1+Tab. (On most platforms, MOD1 is the Control key; on macOS, it is the Command key.) When the current settings of your decompiler plugin are not exactly what you want to decompile a particular code item, use Decompile with Options to temporarily modify your settings. This action also allows users to force the re-decompilation of an already decompiled code item. (A clunkier alternative would be to find the corresponding decompiled unit node in the project Hierarchy, remove it, and then decompile again.)","title":"Decompiling with Options"},{"location":"decompiling.html#back-to-the-assembly","text":"Conversely, you can go back to the assembly from a decompiled view by using the Tab .","title":"Back to the Assembly"},{"location":"decompiling.html#managing-views","text":"By default, a view representing a portion of decompiled code (e.g., a class) will be replaced by the next class being decompiled. This default behavior is to avoid cluttering the workspace with tens of views representing various decompiled artifacts. However, if you would like to open every piece of decompiled code in a separate view, you may do so by checking the Navigation, do not replace Views menu option.","title":"Managing Views"},{"location":"decompiling.html#actions-and-interactivity","text":"Generally, when it comes to interactivity, decompilation plugins proxy requests to their corresponding parent code unit. That means that the actions set offered is essentially the same. The consistency between views is maintained.","title":"Actions and Interactivity"},{"location":"engines-configuration.html","text":"JEB clients store the JEB engines configuration , also known as the back-end configuration, in the bin/jeb-engines.cfg . The configuration file is a key-value store where keys are fully-qualified identifiers that start with a leading dot. This file contains general back-end settings as well as the settings of common plugins shipping with most distributions of JEB. Each plugin has its own sub-namespace ( .PluginType ) within the .parsers namespace. Keys pertaining to document rendering are stored in a sub-region named .text . The public keys can safely be changed by a user. They are accessible in the Options dialog, Advanced mode, panel Engines . The engines configuration acts as a template for your projects' settings. Once a project is loaded, an additional tab named Project-Specific allows the user to modify the back-end settings of the project only, without changing the global back-end settings. ) .DatabaseBackupBeforeSave # Description : Before saving a project to JDB2, the current JDB2 database is copied to the %TEMP% folder and will be used as backup is any problem showed up during saving. Type and Default : Boolean(true) .DevPluginClassnames # Description : Classnames of your in-development plugin entry-point classes (they are not JARs) Type and Default : String(\"\") .DevPluginClasspath # Description : Classpath for your in-development plugins (they are not JARs) Type and Default : String(\"\") .LoadPythonPlugins # Description : Specify whether or not JEB back-end plugins written in Python are allowed and should be loaded Type and Default : Boolean(true) .NetworkProxy # Description : Network proxy settings for JEB back-end components. The format of this property is: 'protocol|hostname|port|user|pass'. Protocol can be http or socks. User and password are optional (needed only if your proxy requires authentication) Type and Default : String(\"\") .PluginsFolder # Description : Location of the JEB back-end plugins folder Type and Default : String(\"$JEB_HOME/coreplugins\") .SiglibsAutoLoadPackages # Description : Specify whether or not signature libraries should be automatically loaded when target file is deemed suitable Type and Default : Boolean(true) .SiglibsAutoModeSaveCount # Description : Number of signatures that need to be created before saving to a signature package; if 0 the package is not saved by this manager Type and Default : Integer(10) .SiglibsFolder # Description : Folder containing native code signature libraries Type and Default : String(\"$JEB_HOME/siglibs\") .TypelibsFolder # Description : Folder containing native type libraries Type and Default : String(\"$JEB_HOME/typelibs\") .parsers.EnforceVersionChecks # Description : Verify that the plugins's requirements in terms for JEB are met. Ex: if enabled, a plugin requiring JEB [2.3.10, 3.0.7] will not be loaded if JEB is older than 2.3.10 or newer than 3.0.7 Type and Default : Boolean(true) .parsers.apk.AndroidJavadocRoot # Description : Location of Java/Android API documentation files; by default, local files stored in your Android SDK folder will be preferred over web-based API doc Type and Default : String(\"($ANDROID_HOME/docs|$ANDROID_SDK_HOME/docs|$ANDROID_SDK_ROOT/docs)/reference/;https://developer.android.com/reference/;($JAVA_HOME)/docs/api\") .parsers.apk.ArscRestructuringMode # Description : Restructuring mode for decoded resource files: either 0 (none), 1 (basic), 2 (moving to better folder), 3 (moving + renaming - the default) Type and Default : Integer(3) .parsers.apk.DisableAssetsProcessingThreshold # Description : The plugin will suggest disabling the auto-processing of APK assets if the number of asset files exceed that threshold (0 to disable) Type and Default : Integer(300){0+} .parsers.apk.DisableResourcesProcessingThreshold # Description : The plugin will suggest disabling the auto-processing of APK resources if the number of resource files exceed that threshold (0 to disable) Type and Default : Integer(500){0+} .parsers.apk.FrameworksDirectory # Description : Directory containing additional frameworks. Leave empty to use the default, which is the '.jeb-android-frameworks' directory in your Home folder Type and Default : Path(\"\") .parsers.apk.GenerateAapt2Output # Description : Tick to generate an additional text fragment that will describe the APK resources similarly to AAPT2's output Type and Default : Boolean(false) .parsers.apk.MergeMultiDex # Description : Attempt to merge the DEX files of a multi-DEX APK into a single, unified DEX unit Type and Default : Boolean(true) .parsers.apk.ProcessAssets # Description : Process files in the APK's Assets directory Type and Default : Boolean(true) .parsers.apk.ProcessBytecode # Description : Process the Dalvik bytecode (classes[N].dex) Type and Default : Boolean(true) .parsers.apk.ProcessCertificates # Description : Process the APK's certificates data (legacy, v1, and v2) Type and Default : Boolean(true) .parsers.apk.ProcessLibraries # Description : Process native code (.so) libraries Type and Default : Boolean(true) .parsers.apk.ProcessManifest # Description : Decode and process the APK Manifest Type and Default : Boolean(true) .parsers.apk.ProcessResources # Description : Decode and process the Resources (if this option is true, the Manifest is always processed) Type and Default : Boolean(true) .parsers.arm.AdvancedAnalysisRoutineCountWarning # Description : If the standard analysis yields more routines that this provided threshold, then the user will be prompted for confirmation before starting the optional advanced analysis pass (and subsequent passes). Type and Default : Integer(200){0+} .parsers.arm.AllowAdvancedAnalysis # Description : The advanced analysis is an optional analysis pass that comes after the initial standard analysis. It permits discovery of indirect dispatch, therefore providing better routine discovery coverage, and partial resolution of register values. Type and Default : Boolean(false) .parsers.arm.AnalysisStyle # Description : Native analysis style: 0 = forced conservative analysis 1 = automatic mode (depends on the file) 2 = forced aggressive analysis 3 = forced lazy analysis 4 = forced lazy no data analysis Type and Default : Integer(1){0-4} .parsers.arm.DebugInformationRetrievalPolicy # Description : Policy regarding the retrieval of externally-stored debugging and symbolic information of code objects: 0 = never attempt 1 = retrieve locally stored external symbols 2 = attempt to retrieve locally and network-stored symbols Locations are architecture- and code object- dependent and may be customized via environment variables. Refer to the manual for additional documentation. Type and Default : Integer(2){0-2} .parsers.arm.DebugInformationUsagePolicy # Description : Apply and use debug information to improve analysis accuracy (on a best-effort basis): 0 = never use debug information 1 = use internal debug information only 2 = use all available (internal and external) debug information Type and Default : Integer(1){0-2} .parsers.arm.IdentifiedCompiler # Description : Identified compiler: 0 = automatic identification (depends on the file) 1 = unknown compiler 2 = generic Linux compiler 3 = Android ART 4 = Android NDK 5 = generic Windows compiler 6 = Microsoft Visual C++ Type and Default : Integer(0){0-6} .parsers.arm.PerformClassRecovery # Description : Attempt C++ class discovery and rebuilding (limited to MSVC-compiled x86 executables for now) Type and Default : Boolean(false) .parsers.arm.PerformGlobalAnalysis # Description : Global analysis passes are optional passes provided by specific decompiler modules. They may allow recovery of complex artifacts, such as classes or modules. Type and Default : Boolean(false) .parsers.arm.PerformRttiRecovery # Description : Attempt C++ Run-Time Type Information (RTTI) discovery and rebuilding (MSVC and Itanium (GCC/CLANG/NDK) are supported) Type and Default : Boolean(true) .parsers.arm.PreferSynchronousExecution # Description : Synchronous analysis prevents access to the unit during a code analysis Type and Default : Boolean(false) .parsers.arm.TailCallAnalysisStyle # Description : Search for possible tail calls optimized as branches, and build proper routines. Possible modes: 0 = deactivated 1 = automatic mode (heuristics depend on the file) 2 = safe heuristics only 3 = aggressive heuristics Type and Default : Integer(1){0-3} .parsers.arm.WantedEndianness # Description : Desired endianness for raw binaries: 'little'/'le', 'big'/'be'. May be overridden by the code parser. Type and Default : String(\"le\") .parsers.arm.WantedImageBase # Description : Desired memory base address for raw binaries. 0 by default. Type and Default : String(\"0\") .parsers.arm.text.BlockXrefsCount # Description : Maximum number of cross-references displayed at any address Type and Default : Integer(50) .parsers.arm.text.CharBreak64BitAddresses # Description : If not empty, the address column will display 64-bit addresses as two 8-hexdigit parts, separated by the provided character string Type and Default : String(\"'\") .parsers.arm.text.GapPreferRawFormatting # Description : Prefer raw formatting (dr XX, dr XXXX) for gaps and slack spaces instead of regular declarations (eg, db ??) Type and Default : Boolean(false) .parsers.arm.text.GapRawBytesPerLine # Description : For raw formatting, determine the maximum number of bytes per line in gaps and slack spaces. Must be a power of 2, else reverts to the default. Type and Default : Integer(16){0+} .parsers.arm.text.GapRawIntegerSize # Description : For raw formatting, determine the integer length (in bytes) used for rendering. Must be either 1, 2, 4, or 8, else reverts to the default Type and Default : Integer(1){0+} .parsers.arm.text.InstructionAreaLength # Description : Length in characters of the assembly column containing the instructions Type and Default : Integer(40){0+} .parsers.arm.text.LabelAreaLength # Description : Length in characters of the assembly column containing the labels Type and Default : Integer(16){0+} .parsers.arm.text.RoutineSeparatorLength # Description : Number of characters used to build the line separating routines Type and Default : Integer(80){0+} .parsers.arm.text.ShowAddresses # Description : Display addresses of items Type and Default : Boolean(true) .parsers.arm.text.ShowBytesCount # Description : Maximum count of instruction bytes to be displayed before the instruction Type and Default : Integer(0){0+} .parsers.arm.text.ShowSegmentHeaders # Description : Display the segment or section headers Type and Default : Boolean(true) .parsers.arm.text.ShowSpaceBetweenBlocks # Description : Insert blank lines between basic blocks Type and Default : Boolean(false) .parsers.arm64.AdvancedAnalysisRoutineCountWarning # Description : If the standard analysis yields more routines that this provided threshold, then the user will be prompted for confirmation before starting the optional advanced analysis pass (and subsequent passes). Type and Default : Integer(200){0+} .parsers.arm64.AllowAdvancedAnalysis # Description : The advanced analysis is an optional analysis pass that comes after the initial standard analysis. It permits discovery of indirect dispatch, therefore providing better routine discovery coverage, and partial resolution of register values. Type and Default : Boolean(false) .parsers.arm64.AnalysisStyle # Description : Native analysis style: 0 = forced conservative analysis 1 = automatic mode (depends on the file) 2 = forced aggressive analysis 3 = forced lazy analysis 4 = forced lazy no data analysis Type and Default : Integer(1){0-4} .parsers.arm64.DebugInformationRetrievalPolicy # Description : Policy regarding the retrieval of externally-stored debugging and symbolic information of code objects: 0 = never attempt 1 = retrieve locally stored external symbols 2 = attempt to retrieve locally and network-stored symbols Locations are architecture- and code object- dependent and may be customized via environment variables. Refer to the manual for additional documentation. Type and Default : Integer(2){0-2} .parsers.arm64.DebugInformationUsagePolicy # Description : Apply and use debug information to improve analysis accuracy (on a best-effort basis): 0 = never use debug information 1 = use internal debug information only 2 = use all available (internal and external) debug information Type and Default : Integer(1){0-2} .parsers.arm64.IdentifiedCompiler # Description : Identified compiler: 0 = automatic identification (depends on the file) 1 = unknown compiler 2 = generic Linux compiler 3 = Android ART 4 = Android NDK 5 = generic Windows compiler 6 = Microsoft Visual C++ Type and Default : Integer(0){0-6} .parsers.arm64.PerformClassRecovery # Description : Attempt C++ class discovery and rebuilding (limited to MSVC-compiled x86 executables for now) Type and Default : Boolean(false) .parsers.arm64.PerformGlobalAnalysis # Description : Global analysis passes are optional passes provided by specific decompiler modules. They may allow recovery of complex artifacts, such as classes or modules. Type and Default : Boolean(false) .parsers.arm64.PerformRttiRecovery # Description : Attempt C++ Run-Time Type Information (RTTI) discovery and rebuilding (MSVC and Itanium (GCC/CLANG/NDK) are supported) Type and Default : Boolean(true) .parsers.arm64.PreferSynchronousExecution # Description : Synchronous analysis prevents access to the unit during a code analysis Type and Default : Boolean(false) .parsers.arm64.TailCallAnalysisStyle # Description : Search for possible tail calls optimized as branches, and build proper routines. Possible modes: 0 = deactivated 1 = automatic mode (heuristics depend on the file) 2 = safe heuristics only 3 = aggressive heuristics Type and Default : Integer(1){0-3} .parsers.arm64.WantedEndianness # Description : Desired endianness for raw binaries: 'little'/'le', 'big'/'be'. May be overridden by the code parser. Type and Default : String(\"le\") .parsers.arm64.WantedImageBase # Description : Desired memory base address for raw binaries. 0 by default. Type and Default : String(\"0\") .parsers.arm64.text.BlockXrefsCount # Description : Maximum number of cross-references displayed at any address Type and Default : Integer(50) .parsers.arm64.text.CharBreak64BitAddresses # Description : If not empty, the address column will display 64-bit addresses as two 8-hexdigit parts, separated by the provided character string Type and Default : String(\"'\") .parsers.arm64.text.GapPreferRawFormatting # Description : Prefer raw formatting (dr XX, dr XXXX) for gaps and slack spaces instead of regular declarations (eg, db ??) Type and Default : Boolean(false) .parsers.arm64.text.GapRawBytesPerLine # Description : For raw formatting, determine the maximum number of bytes per line in gaps and slack spaces. Must be a power of 2, else reverts to the default. Type and Default : Integer(16){0+} .parsers.arm64.text.GapRawIntegerSize # Description : For raw formatting, determine the integer length (in bytes) used for rendering. Must be either 1, 2, 4, or 8, else reverts to the default Type and Default : Integer(1){0+} .parsers.arm64.text.InstructionAreaLength # Description : Length in characters of the assembly column containing the instructions Type and Default : Integer(40){0+} .parsers.arm64.text.LabelAreaLength # Description : Length in characters of the assembly column containing the labels Type and Default : Integer(16){0+} .parsers.arm64.text.RoutineSeparatorLength # Description : Number of characters used to build the line separating routines Type and Default : Integer(80){0+} .parsers.arm64.text.ShowAddresses # Description : Display addresses of items Type and Default : Boolean(true) .parsers.arm64.text.ShowBytesCount # Description : Maximum count of instruction bytes to be displayed before the instruction Type and Default : Integer(0){0+} .parsers.arm64.text.ShowSegmentHeaders # Description : Display the segment or section headers Type and Default : Boolean(true) .parsers.arm64.text.ShowSpaceBetweenBlocks # Description : Insert blank lines between basic blocks Type and Default : Boolean(false) .parsers.armT32.AdvancedAnalysisRoutineCountWarning # Description : If the standard analysis yields more routines that this provided threshold, then the user will be prompted for confirmation before starting the optional advanced analysis pass (and subsequent passes). Type and Default : Integer(200){0+} .parsers.armT32.AllowAdvancedAnalysis # Description : The advanced analysis is an optional analysis pass that comes after the initial standard analysis. It permits discovery of indirect dispatch, therefore providing better routine discovery coverage, and partial resolution of register values. Type and Default : Boolean(false) .parsers.armT32.AnalysisStyle # Description : Native analysis style: 0 = forced conservative analysis 1 = automatic mode (depends on the file) 2 = forced aggressive analysis 3 = forced lazy analysis 4 = forced lazy no data analysis Type and Default : Integer(1){0-4} .parsers.armT32.DebugInformationRetrievalPolicy # Description : Policy regarding the retrieval of externally-stored debugging and symbolic information of code objects: 0 = never attempt 1 = retrieve locally stored external symbols 2 = attempt to retrieve locally and network-stored symbols Locations are architecture- and code object- dependent and may be customized via environment variables. Refer to the manual for additional documentation. Type and Default : Integer(2){0-2} .parsers.armT32.DebugInformationUsagePolicy # Description : Apply and use debug information to improve analysis accuracy (on a best-effort basis): 0 = never use debug information 1 = use internal debug information only 2 = use all available (internal and external) debug information Type and Default : Integer(1){0-2} .parsers.armT32.IdentifiedCompiler # Description : Identified compiler: 0 = automatic identification (depends on the file) 1 = unknown compiler 2 = generic Linux compiler 3 = Android ART 4 = Android NDK 5 = generic Windows compiler 6 = Microsoft Visual C++ Type and Default : Integer(0){0-6} .parsers.armT32.PerformClassRecovery # Description : Attempt C++ class discovery and rebuilding (limited to MSVC-compiled x86 executables for now) Type and Default : Boolean(false) .parsers.armT32.PerformGlobalAnalysis # Description : Global analysis passes are optional passes provided by specific decompiler modules. They may allow recovery of complex artifacts, such as classes or modules. Type and Default : Boolean(false) .parsers.armT32.PerformRttiRecovery # Description : Attempt C++ Run-Time Type Information (RTTI) discovery and rebuilding (MSVC and Itanium (GCC/CLANG/NDK) are supported) Type and Default : Boolean(true) .parsers.armT32.PreferSynchronousExecution # Description : Synchronous analysis prevents access to the unit during a code analysis Type and Default : Boolean(false) .parsers.armT32.TailCallAnalysisStyle # Description : Search for possible tail calls optimized as branches, and build proper routines. Possible modes: 0 = deactivated 1 = automatic mode (heuristics depend on the file) 2 = safe heuristics only 3 = aggressive heuristics Type and Default : Integer(1){0-3} .parsers.armT32.WantedEndianness # Description : Desired endianness for raw binaries: 'little'/'le', 'big'/'be'. May be overridden by the code parser. Type and Default : String(\"le\") .parsers.armT32.WantedImageBase # Description : Desired memory base address for raw binaries. 0 by default. Type and Default : String(\"0\") .parsers.armT32.text.BlockXrefsCount # Description : Maximum number of cross-references displayed at any address Type and Default : Integer(50) .parsers.armT32.text.CharBreak64BitAddresses # Description : If not empty, the address column will display 64-bit addresses as two 8-hexdigit parts, separated by the provided character string Type and Default : String(\"'\") .parsers.armT32.text.GapPreferRawFormatting # Description : Prefer raw formatting (dr XX, dr XXXX) for gaps and slack spaces instead of regular declarations (eg, db ??) Type and Default : Boolean(false) .parsers.armT32.text.GapRawBytesPerLine # Description : For raw formatting, determine the maximum number of bytes per line in gaps and slack spaces. Must be a power of 2, else reverts to the default. Type and Default : Integer(16){0+} .parsers.armT32.text.GapRawIntegerSize # Description : For raw formatting, determine the integer length (in bytes) used for rendering. Must be either 1, 2, 4, or 8, else reverts to the default Type and Default : Integer(1){0+} .parsers.armT32.text.InstructionAreaLength # Description : Length in characters of the assembly column containing the instructions Type and Default : Integer(40){0+} .parsers.armT32.text.LabelAreaLength # Description : Length in characters of the assembly column containing the labels Type and Default : Integer(16){0+} .parsers.armT32.text.RoutineSeparatorLength # Description : Number of characters used to build the line separating routines Type and Default : Integer(80){0+} .parsers.armT32.text.ShowAddresses # Description : Display addresses of items Type and Default : Boolean(true) .parsers.armT32.text.ShowBytesCount # Description : Maximum count of instruction bytes to be displayed before the instruction Type and Default : Integer(0){0+} .parsers.armT32.text.ShowSegmentHeaders # Description : Display the segment or section headers Type and Default : Boolean(true) .parsers.armT32.text.ShowSpaceBetweenBlocks # Description : Insert blank lines between basic blocks Type and Default : Boolean(false) .parsers.avr.AdvancedAnalysisRoutineCountWarning # Description : If the standard analysis yields more routines that this provided threshold, then the user will be prompted for confirmation before starting the optional advanced analysis pass (and subsequent passes). Type and Default : Integer(200){0+} .parsers.avr.AllowAdvancedAnalysis # Description : The advanced analysis is an optional analysis pass that comes after the initial standard analysis. It permits discovery of indirect dispatch, therefore providing better routine discovery coverage, and partial resolution of register values. Type and Default : Boolean(false) .parsers.avr.AnalysisStyle # Description : Native analysis style: 0 = forced conservative analysis 1 = automatic mode (depends on the file) 2 = forced aggressive analysis 3 = forced lazy analysis 4 = forced lazy no data analysis Type and Default : Integer(1){0-4} .parsers.avr.DebugInformationRetrievalPolicy # Description : Policy regarding the retrieval of externally-stored debugging and symbolic information of code objects: 0 = never attempt 1 = retrieve locally stored external symbols 2 = attempt to retrieve locally and network-stored symbols Locations are architecture- and code object- dependent and may be customized via environment variables. Refer to the manual for additional documentation. Type and Default : Integer(2){0-2} .parsers.avr.DebugInformationUsagePolicy # Description : Apply and use debug information to improve analysis accuracy (on a best-effort basis): 0 = never use debug information 1 = use internal debug information only 2 = use all available (internal and external) debug information Type and Default : Integer(1){0-2} .parsers.avr.IdentifiedCompiler # Description : Identified compiler: 0 = automatic identification (depends on the file) 1 = unknown compiler 2 = generic Linux compiler 3 = Android ART 4 = Android NDK 5 = generic Windows compiler 6 = Microsoft Visual C++ Type and Default : Integer(0){0-6} .parsers.avr.PerformClassRecovery # Description : Attempt C++ class discovery and rebuilding (limited to MSVC-compiled x86 executables for now) Type and Default : Boolean(false) .parsers.avr.PerformGlobalAnalysis # Description : Global analysis passes are optional passes provided by specific decompiler modules. They may allow recovery of complex artifacts, such as classes or modules. Type and Default : Boolean(false) .parsers.avr.PerformRttiRecovery # Description : Attempt C++ Run-Time Type Information (RTTI) discovery and rebuilding (MSVC and Itanium (GCC/CLANG/NDK) are supported) Type and Default : Boolean(true) .parsers.avr.PreferSynchronousExecution # Description : Synchronous analysis prevents access to the unit during a code analysis Type and Default : Boolean(false) .parsers.avr.TailCallAnalysisStyle # Description : Search for possible tail calls optimized as branches, and build proper routines. Possible modes: 0 = deactivated 1 = automatic mode (heuristics depend on the file) 2 = safe heuristics only 3 = aggressive heuristics Type and Default : Integer(1){0-3} .parsers.avr.WantedEndianness # Description : Desired endianness for raw binaries: 'little'/'le', 'big'/'be'. May be overridden by the code parser. Type and Default : String(\"le\") .parsers.avr.WantedImageBase # Description : Desired memory base address for raw binaries. 0 by default. Type and Default : String(\"0\") .parsers.avr.text.BlockXrefsCount # Description : Maximum number of cross-references displayed at any address Type and Default : Integer(50) .parsers.avr.text.CharBreak64BitAddresses # Description : If not empty, the address column will display 64-bit addresses as two 8-hexdigit parts, separated by the provided character string Type and Default : String(\"'\") .parsers.avr.text.GapPreferRawFormatting # Description : Prefer raw formatting (dr XX, dr XXXX) for gaps and slack spaces instead of regular declarations (eg, db ??) Type and Default : Boolean(false) .parsers.avr.text.GapRawBytesPerLine # Description : For raw formatting, determine the maximum number of bytes per line in gaps and slack spaces. Must be a power of 2, else reverts to the default. Type and Default : Integer(16){0+} .parsers.avr.text.GapRawIntegerSize # Description : For raw formatting, determine the integer length (in bytes) used for rendering. Must be either 1, 2, 4, or 8, else reverts to the default Type and Default : Integer(1){0+} .parsers.avr.text.InstructionAreaLength # Description : Length in characters of the assembly column containing the instructions Type and Default : Integer(40){0+} .parsers.avr.text.LabelAreaLength # Description : Length in characters of the assembly column containing the labels Type and Default : Integer(16){0+} .parsers.avr.text.RoutineSeparatorLength # Description : Number of characters used to build the line separating routines Type and Default : Integer(80){0+} .parsers.avr.text.ShowAddresses # Description : Display addresses of items Type and Default : Boolean(true) .parsers.avr.text.ShowBytesCount # Description : Maximum count of instruction bytes to be displayed before the instruction Type and Default : Integer(0){0+} .parsers.avr.text.ShowSegmentHeaders # Description : Display the segment or section headers Type and Default : Boolean(true) .parsers.avr.text.ShowSpaceBetweenBlocks # Description : Insert blank lines between basic blocks Type and Default : Boolean(false) .parsers.dbug_apk.AttachPortRangeSize # Description : Number of ports to try after the preferred port if the preferred port is in useby another program Type and Default : Integer(20){1-100} .parsers.dbug_apk.AttachPortRangeStart # Description : Preferred TCP port to use and listen to when attaching to the JDWP debugger Type and Default : Integer(8900){1024-65535} .parsers.dbug_apk.BlockingQueryTimeoutSeconds # Description : Maximum time in seconds to wait for a response from the debugger server Type and Default : Integer(15){0+} .parsers.dbug_apk.NativeAttachPortRangeSize # Description : Number of ports to try after the preferred port if the preferred port is in useby another program Type and Default : Integer(20){1-100} .parsers.dbug_apk.NativeAttachPortRangeStart # Description : Preferred TCP port to use and listen to when attaching to the native debugger Type and Default : Integer(8950){1024-65535} .parsers.dbug_apk.PreferLldbserver # Description : Prefer the use of LLDB server over GDB server for debugging native Android code. Type and Default : Boolean(true) .parsers.dbug_apk.PreferredGdbserverVersion # Description : Preferred GDB server version to use. JEB does not ship with all versions of GDB server for all platforms. See the core/assets/ folder in your jeb.jar software archive.It is recommended to use the default. Type and Default : String(\"\") .parsers.dbug_apk.PreferredLldbserverVersion # Description : Preferred LLDB server version to use. JEB does not ship with all versions of LLDB server for all platforms. See the core/assets/ folder in your jeb.jar software archive.It is recommended to use the default. Type and Default : String(\"\") .parsers.dbug_apk.UseNativeDebugger # Description : If the client does not provide this information, this setting is used to determine whether the native debugger should be used as well. Use AUTO to let JEB choose (which will result in a yes if and only if a native library folder containing SO files exist), else use ALWAYS or NEVER. Type and Default : String(\"NEVER\") .parsers.dbug_elf.BlockingQueryTimeoutSeconds # Description : Maximum time in seconds to wait for a response from the debugger server Type and Default : Integer(15){0+} .parsers.dcmp_arm.ASTOptimizerMaxRunCount # Description : Determine how many passes the AST optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(20) .parsers.dcmp_arm.FailOnPipelineError # Description : Determine whether or not an exception should be thrown on decompilation error. If not, the error will be visible as a comment in the decompiled code output Type and Default : Boolean(true) .parsers.dcmp_arm.IROptimizerDisableAggressivePass # Description : Disable aggressive IR optimization pass, normally scheduled to run in later IR lifting stages. This pass is used to remove unused out-reaching variables. Type and Default : Boolean(false) .parsers.dcmp_arm.IROptimizerMaxRunCount # Description : Determine how many passes the IR optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(5) .parsers.dcmp_arm.MemoryResolutionPolicy # Description : A resolution policy guides the memory resolver in terms of what memory dereferences can be directly resolved. Supported policy values are: 0: forbidden (no resolution allowed) 1: allowed if reading takes place in read-only area, and points to a defined item 2: #1 + allowed if reading takes place from \"special\" code object areas (eg, ELF's global offset table) and points to a defined item 3: #1 + allowed if reading takes place from \"special\" code object areas (eg, ELF's global offset table) 100: allowed from any area and points to a defined item 200: allowed from any area Type and Default : Integer(2) .parsers.dcmp_arm.ReconversionMaxCount # Description : Maximum decompilation pipeline restart (reconversion) allowed for a routine Type and Default : Integer(2){0+} .parsers.dcmp_arm.StructurerUseVersion # Description : Version of the structurer to use (0 means use the default structuring algorithms - in release mode, default=newest) Type and Default : Integer(2){0-3} .parsers.dcmp_arm.UseFriendlyVariableNames # Description : Let the AST generate friendly identifier names (eg, based on types) instead of generic names Type and Default : Boolean(true) .parsers.dcmp_arm.UseSSAForm # Description : Let the decompiler convert intermediate form CFG to SSA forms Type and Default : Boolean(false) .parsers.dcmp_arm.text.MergeAdjacentDefinitions # Description : Merge same type definitions on a single line (eg, int i = 0, j = 1;) Type and Default : Boolean(true) .parsers.dcmp_arm.text.SpaceOutCompounds # Description : Insert blank lines between compounds Type and Default : Boolean(true) .parsers.dcmp_arm64.ASTOptimizerMaxRunCount # Description : Determine how many passes the AST optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(20) .parsers.dcmp_arm64.FailOnPipelineError # Description : Determine whether or not an exception should be thrown on decompilation error. If not, the error will be visible as a comment in the decompiled code output Type and Default : Boolean(true) .parsers.dcmp_arm64.IROptimizerDisableAggressivePass # Description : Disable aggressive IR optimization pass, normally scheduled to run in later IR lifting stages. This pass is used to remove unused out-reaching variables. Type and Default : Boolean(false) .parsers.dcmp_arm64.IROptimizerMaxRunCount # Description : Determine how many passes the IR optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(5) .parsers.dcmp_arm64.MemoryResolutionPolicy # Description : A resolution policy guides the memory resolver in terms of what memory dereferences can be directly resolved. Supported policy values are: 0: forbidden (no resolution allowed) 1: allowed if reading takes place in read-only area, and points to a defined item 2: #1 + allowed if reading takes place from \"special\" code object areas (eg, ELF's global offset table) and points to a defined item 3: #1 + allowed if reading takes place from \"special\" code object areas (eg, ELF's global offset table) 100: allowed from any area and points to a defined item 200: allowed from any area Type and Default : Integer(2) .parsers.dcmp_arm64.ReconversionMaxCount # Description : Maximum decompilation pipeline restart (reconversion) allowed for a routine Type and Default : Integer(2){0+} .parsers.dcmp_arm64.StructurerUseVersion # Description : Version of the structurer to use (0 means use the default structuring algorithms - in release mode, default=newest) Type and Default : Integer(2){0-3} .parsers.dcmp_arm64.UseFriendlyVariableNames # Description : Let the AST generate friendly identifier names (eg, based on types) instead of generic names Type and Default : Boolean(true) .parsers.dcmp_arm64.UseSSAForm # Description : Let the decompiler convert intermediate form CFG to SSA forms Type and Default : Boolean(false) .parsers.dcmp_arm64.text.MergeAdjacentDefinitions # Description : Merge same type definitions on a single line (eg, int i = 0, j = 1;) Type and Default : Boolean(true) .parsers.dcmp_arm64.text.SpaceOutCompounds # Description : Insert blank lines between compounds Type and Default : Boolean(true) .parsers.dcmp_avr.ASTOptimizerMaxRunCount # Description : Determine how many passes the AST optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(20) .parsers.dcmp_avr.FailOnPipelineError # Description : Determine whether or not an exception should be thrown on decompilation error. If not, the error will be visible as a comment in the decompiled code output Type and Default : Boolean(true) .parsers.dcmp_avr.IROptimizerDisableAggressivePass # Description : Disable aggressive IR optimization pass, normally scheduled to run in later IR lifting stages. This pass is used to remove unused out-reaching variables. Type and Default : Boolean(false) .parsers.dcmp_avr.IROptimizerMaxRunCount # Description : Determine how many passes the IR optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(5) .parsers.dcmp_avr.MemoryResolutionPolicy # Description : A resolution policy guides the memory resolver in terms of what memory dereferences can be directly resolved. Supported policy values are: 0: forbidden (no resolution allowed) 1: allowed if reading takes place in read-only area, and points to a defined item 2: #1 + allowed if reading takes place from \"special\" code object areas (eg, ELF's global offset table) and points to a defined item 3: #1 + allowed if reading takes place from \"special\" code object areas (eg, ELF's global offset table) 100: allowed from any area and points to a defined item 200: allowed from any area Type and Default : Integer(2) .parsers.dcmp_avr.ReconversionMaxCount # Description : Maximum decompilation pipeline restart (reconversion) allowed for a routine Type and Default : Integer(2){0+} .parsers.dcmp_avr.StructurerUseVersion # Description : Version of the structurer to use (0 means use the default structuring algorithms - in release mode, default=newest) Type and Default : Integer(2){0-3} .parsers.dcmp_avr.UseFriendlyVariableNames # Description : Let the AST generate friendly identifier names (eg, based on types) instead of generic names Type and Default : Boolean(true) .parsers.dcmp_avr.UseSSAForm # Description : Let the decompiler convert intermediate form CFG to SSA forms Type and Default : Boolean(false) .parsers.dcmp_avr.text.MergeAdjacentDefinitions # Description : Merge same type definitions on a single line (eg, int i = 0, j = 1;) Type and Default : Boolean(true) .parsers.dcmp_avr.text.SpaceOutCompounds # Description : Insert blank lines between compounds Type and Default : Boolean(true) .parsers.dcmp_dex.AggressiveSubstitutions # Description : IR optimization: Allow aggressive (potentially unsafe) substitutions Type and Default : Boolean(true) .parsers.dcmp_dex.EmulationSupport # Description : Support for emulation, allowing optimizers to perform complex code cleaning such as decryption: 0: disabled 1: enabled, notify the client to proceed 2: enabled, always proceed Type and Default : Integer(2) .parsers.dcmp_dex.EmulatorConfigPath # Description : Path to the emulator configuration file. If the path is relative, the configuration file will be searched in JEB's plugins directory (usually, coreplugins/). Type and Default : Path(\"dexdec-emu.cfg\") .parsers.dcmp_dex.EnableDeobfuscators # Description : Enable unsafe deobfuscation optimizers. Those aggressive optimizers can generate code radically different than the underlying bytecode. Type and Default : Boolean(true) .parsers.dcmp_dex.FullCFGSubstitutionsInsnCountThreshold # Description : Experimental IR optimization: Allow full-CFG expression propagation for methods having less than threshold instructions (-1 to disable the threshold and enable for all methods regardless of their size) Type and Default : Integer(100) .parsers.dcmp_dex.IdentifierNamingStrategy # Description : Naming strategy for the identifiers: 0= reflect underlying register usage as much as possible: argN, vN, vN_x 1= derive names from types Type and Default : Integer(0) .parsers.dcmp_dex.JarLibraryClasspath # Description : A classpath containing Java classfiles to be used to support the decompiler. Refer to JarLibraryEnabled. If non-empty, this classpath takes precedence over JarLibraryFolder. Type and Default : String(\"\") .parsers.dcmp_dex.JarLibraryEnabled # Description : Enable external Java library file parsing. They can be used by the decompiler to achieve better typing (cast reduction). To activate, enable this property and set either one of JarLibraryClasspath or JarLibraryFolder property. Type and Default : Boolean(true) .parsers.dcmp_dex.JarLibraryFolder # Description : A folder containing Jar library files to be used to support the decompiler. Refer to JarLibraryEnabled. The default value (empty) means to use the folder ~/.jeb-android-libraries, which always contains a recent copy of the Android framework (android.jar). You may change the value to point to another folder, or drop additional jars in this folder.Note that JarLibraryClasspath takes precedence over this value. Type and Default : String(\"\") .parsers.dcmp_dex.MethodDecompilationTimeout # Description : Maximum time in seconds allowed for a method decompilation (use 0 to specify no time-out) Type and Default : Integer(0){0+} .parsers.dcmp_dex.OptimizeCreateConditionalAssignments # Description : AST optimization: allow condition assignments (using the ternary operator) Type and Default : Boolean(true) .parsers.dcmp_dex.OptimizeCreateFinallyBlocks # Description : AST optimization: attempt to create try-(catch,multi-catch)-finally blocks. This heuristic is potentially unsafe. Type and Default : Boolean(true) .parsers.dcmp_dex.OptimizeCreateForLoops # Description : AST optimization: Allow the creation of for-loops Type and Default : Boolean(true) .parsers.dcmp_dex.OptimizeCreateMultiDimArrays # Description : AST optimization: allow the creation of multi-dimensional arrays Type and Default : Boolean(true) .parsers.dcmp_dex.OptimizeCreateStringSwitches # Description : AST optimization: attempt to create switch-on-strings. This heuristic is potentially unsafe. Type and Default : Boolean(true) .parsers.dcmp_dex.OptimizeCreateSynchronizedBlocks # Description : AST optimization: attempt to create synchronized blocks. This heuristic is potentially unsafe. Type and Default : Boolean(true) .parsers.dcmp_dex.OptimizeCreateVarArgs # Description : AST optimization: support the creation of variable-argument methods Type and Default : Boolean(true) .parsers.dcmp_dex.OptimizeInlineSyntheticAccessCalls # Description : AST optimization: Inline calls to accessor (synthetic) methods Type and Default : Boolean(true) .parsers.dcmp_dex.OptimizeStringConcatenation # Description : AST optimization: Allow String concatenation Type and Default : Boolean(true) .parsers.dcmp_dex.ParseDebugInformation # Description : Process debug information. If enabled, debug names can be used to name identifiers. Proceed with caution! DEX metadata is not reliable, it can be forged and/or obfuscated to mislead analysis. Type and Default : Boolean(true) .parsers.dcmp_dex.ParseExceptionBlocks # Description : Parse exception blocks Type and Default : Boolean(true) .parsers.dcmp_dex.ReconstructEnums # Description : Discover and rebuild enumerations (and related artifacts such as enumeration-maps). This heuristic is potentially unsafe. Type and Default : Boolean(true) .parsers.dcmp_dex.ReconstructLambdas # Description : Discover and rebuild lambdas (and related higher-order artifacts such as method handles). This heuristic is potentially unsafe. Type and Default : Boolean(true) .parsers.dcmp_dex.text.DisplayMethodInternalsAsComment # Description : When rendering source, prepend method internals as a comment block before rendering the method (0: none, 1: original method signature, 2: signature + flattened AST rendering) Type and Default : Integer(0) .parsers.dcmp_dex.text.DisplayPrivateMethodsLast # Description : Output private methods last (after public, default and protected methods) Type and Default : Boolean(false) .parsers.dcmp_dex.text.GenerateAnnotations # Description : Generate Java annotations Type and Default : Boolean(true) .parsers.dcmp_dex.text.GenerateLambdas # Description : Favor the generation of lambda functions (Java 8+) if possible. Lambdas must have been reconstructed (engines option) Type and Default : Boolean(true) .parsers.dcmp_dex.text.GenerateOverrideAnnotations # Description : Geneate additional @Override annotations for methods for which super implementations or definitions were found Type and Default : Boolean(true) .parsers.dcmp_dex.text.GenerateSyntheticFields # Description : Explicitly generate synthetic fields Type and Default : Boolean(false) .parsers.dcmp_dex.text.GenerateSyntheticMethods # Description : Explicitly generate synthetic methods Type and Default : Boolean(false) .parsers.dcmp_dex.text.InsertBlankLinesAfterCompounds # Description : Insert blank lines between compounds Type and Default : Boolean(true) .parsers.dcmp_dex.text.ResolveFieldAccessTargets # Description : Resolve accesses to object and class fields Type and Default : Boolean(true) .parsers.dcmp_dex.text.ResolveMethodCallTargets # Description : Resolve calls to virtual and static methods, possibly offering a list of candidates methods to client code Type and Default : Boolean(true) .parsers.dcmp_dex.text.SortItemsForRendering # Description : Sort class, field and method source items before rendering them (0: no sort (rendered as they appear in native code), 1: alphabetically + access type) Type and Default : Integer(1) .parsers.dcmp_dex.text.UseDebugInfoNames # Description : Use names located in DEX debug information (if available) Type and Default : Boolean(true) .parsers.dcmp_evmbc.ASTOptimizerMaxRunCount # Description : Determine how many passes the AST optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(20) .parsers.dcmp_evmbc.FailOnPipelineError # Description : Determine whether or not an exception should be thrown on decompilation error. If not, the error will be visible as a comment in the decompiled code output Type and Default : Boolean(true) .parsers.dcmp_evmbc.IROptimizerDisableAggressivePass # Description : Disable aggressive IR optimization pass, normally scheduled to run in later IR lifting stages. This pass is used to remove unused out-reaching variables. Type and Default : Boolean(false) .parsers.dcmp_evmbc.IROptimizerMaxRunCount # Description : Determine how many passes the IR optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(5) .parsers.dcmp_evmbc.MemoryResolutionPolicy # Description : A resolution policy guides the memory resolver in terms of what memory dereferences can be directly resolved. Supported policy values are: 0: forbidden (no resolution allowed) 1: allowed if reading takes place in read-only area, and points to a defined item 2: #1 + allowed if reading takes place from \"special\" code object areas (eg, ELF's global offset table) and points to a defined item 3: #1 + allowed if reading takes place from \"special\" code object areas (eg, ELF's global offset table) 100: allowed from any area and points to a defined item 200: allowed from any area Type and Default : Integer(2) .parsers.dcmp_evmbc.ReconversionMaxCount # Description : Maximum decompilation pipeline restart (reconversion) allowed for a routine Type and Default : Integer(2){0+} .parsers.dcmp_evmbc.StructurerUseVersion # Description : Version of the structurer to use (0 means use the default structuring algorithms - in release mode, default=newest) Type and Default : Integer(2){0-3} .parsers.dcmp_evmbc.UseFriendlyVariableNames # Description : Let the AST generate friendly identifier names (eg, based on types) instead of generic names Type and Default : Boolean(false) .parsers.dcmp_evmbc.UseSSAForm # Description : Let the decompiler convert intermediate form CFG to SSA forms Type and Default : Boolean(false) .parsers.dcmp_evmbc.text.MergeAdjacentDefinitions # Description : Merge same type definitions on a single line (eg, int i = 0, j = 1;) Type and Default : Boolean(true) .parsers.dcmp_evmbc.text.SpaceOutCompounds # Description : Insert blank lines between compounds Type and Default : Boolean(true) .parsers.dcmp_libravm_bc.ASTOptimizerMaxRunCount # Description : Determine how many passes the AST optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(20) .parsers.dcmp_libravm_bc.FailOnPipelineError # Description : Determine whether or not an exception should be thrown on decompilation error. If not, the error will be visible as a comment in the decompiled code output Type and Default : Boolean(true) .parsers.dcmp_libravm_bc.IROptimizerDisableAggressivePass # Description : Disable aggressive IR optimization pass, normally scheduled to run in later IR lifting stages. This pass is used to remove unused out-reaching variables. Type and Default : Boolean(false) .parsers.dcmp_libravm_bc.IROptimizerMaxRunCount # Description : Determine how many passes the IR optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(5) .parsers.dcmp_libravm_bc.MemoryResolutionPolicy # Description : A resolution policy guides the memory resolver in terms of what memory dereferences can be directly resolved. Supported policy values are: 0: forbidden (no resolution allowed) 1: allowed if reading takes place in read-only area, and points to a defined item 2: #1 + allowed if reading takes place from \"special\" code object areas (eg, ELF's global offset table) and points to a defined item 3: #1 + allowed if reading takes place from \"special\" code object areas (eg, ELF's global offset table) 100: allowed from any area and points to a defined item 200: allowed from any area Type and Default : Integer(2) .parsers.dcmp_libravm_bc.ReconversionMaxCount # Description : Maximum decompilation pipeline restart (reconversion) allowed for a routine Type and Default : Integer(2){0+} .parsers.dcmp_libravm_bc.StructurerUseVersion # Description : Version of the structurer to use (0 means use the default structuring algorithms - in release mode, default=newest) Type and Default : Integer(2){0-3} .parsers.dcmp_libravm_bc.UseFriendlyVariableNames # Description : Let the AST generate friendly identifier names (eg, based on types) instead of generic names Type and Default : Boolean(false) .parsers.dcmp_libravm_bc.UseSSAForm # Description : Let the decompiler convert intermediate form CFG to SSA forms Type and Default : Boolean(false) .parsers.dcmp_libravm_bc.text.MergeAdjacentDefinitions # Description : Merge same type definitions on a single line (eg, int i = 0, j = 1;) Type and Default : Boolean(true) .parsers.dcmp_libravm_bc.text.SpaceOutCompounds # Description : Insert blank lines between compounds Type and Default : Boolean(true) .parsers.dcmp_mips.ASTOptimizerMaxRunCount # Description : Determine how many passes the AST optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(20) .parsers.dcmp_mips.FailOnPipelineError # Description : Determine whether or not an exception should be thrown on decompilation error. If not, the error will be visible as a comment in the decompiled code output Type and Default : Boolean(true) .parsers.dcmp_mips.IROptimizerDisableAggressivePass # Description : Disable aggressive IR optimization pass, normally scheduled to run in later IR lifting stages. This pass is used to remove unused out-reaching variables. Type and Default : Boolean(false) .parsers.dcmp_mips.IROptimizerMaxRunCount # Description : Determine how many passes the IR optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(5) .parsers.dcmp_mips.MemoryResolutionPolicy # Description : A resolution policy guides the memory resolver in terms of what memory dereferences can be directly resolved. Supported policy values are: 0: forbidden (no resolution allowed) 1: allowed if reading takes place in read-only area, and points to a defined item 2: #1 + allowed if reading takes place from \"special\" code object areas (eg, ELF's global offset table) and points to a defined item 3: #1 + allowed if reading takes place from \"special\" code object areas (eg, ELF's global offset table) 100: allowed from any area and points to a defined item 200: allowed from any area Type and Default : Integer(2) .parsers.dcmp_mips.ReconversionMaxCount # Description : Maximum decompilation pipeline restart (reconversion) allowed for a routine Type and Default : Integer(2){0+} .parsers.dcmp_mips.StructurerUseVersion # Description : Version of the structurer to use (0 means use the default structuring algorithms - in release mode, default=newest) Type and Default : Integer(2){0-3} .parsers.dcmp_mips.UseFriendlyVariableNames # Description : Let the AST generate friendly identifier names (eg, based on types) instead of generic names Type and Default : Boolean(true) .parsers.dcmp_mips.UseSSAForm # Description : Let the decompiler convert intermediate form CFG to SSA forms Type and Default : Boolean(false) .parsers.dcmp_mips.text.MergeAdjacentDefinitions # Description : Merge same type definitions on a single line (eg, int i = 0, j = 1;) Type and Default : Boolean(true) .parsers.dcmp_mips.text.SpaceOutCompounds # Description : Insert blank lines between compounds Type and Default : Boolean(true) .parsers.dcmp_mips64.ASTOptimizerMaxRunCount # Description : Determine how many passes the AST optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(20) .parsers.dcmp_mips64.FailOnPipelineError # Description : Determine whether or not an exception should be thrown on decompilation error. If not, the error will be visible as a comment in the decompiled code output Type and Default : Boolean(true) .parsers.dcmp_mips64.IROptimizerDisableAggressivePass # Description : Disable aggressive IR optimization pass, normally scheduled to run in later IR lifting stages. This pass is used to remove unused out-reaching variables. Type and Default : Boolean(false) .parsers.dcmp_mips64.IROptimizerMaxRunCount # Description : Determine how many passes the IR optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(5) .parsers.dcmp_mips64.MemoryResolutionPolicy # Description : A resolution policy guides the memory resolver in terms of what memory dereferences can be directly resolved. Supported policy values are: 0: forbidden (no resolution allowed) 1: allowed if reading takes place in read-only area, and points to a defined item 2: #1 + allowed if reading takes place from \"special\" code object areas (eg, ELF's global offset table) and points to a defined item 3: #1 + allowed if reading takes place from \"special\" code object areas (eg, ELF's global offset table) 100: allowed from any area and points to a defined item 200: allowed from any area Type and Default : Integer(2) .parsers.dcmp_mips64.ReconversionMaxCount # Description : Maximum decompilation pipeline restart (reconversion) allowed for a routine Type and Default : Integer(2){0+} .parsers.dcmp_mips64.StructurerUseVersion # Description : Version of the structurer to use (0 means use the default structuring algorithms - in release mode, default=newest) Type and Default : Integer(2){0-3} .parsers.dcmp_mips64.UseFriendlyVariableNames # Description : Let the AST generate friendly identifier names (eg, based on types) instead of generic names Type and Default : Boolean(true) .parsers.dcmp_mips64.UseSSAForm # Description : Let the decompiler convert intermediate form CFG to SSA forms Type and Default : Boolean(false) .parsers.dcmp_mips64.text.MergeAdjacentDefinitions # Description : Merge same type definitions on a single line (eg, int i = 0, j = 1;) Type and Default : Boolean(true) .parsers.dcmp_mips64.text.SpaceOutCompounds # Description : Insert blank lines between compounds Type and Default : Boolean(true) .parsers.dcmp_wasmbc.ASTOptimizerMaxRunCount # Description : Determine how many passes the AST optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(20) .parsers.dcmp_wasmbc.FailOnPipelineError # Description : Determine whether or not an exception should be thrown on decompilation error. If not, the error will be visible as a comment in the decompiled code output Type and Default : Boolean(true) .parsers.dcmp_wasmbc.IROptimizerDisableAggressivePass # Description : Disable aggressive IR optimization pass, normally scheduled to run in later IR lifting stages. This pass is used to remove unused out-reaching variables. Type and Default : Boolean(false) .parsers.dcmp_wasmbc.IROptimizerMaxRunCount # Description : Determine how many passes the IR optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(5) .parsers.dcmp_wasmbc.MemoryResolutionPolicy # Description : A resolution policy guides the memory resolver in terms of what memory dereferences can be directly resolved. Supported policy values are: 0: forbidden (no resolution allowed) 1: allowed if reading takes place in read-only area, and points to a defined item 2: #1 + allowed if reading takes place from \"special\" code object areas (eg, ELF's global offset table) and points to a defined item 3: #1 + allowed if reading takes place from \"special\" code object areas (eg, ELF's global offset table) 100: allowed from any area and points to a defined item 200: allowed from any area Type and Default : Integer(2) .parsers.dcmp_wasmbc.ReconversionMaxCount # Description : Maximum decompilation pipeline restart (reconversion) allowed for a routine Type and Default : Integer(2){0+} .parsers.dcmp_wasmbc.StructurerUseVersion # Description : Version of the structurer to use (0 means use the default structuring algorithms - in release mode, default=newest) Type and Default : Integer(2){0-3} .parsers.dcmp_wasmbc.UseFriendlyVariableNames # Description : Let the AST generate friendly identifier names (eg, based on types) instead of generic names Type and Default : Boolean(true) .parsers.dcmp_wasmbc.UseSSAForm # Description : Let the decompiler convert intermediate form CFG to SSA forms Type and Default : Boolean(false) .parsers.dcmp_wasmbc.text.MergeAdjacentDefinitions # Description : Merge same type definitions on a single line (eg, int i = 0, j = 1;) Type and Default : Boolean(true) .parsers.dcmp_wasmbc.text.SpaceOutCompounds # Description : Insert blank lines between compounds Type and Default : Boolean(true) .parsers.dcmp_x86.ASTOptimizerMaxRunCount # Description : Determine how many passes the AST optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(20) .parsers.dcmp_x86.FailOnPipelineError # Description : Determine whether or not an exception should be thrown on decompilation error. If not, the error will be visible as a comment in the decompiled code output Type and Default : Boolean(true) .parsers.dcmp_x86.IROptimizerDisableAggressivePass # Description : Disable aggressive IR optimization pass, normally scheduled to run in later IR lifting stages. This pass is used to remove unused out-reaching variables. Type and Default : Boolean(false) .parsers.dcmp_x86.IROptimizerMaxRunCount # Description : Determine how many passes the IR optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(5) .parsers.dcmp_x86.MemoryResolutionPolicy # Description : A resolution policy guides the memory resolver in terms of what memory dereferences can be directly resolved. Supported policy values are: 0: forbidden (no resolution allowed) 1: allowed if reading takes place in read-only area, and points to a defined item 2: #1 + allowed if reading takes place from \"special\" code object areas (eg, ELF's global offset table) and points to a defined item 3: #1 + allowed if reading takes place from \"special\" code object areas (eg, ELF's global offset table) 100: allowed from any area and points to a defined item 200: allowed from any area Type and Default : Integer(2) .parsers.dcmp_x86.ReconversionMaxCount # Description : Maximum decompilation pipeline restart (reconversion) allowed for a routine Type and Default : Integer(2){0+} .parsers.dcmp_x86.StructurerUseVersion # Description : Version of the structurer to use (0 means use the default structuring algorithms - in release mode, default=newest) Type and Default : Integer(2){0-3} .parsers.dcmp_x86.UseFriendlyVariableNames # Description : Let the AST generate friendly identifier names (eg, based on types) instead of generic names Type and Default : Boolean(true) .parsers.dcmp_x86.UseSSAForm # Description : Let the decompiler convert intermediate form CFG to SSA forms Type and Default : Boolean(false) .parsers.dcmp_x86.text.MergeAdjacentDefinitions # Description : Merge same type definitions on a single line (eg, int i = 0, j = 1;) Type and Default : Boolean(true) .parsers.dcmp_x86.text.SpaceOutCompounds # Description : Insert blank lines between compounds Type and Default : Boolean(true) .parsers.dcmp_x86_64.ASTOptimizerMaxRunCount # Description : Determine how many passes the AST optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(20) .parsers.dcmp_x86_64.FailOnPipelineError # Description : Determine whether or not an exception should be thrown on decompilation error. If not, the error will be visible as a comment in the decompiled code output Type and Default : Boolean(true) .parsers.dcmp_x86_64.IROptimizerDisableAggressivePass # Description : Disable aggressive IR optimization pass, normally scheduled to run in later IR lifting stages. This pass is used to remove unused out-reaching variables. Type and Default : Boolean(false) .parsers.dcmp_x86_64.IROptimizerMaxRunCount # Description : Determine how many passes the IR optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(5) .parsers.dcmp_x86_64.MemoryResolutionPolicy # Description : A resolution policy guides the memory resolver in terms of what memory dereferences can be directly resolved. Supported policy values are: 0: forbidden (no resolution allowed) 1: allowed if reading takes place in read-only area, and points to a defined item 2: #1 + allowed if reading takes place from \"special\" code object areas (eg, ELF's global offset table) and points to a defined item 3: #1 + allowed if reading takes place from \"special\" code object areas (eg, ELF's global offset table) 100: allowed from any area and points to a defined item 200: allowed from any area Type and Default : Integer(2) .parsers.dcmp_x86_64.ReconversionMaxCount # Description : Maximum decompilation pipeline restart (reconversion) allowed for a routine Type and Default : Integer(2){0+} .parsers.dcmp_x86_64.StructurerUseVersion # Description : Version of the structurer to use (0 means use the default structuring algorithms - in release mode, default=newest) Type and Default : Integer(2){0-3} .parsers.dcmp_x86_64.UseFriendlyVariableNames # Description : Let the AST generate friendly identifier names (eg, based on types) instead of generic names Type and Default : Boolean(true) .parsers.dcmp_x86_64.UseSSAForm # Description : Let the decompiler convert intermediate form CFG to SSA forms Type and Default : Boolean(false) .parsers.dcmp_x86_64.text.MergeAdjacentDefinitions # Description : Merge same type definitions on a single line (eg, int i = 0, j = 1;) Type and Default : Boolean(true) .parsers.dcmp_x86_64.text.SpaceOutCompounds # Description : Insert blank lines between compounds Type and Default : Boolean(true) .parsers.dex.AndroidJavadocRoot # Description : Location of Java/Android API documentation files; by default, local files stored in your Android SDK folder will be preferred over web-based API doc Type and Default : String(\"($ANDROID_HOME/docs|$ANDROID_SDK_HOME/docs|$ANDROID_SDK_ROOT/docs)/reference/;https://developer.android.com/reference/;($JAVA_HOME)/docs/api\") .parsers.dex.DalvikParserMode # Description : Dalvik parser mode: 0: Legacy DEX, including odex and extended opcodes (0xFFxx) - designed for DEX <=37 If DEX version >= 38 is detected, the mode will be bumped to 100, 110, or more, automatically 50: ART introduction 100: DEX version 38 (+invoke-polymorphic, +invoke-custom, and variants) 110: DEX version 39 (+const-method-handle, +const-method-type) 1000: Newest, including things that may not be supported in JEB yet Type and Default : Integer(50) .parsers.dex.ParseExtendedOpcodes # Description : Support parsing for the extended opcodes Type and Default : Boolean(true) .parsers.dex.ParseOptimizedOpcodes # Description : Support parsing for the optimized opcodes Type and Default : Boolean(true) .parsers.dex.ProvideExtraInfoInCodeNodeLabels # Description : Provide additional information in code node items to client components. Currently, when this option is enabled, method labels for concrete non-native methods are appended with a ' /N' string where N is the instruction count of the method. Type and Default : Boolean(false) .parsers.dex.ProvideFriendlyCodeNodeLabels # Description : Provide user-friendly code node items (non-qualified, non-internal Java names) to client components. Methods and field signatures will be more readable, at the risk of potentially appearing conflicting, esp. on obfuscated samples that heavily reuse names across methods, fields, and types. Type and Default : Boolean(true) .parsers.dex.VerifyAccessFlags # Description : Fail parsing if the access flags of a class, method, or field appear to be illegal Type and Default : Boolean(false) .parsers.dex.VerifyHashes # Description : Fail parsing if the DEX Adler checksum is not the expected one Type and Default : Boolean(false) .parsers.dex.VerifyVersion # Description : Fail parsing if the DEX version number is not in the range [35, 39] Type and Default : Boolean(false) .parsers.dex.WellKnownLibraryPackages # Description : CSL of well-known packages that may not be provided as fully-expanded in code hierarchy tree documents. Use * to prevent auto-expansion for all packages. In practice, the JEB UI client will not auto-expand those packages by default to avoid cluttering the code hierarchy fragment view. Type and Default : String(\"android,androidx,android_src,com.google,java,javax,org.acra,org.json,org.apache\") .parsers.dex.text.ClassSeparatorLength # Description : Length of the class separator line in characters Type and Default : Integer(0){0+} .parsers.dex.text.MethodSeparatorLength # Description : Length of the method separator line in characters Type and Default : Integer(0){0+} .parsers.dex.text.ShowAddresses # Description : Display addresses of items Type and Default : Boolean(true) .parsers.dex.text.ShowAnnotations # Description : Show the DEX annotations Type and Default : Boolean(true) .parsers.dex.text.ShowBytecode # Description : Display the instruction bytecode Type and Default : Boolean(false) .parsers.dex.text.ShowDebugDirectives # Description : Show the debug directives (metadata) Type and Default : Boolean(false) .parsers.dex.text.ShowInstructionsInGaps # Description : Parse byte gaps (aka slack space, or unsued data bytes, that can be present of method's body) and display those bytes as Dalvik instructions Type and Default : Boolean(false) .parsers.dex.text.ShowLineNumbers # Description : Show the source line numbers (metadata) Type and Default : Boolean(false) .parsers.dex.text.ShowSpaceBetweenBlocks # Description : Insert a blank line between basic blocks Type and Default : Boolean(false) .parsers.dex.text.SmaliCompatibility # Description : Generate assembly code closer to (sometimes, compatible with) Smali, eg, using fully-qualified names everywhere Type and Default : Boolean(false) .parsers.dex.text.UsePForParameters # Description : Use p0,p1,... instead of v0,v1,... for variables Type and Default : Boolean(true) .parsers.evmbc.AdvancedAnalysisRoutineCountWarning # Description : If the standard analysis yields more routines that this provided threshold, then the user will be prompted for confirmation before starting the optional advanced analysis pass (and subsequent passes). Type and Default : Integer(200){0+} .parsers.evmbc.AllowAdvancedAnalysis # Description : The advanced analysis is an optional analysis pass that comes after the initial standard analysis. It permits discovery of indirect dispatch, therefore providing better routine discovery coverage, and partial resolution of register values. Type and Default : Boolean(false) .parsers.evmbc.AnalysisStyle # Description : Native analysis style: 0 = forced conservative analysis 1 = automatic mode (depends on the file) 2 = forced aggressive analysis 3 = forced lazy analysis 4 = forced lazy no data analysis Type and Default : Integer(1){0-4} .parsers.evmbc.DebugInformationRetrievalPolicy # Description : Policy regarding the retrieval of externally-stored debugging and symbolic information of code objects: 0 = never attempt 1 = retrieve locally stored external symbols 2 = attempt to retrieve locally and network-stored symbols Locations are architecture- and code object- dependent and may be customized via environment variables. Refer to the manual for additional documentation. Type and Default : Integer(2){0-2} .parsers.evmbc.DebugInformationUsagePolicy # Description : Apply and use debug information to improve analysis accuracy (on a best-effort basis): 0 = never use debug information 1 = use internal debug information only 2 = use all available (internal and external) debug information Type and Default : Integer(1){0-2} .parsers.evmbc.IdentifiedCompiler # Description : Identified compiler: 0 = automatic identification (depends on the file) 1 = unknown compiler 2 = generic Linux compiler 3 = Android ART 4 = Android NDK 5 = generic Windows compiler 6 = Microsoft Visual C++ Type and Default : Integer(0){0-6} .parsers.evmbc.PerformClassRecovery # Description : Attempt C++ class discovery and rebuilding (limited to MSVC-compiled x86 executables for now) Type and Default : Boolean(false) .parsers.evmbc.PerformGlobalAnalysis # Description : Global analysis passes are optional passes provided by specific decompiler modules. They may allow recovery of complex artifacts, such as classes or modules. Type and Default : Boolean(false) .parsers.evmbc.PerformRttiRecovery # Description : Attempt C++ Run-Time Type Information (RTTI) discovery and rebuilding (MSVC and Itanium (GCC/CLANG/NDK) are supported) Type and Default : Boolean(true) .parsers.evmbc.PreferSynchronousExecution # Description : Synchronous analysis prevents access to the unit during a code analysis Type and Default : Boolean(false) .parsers.evmbc.TailCallAnalysisStyle # Description : Search for possible tail calls optimized as branches, and build proper routines. Possible modes: 0 = deactivated 1 = automatic mode (heuristics depend on the file) 2 = safe heuristics only 3 = aggressive heuristics Type and Default : Integer(1){0-3} .parsers.evmbc.WantedEndianness # Description : Desired endianness for raw binaries: 'little'/'le', 'big'/'be'. May be overridden by the code parser. Type and Default : String(\"le\") .parsers.evmbc.WantedImageBase # Description : Desired memory base address for raw binaries. 0 by default. Type and Default : String(\"0\") .parsers.evmbc.text.BlockXrefsCount # Description : Maximum number of cross-references displayed at any address Type and Default : Integer(50) .parsers.evmbc.text.CharBreak64BitAddresses # Description : If not empty, the address column will display 64-bit addresses as two 8-hexdigit parts, separated by the provided character string Type and Default : String(\"'\") .parsers.evmbc.text.GapPreferRawFormatting # Description : Prefer raw formatting (dr XX, dr XXXX) for gaps and slack spaces instead of regular declarations (eg, db ??) Type and Default : Boolean(false) .parsers.evmbc.text.GapRawBytesPerLine # Description : For raw formatting, determine the maximum number of bytes per line in gaps and slack spaces. Must be a power of 2, else reverts to the default. Type and Default : Integer(16){0+} .parsers.evmbc.text.GapRawIntegerSize # Description : For raw formatting, determine the integer length (in bytes) used for rendering. Must be either 1, 2, 4, or 8, else reverts to the default Type and Default : Integer(1){0+} .parsers.evmbc.text.InstructionAreaLength # Description : Length in characters of the assembly column containing the instructions Type and Default : Integer(40){0+} .parsers.evmbc.text.LabelAreaLength # Description : Length in characters of the assembly column containing the labels Type and Default : Integer(16){0+} .parsers.evmbc.text.RoutineSeparatorLength # Description : Number of characters used to build the line separating routines Type and Default : Integer(80){0+} .parsers.evmbc.text.ShowAddresses # Description : Display addresses of items Type and Default : Boolean(true) .parsers.evmbc.text.ShowBytesCount # Description : Maximum count of instruction bytes to be displayed before the instruction Type and Default : Integer(0){0+} .parsers.evmbc.text.ShowSegmentHeaders # Description : Display the segment or section headers Type and Default : Boolean(true) .parsers.evmbc.text.ShowSpaceBetweenBlocks # Description : Insert blank lines between basic blocks Type and Default : Boolean(false) .parsers.ihex.BigEndian # Description : Set to true to specify big-endian. The default is little-endian, unless a specific processor setting overrides it. Type and Default : Boolean(false) .parsers.ihex.Processor # Description : Target processor/microcontroller code: 'x86', 'x86_64', 'arm', 'arm64', 'mips', 'avr', etc. The default is x86 Type and Default : String(\"x86\") .parsers.ihex.WantedImageBase # Description : Base address hint. Leave empty to let the plugin decide Type and Default : String(\"\") .parsers.ihex.WantedWordsize # Description : Desired wordsize in bits: 8, 16, 32, etc. Leave empty to let the plugin decide by heuristics Type and Default : String(\"\") .parsers.javaclass.UseD8ForDexConversion # Description : Prefer the new d8/r8 compiler over the legacy dx compiler to perform Java bytecode to Dalvik bytecode transpilation Type and Default : Boolean(false) .parsers.libravm_bc.AdvancedAnalysisRoutineCountWarning # Description : If the standard analysis yields more routines that this provided threshold, then the user will be prompted for confirmation before starting the optional advanced analysis pass (and subsequent passes). Type and Default : Integer(200){0+} .parsers.libravm_bc.AllowAdvancedAnalysis # Description : The advanced analysis is an optional analysis pass that comes after the initial standard analysis. It permits discovery of indirect dispatch, therefore providing better routine discovery coverage, and partial resolution of register values. Type and Default : Boolean(false) .parsers.libravm_bc.AnalysisStyle # Description : Native analysis style: 0 = forced conservative analysis 1 = automatic mode (depends on the file) 2 = forced aggressive analysis 3 = forced lazy analysis 4 = forced lazy no data analysis Type and Default : Integer(1){0-4} .parsers.libravm_bc.DebugInformationRetrievalPolicy # Description : Policy regarding the retrieval of externally-stored debugging and symbolic information of code objects: 0 = never attempt 1 = retrieve locally stored external symbols 2 = attempt to retrieve locally and network-stored symbols Locations are architecture- and code object- dependent and may be customized via environment variables. Refer to the manual for additional documentation. Type and Default : Integer(2){0-2} .parsers.libravm_bc.DebugInformationUsagePolicy # Description : Apply and use debug information to improve analysis accuracy (on a best-effort basis): 0 = never use debug information 1 = use internal debug information only 2 = use all available (internal and external) debug information Type and Default : Integer(1){0-2} .parsers.libravm_bc.IdentifiedCompiler # Description : Identified compiler: 0 = automatic identification (depends on the file) 1 = unknown compiler 2 = generic Linux compiler 3 = Android ART 4 = Android NDK 5 = generic Windows compiler 6 = Microsoft Visual C++ Type and Default : Integer(0){0-6} .parsers.libravm_bc.PerformClassRecovery # Description : Attempt C++ class discovery and rebuilding (limited to MSVC-compiled x86 executables for now) Type and Default : Boolean(false) .parsers.libravm_bc.PerformGlobalAnalysis # Description : Global analysis passes are optional passes provided by specific decompiler modules. They may allow recovery of complex artifacts, such as classes or modules. Type and Default : Boolean(false) .parsers.libravm_bc.PerformRttiRecovery # Description : Attempt C++ Run-Time Type Information (RTTI) discovery and rebuilding (MSVC and Itanium (GCC/CLANG/NDK) are supported) Type and Default : Boolean(true) .parsers.libravm_bc.PreferSynchronousExecution # Description : Synchronous analysis prevents access to the unit during a code analysis Type and Default : Boolean(false) .parsers.libravm_bc.TailCallAnalysisStyle # Description : Search for possible tail calls optimized as branches, and build proper routines. Possible modes: 0 = deactivated 1 = automatic mode (heuristics depend on the file) 2 = safe heuristics only 3 = aggressive heuristics Type and Default : Integer(1){0-3} .parsers.libravm_bc.WantedEndianness # Description : Desired endianness for raw binaries: 'little'/'le', 'big'/'be'. May be overridden by the code parser. Type and Default : String(\"le\") .parsers.libravm_bc.WantedImageBase # Description : Desired memory base address for raw binaries. 0 by default. Type and Default : String(\"0\") .parsers.libravm_bc.text.BlockXrefsCount # Description : Maximum number of cross-references displayed at any address Type and Default : Integer(50) .parsers.libravm_bc.text.CharBreak64BitAddresses # Description : If not empty, the address column will display 64-bit addresses as two 8-hexdigit parts, separated by the provided character string Type and Default : String(\"'\") .parsers.libravm_bc.text.GapPreferRawFormatting # Description : Prefer raw formatting (dr XX, dr XXXX) for gaps and slack spaces instead of regular declarations (eg, db ??) Type and Default : Boolean(false) .parsers.libravm_bc.text.GapRawBytesPerLine # Description : For raw formatting, determine the maximum number of bytes per line in gaps and slack spaces. Must be a power of 2, else reverts to the default. Type and Default : Integer(16){0+} .parsers.libravm_bc.text.GapRawIntegerSize # Description : For raw formatting, determine the integer length (in bytes) used for rendering. Must be either 1, 2, 4, or 8, else reverts to the default Type and Default : Integer(1){0+} .parsers.libravm_bc.text.InstructionAreaLength # Description : Length in characters of the assembly column containing the instructions Type and Default : Integer(40){0+} .parsers.libravm_bc.text.LabelAreaLength # Description : Length in characters of the assembly column containing the labels Type and Default : Integer(16){0+} .parsers.libravm_bc.text.RoutineSeparatorLength # Description : Number of characters used to build the line separating routines Type and Default : Integer(80){0+} .parsers.libravm_bc.text.ShowAddresses # Description : Display addresses of items Type and Default : Boolean(true) .parsers.libravm_bc.text.ShowBytesCount # Description : Maximum count of instruction bytes to be displayed before the instruction Type and Default : Integer(0){0+} .parsers.libravm_bc.text.ShowSegmentHeaders # Description : Display the segment or section headers Type and Default : Boolean(true) .parsers.libravm_bc.text.ShowSpaceBetweenBlocks # Description : Insert blank lines between basic blocks Type and Default : Boolean(false) .parsers.mips.AdvancedAnalysisRoutineCountWarning # Description : If the standard analysis yields more routines that this provided threshold, then the user will be prompted for confirmation before starting the optional advanced analysis pass (and subsequent passes). Type and Default : Integer(200){0+} .parsers.mips.AllowAdvancedAnalysis # Description : The advanced analysis is an optional analysis pass that comes after the initial standard analysis. It permits discovery of indirect dispatch, therefore providing better routine discovery coverage, and partial resolution of register values. Type and Default : Boolean(false) .parsers.mips.AnalysisStyle # Description : Native analysis style: 0 = forced conservative analysis 1 = automatic mode (depends on the file) 2 = forced aggressive analysis 3 = forced lazy analysis 4 = forced lazy no data analysis Type and Default : Integer(1){0-4} .parsers.mips.DebugInformationRetrievalPolicy # Description : Policy regarding the retrieval of externally-stored debugging and symbolic information of code objects: 0 = never attempt 1 = retrieve locally stored external symbols 2 = attempt to retrieve locally and network-stored symbols Locations are architecture- and code object- dependent and may be customized via environment variables. Refer to the manual for additional documentation. Type and Default : Integer(2){0-2} .parsers.mips.DebugInformationUsagePolicy # Description : Apply and use debug information to improve analysis accuracy (on a best-effort basis): 0 = never use debug information 1 = use internal debug information only 2 = use all available (internal and external) debug information Type and Default : Integer(1){0-2} .parsers.mips.IdentifiedCompiler # Description : Identified compiler: 0 = automatic identification (depends on the file) 1 = unknown compiler 2 = generic Linux compiler 3 = Android ART 4 = Android NDK 5 = generic Windows compiler 6 = Microsoft Visual C++ Type and Default : Integer(0){0-6} .parsers.mips.PerformClassRecovery # Description : Attempt C++ class discovery and rebuilding (limited to MSVC-compiled x86 executables for now) Type and Default : Boolean(false) .parsers.mips.PerformGlobalAnalysis # Description : Global analysis passes are optional passes provided by specific decompiler modules. They may allow recovery of complex artifacts, such as classes or modules. Type and Default : Boolean(false) .parsers.mips.PerformRttiRecovery # Description : Attempt C++ Run-Time Type Information (RTTI) discovery and rebuilding (MSVC and Itanium (GCC/CLANG/NDK) are supported) Type and Default : Boolean(true) .parsers.mips.PreferSynchronousExecution # Description : Synchronous analysis prevents access to the unit during a code analysis Type and Default : Boolean(false) .parsers.mips.TailCallAnalysisStyle # Description : Search for possible tail calls optimized as branches, and build proper routines. Possible modes: 0 = deactivated 1 = automatic mode (heuristics depend on the file) 2 = safe heuristics only 3 = aggressive heuristics Type and Default : Integer(1){0-3} .parsers.mips.WantedEndianness # Description : Desired endianness for raw binaries: 'little'/'le', 'big'/'be'. May be overridden by the code parser. Type and Default : String(\"le\") .parsers.mips.WantedImageBase # Description : Desired memory base address for raw binaries. 0 by default. Type and Default : String(\"0\") .parsers.mips.text.BlockXrefsCount # Description : Maximum number of cross-references displayed at any address Type and Default : Integer(50) .parsers.mips.text.CharBreak64BitAddresses # Description : If not empty, the address column will display 64-bit addresses as two 8-hexdigit parts, separated by the provided character string Type and Default : String(\"'\") .parsers.mips.text.GapPreferRawFormatting # Description : Prefer raw formatting (dr XX, dr XXXX) for gaps and slack spaces instead of regular declarations (eg, db ??) Type and Default : Boolean(false) .parsers.mips.text.GapRawBytesPerLine # Description : For raw formatting, determine the maximum number of bytes per line in gaps and slack spaces. Must be a power of 2, else reverts to the default. Type and Default : Integer(16){0+} .parsers.mips.text.GapRawIntegerSize # Description : For raw formatting, determine the integer length (in bytes) used for rendering. Must be either 1, 2, 4, or 8, else reverts to the default Type and Default : Integer(1){0+} .parsers.mips.text.InstructionAreaLength # Description : Length in characters of the assembly column containing the instructions Type and Default : Integer(40){0+} .parsers.mips.text.LabelAreaLength # Description : Length in characters of the assembly column containing the labels Type and Default : Integer(16){0+} .parsers.mips.text.RoutineSeparatorLength # Description : Number of characters used to build the line separating routines Type and Default : Integer(80){0+} .parsers.mips.text.ShowAddresses # Description : Display addresses of items Type and Default : Boolean(true) .parsers.mips.text.ShowBytesCount # Description : Maximum count of instruction bytes to be displayed before the instruction Type and Default : Integer(0){0+} .parsers.mips.text.ShowSegmentHeaders # Description : Display the segment or section headers Type and Default : Boolean(true) .parsers.mips.text.ShowSpaceBetweenBlocks # Description : Insert blank lines between basic blocks Type and Default : Boolean(false) .parsers.mips64.AdvancedAnalysisRoutineCountWarning # Description : If the standard analysis yields more routines that this provided threshold, then the user will be prompted for confirmation before starting the optional advanced analysis pass (and subsequent passes). Type and Default : Integer(200){0+} .parsers.mips64.AllowAdvancedAnalysis # Description : The advanced analysis is an optional analysis pass that comes after the initial standard analysis. It permits discovery of indirect dispatch, therefore providing better routine discovery coverage, and partial resolution of register values. Type and Default : Boolean(false) .parsers.mips64.AnalysisStyle # Description : Native analysis style: 0 = forced conservative analysis 1 = automatic mode (depends on the file) 2 = forced aggressive analysis 3 = forced lazy analysis 4 = forced lazy no data analysis Type and Default : Integer(1){0-4} .parsers.mips64.DebugInformationRetrievalPolicy # Description : Policy regarding the retrieval of externally-stored debugging and symbolic information of code objects: 0 = never attempt 1 = retrieve locally stored external symbols 2 = attempt to retrieve locally and network-stored symbols Locations are architecture- and code object- dependent and may be customized via environment variables. Refer to the manual for additional documentation. Type and Default : Integer(2){0-2} .parsers.mips64.DebugInformationUsagePolicy # Description : Apply and use debug information to improve analysis accuracy (on a best-effort basis): 0 = never use debug information 1 = use internal debug information only 2 = use all available (internal and external) debug information Type and Default : Integer(1){0-2} .parsers.mips64.IdentifiedCompiler # Description : Identified compiler: 0 = automatic identification (depends on the file) 1 = unknown compiler 2 = generic Linux compiler 3 = Android ART 4 = Android NDK 5 = generic Windows compiler 6 = Microsoft Visual C++ Type and Default : Integer(0){0-6} .parsers.mips64.PerformClassRecovery # Description : Attempt C++ class discovery and rebuilding (limited to MSVC-compiled x86 executables for now) Type and Default : Boolean(false) .parsers.mips64.PerformGlobalAnalysis # Description : Global analysis passes are optional passes provided by specific decompiler modules. They may allow recovery of complex artifacts, such as classes or modules. Type and Default : Boolean(false) .parsers.mips64.PerformRttiRecovery # Description : Attempt C++ Run-Time Type Information (RTTI) discovery and rebuilding (MSVC and Itanium (GCC/CLANG/NDK) are supported) Type and Default : Boolean(true) .parsers.mips64.PreferSynchronousExecution # Description : Synchronous analysis prevents access to the unit during a code analysis Type and Default : Boolean(false) .parsers.mips64.TailCallAnalysisStyle # Description : Search for possible tail calls optimized as branches, and build proper routines. Possible modes: 0 = deactivated 1 = automatic mode (heuristics depend on the file) 2 = safe heuristics only 3 = aggressive heuristics Type and Default : Integer(1){0-3} .parsers.mips64.WantedEndianness # Description : Desired endianness for raw binaries: 'little'/'le', 'big'/'be'. May be overridden by the code parser. Type and Default : String(\"le\") .parsers.mips64.WantedImageBase # Description : Desired memory base address for raw binaries. 0 by default. Type and Default : String(\"0\") .parsers.mips64.text.BlockXrefsCount # Description : Maximum number of cross-references displayed at any address Type and Default : Integer(50) .parsers.mips64.text.CharBreak64BitAddresses # Description : If not empty, the address column will display 64-bit addresses as two 8-hexdigit parts, separated by the provided character string Type and Default : String(\"'\") .parsers.mips64.text.GapPreferRawFormatting # Description : Prefer raw formatting (dr XX, dr XXXX) for gaps and slack spaces instead of regular declarations (eg, db ??) Type and Default : Boolean(false) .parsers.mips64.text.GapRawBytesPerLine # Description : For raw formatting, determine the maximum number of bytes per line in gaps and slack spaces. Must be a power of 2, else reverts to the default. Type and Default : Integer(16){0+} .parsers.mips64.text.GapRawIntegerSize # Description : For raw formatting, determine the integer length (in bytes) used for rendering. Must be either 1, 2, 4, or 8, else reverts to the default Type and Default : Integer(1){0+} .parsers.mips64.text.InstructionAreaLength # Description : Length in characters of the assembly column containing the instructions Type and Default : Integer(40){0+} .parsers.mips64.text.LabelAreaLength # Description : Length in characters of the assembly column containing the labels Type and Default : Integer(16){0+} .parsers.mips64.text.RoutineSeparatorLength # Description : Number of characters used to build the line separating routines Type and Default : Integer(80){0+} .parsers.mips64.text.ShowAddresses # Description : Display addresses of items Type and Default : Boolean(true) .parsers.mips64.text.ShowBytesCount # Description : Maximum count of instruction bytes to be displayed before the instruction Type and Default : Integer(0){0+} .parsers.mips64.text.ShowSegmentHeaders # Description : Display the segment or section headers Type and Default : Boolean(true) .parsers.mips64.text.ShowSpaceBetweenBlocks # Description : Insert blank lines between basic blocks Type and Default : Boolean(false) .parsers.wasmbc.AdvancedAnalysisRoutineCountWarning # Description : If the standard analysis yields more routines that this provided threshold, then the user will be prompted for confirmation before starting the optional advanced analysis pass (and subsequent passes). Type and Default : Integer(200){0+} .parsers.wasmbc.AllowAdvancedAnalysis # Description : The advanced analysis is an optional analysis pass that comes after the initial standard analysis. It permits discovery of indirect dispatch, therefore providing better routine discovery coverage, and partial resolution of register values. Type and Default : Boolean(false) .parsers.wasmbc.AnalysisStyle # Description : Native analysis style: 0 = forced conservative analysis 1 = automatic mode (depends on the file) 2 = forced aggressive analysis 3 = forced lazy analysis 4 = forced lazy no data analysis Type and Default : Integer(1){0-4} .parsers.wasmbc.DebugInformationRetrievalPolicy # Description : Policy regarding the retrieval of externally-stored debugging and symbolic information of code objects: 0 = never attempt 1 = retrieve locally stored external symbols 2 = attempt to retrieve locally and network-stored symbols Locations are architecture- and code object- dependent and may be customized via environment variables. Refer to the manual for additional documentation. Type and Default : Integer(2){0-2} .parsers.wasmbc.DebugInformationUsagePolicy # Description : Apply and use debug information to improve analysis accuracy (on a best-effort basis): 0 = never use debug information 1 = use internal debug information only 2 = use all available (internal and external) debug information Type and Default : Integer(1){0-2} .parsers.wasmbc.IdentifiedCompiler # Description : Identified compiler: 0 = automatic identification (depends on the file) 1 = unknown compiler 2 = generic Linux compiler 3 = Android ART 4 = Android NDK 5 = generic Windows compiler 6 = Microsoft Visual C++ Type and Default : Integer(0){0-6} .parsers.wasmbc.PerformClassRecovery # Description : Attempt C++ class discovery and rebuilding (limited to MSVC-compiled x86 executables for now) Type and Default : Boolean(false) .parsers.wasmbc.PerformGlobalAnalysis # Description : Global analysis passes are optional passes provided by specific decompiler modules. They may allow recovery of complex artifacts, such as classes or modules. Type and Default : Boolean(false) .parsers.wasmbc.PerformRttiRecovery # Description : Attempt C++ Run-Time Type Information (RTTI) discovery and rebuilding (MSVC and Itanium (GCC/CLANG/NDK) are supported) Type and Default : Boolean(true) .parsers.wasmbc.PreferSynchronousExecution # Description : Synchronous analysis prevents access to the unit during a code analysis Type and Default : Boolean(false) .parsers.wasmbc.TailCallAnalysisStyle # Description : Search for possible tail calls optimized as branches, and build proper routines. Possible modes: 0 = deactivated 1 = automatic mode (heuristics depend on the file) 2 = safe heuristics only 3 = aggressive heuristics Type and Default : Integer(1){0-3} .parsers.wasmbc.WantedEndianness # Description : Desired endianness for raw binaries: 'little'/'le', 'big'/'be'. May be overridden by the code parser. Type and Default : String(\"le\") .parsers.wasmbc.WantedImageBase # Description : Desired memory base address for raw binaries. 0 by default. Type and Default : String(\"0\") .parsers.wasmbc.text.BlockXrefsCount # Description : Maximum number of cross-references displayed at any address Type and Default : Integer(50) .parsers.wasmbc.text.CharBreak64BitAddresses # Description : If not empty, the address column will display 64-bit addresses as two 8-hexdigit parts, separated by the provided character string Type and Default : String(\"'\") .parsers.wasmbc.text.GapPreferRawFormatting # Description : Prefer raw formatting (dr XX, dr XXXX) for gaps and slack spaces instead of regular declarations (eg, db ??) Type and Default : Boolean(false) .parsers.wasmbc.text.GapRawBytesPerLine # Description : For raw formatting, determine the maximum number of bytes per line in gaps and slack spaces. Must be a power of 2, else reverts to the default. Type and Default : Integer(16){0+} .parsers.wasmbc.text.GapRawIntegerSize # Description : For raw formatting, determine the integer length (in bytes) used for rendering. Must be either 1, 2, 4, or 8, else reverts to the default Type and Default : Integer(1){0+} .parsers.wasmbc.text.InstructionAreaLength # Description : Length in characters of the assembly column containing the instructions Type and Default : Integer(40){0+} .parsers.wasmbc.text.LabelAreaLength # Description : Length in characters of the assembly column containing the labels Type and Default : Integer(16){0+} .parsers.wasmbc.text.RoutineSeparatorLength # Description : Number of characters used to build the line separating routines Type and Default : Integer(80){0+} .parsers.wasmbc.text.ShowAddresses # Description : Display addresses of items Type and Default : Boolean(true) .parsers.wasmbc.text.ShowBytesCount # Description : Maximum count of instruction bytes to be displayed before the instruction Type and Default : Integer(0){0+} .parsers.wasmbc.text.ShowSegmentHeaders # Description : Display the segment or section headers Type and Default : Boolean(true) .parsers.wasmbc.text.ShowSpaceBetweenBlocks # Description : Insert blank lines between basic blocks Type and Default : Boolean(false) .parsers.x86.AdvancedAnalysisRoutineCountWarning # Description : If the standard analysis yields more routines that this provided threshold, then the user will be prompted for confirmation before starting the optional advanced analysis pass (and subsequent passes). Type and Default : Integer(200){0+} .parsers.x86.AllowAdvancedAnalysis # Description : The advanced analysis is an optional analysis pass that comes after the initial standard analysis. It permits discovery of indirect dispatch, therefore providing better routine discovery coverage, and partial resolution of register values. Type and Default : Boolean(false) .parsers.x86.AnalysisStyle # Description : Native analysis style: 0 = forced conservative analysis 1 = automatic mode (depends on the file) 2 = forced aggressive analysis 3 = forced lazy analysis 4 = forced lazy no data analysis Type and Default : Integer(1){0-4} .parsers.x86.DebugInformationRetrievalPolicy # Description : Policy regarding the retrieval of externally-stored debugging and symbolic information of code objects: 0 = never attempt 1 = retrieve locally stored external symbols 2 = attempt to retrieve locally and network-stored symbols Locations are architecture- and code object- dependent and may be customized via environment variables. Refer to the manual for additional documentation. Type and Default : Integer(2){0-2} .parsers.x86.DebugInformationUsagePolicy # Description : Apply and use debug information to improve analysis accuracy (on a best-effort basis): 0 = never use debug information 1 = use internal debug information only 2 = use all available (internal and external) debug information Type and Default : Integer(1){0-2} .parsers.x86.IdentifiedCompiler # Description : Identified compiler: 0 = automatic identification (depends on the file) 1 = unknown compiler 2 = generic Linux compiler 3 = Android ART 4 = Android NDK 5 = generic Windows compiler 6 = Microsoft Visual C++ Type and Default : Integer(0){0-6} .parsers.x86.PerformClassRecovery # Description : Attempt C++ class discovery and rebuilding (limited to MSVC-compiled x86 executables for now) Type and Default : Boolean(false) .parsers.x86.PerformGlobalAnalysis # Description : Global analysis passes are optional passes provided by specific decompiler modules. They may allow recovery of complex artifacts, such as classes or modules. Type and Default : Boolean(false) .parsers.x86.PerformRttiRecovery # Description : Attempt C++ Run-Time Type Information (RTTI) discovery and rebuilding (MSVC and Itanium (GCC/CLANG/NDK) are supported) Type and Default : Boolean(true) .parsers.x86.PreferSynchronousExecution # Description : Synchronous analysis prevents access to the unit during a code analysis Type and Default : Boolean(false) .parsers.x86.TailCallAnalysisStyle # Description : Search for possible tail calls optimized as branches, and build proper routines. Possible modes: 0 = deactivated 1 = automatic mode (heuristics depend on the file) 2 = safe heuristics only 3 = aggressive heuristics Type and Default : Integer(1){0-3} .parsers.x86.WantedEndianness # Description : Desired endianness for raw binaries: 'little'/'le', 'big'/'be'. May be overridden by the code parser. Type and Default : String(\"le\") .parsers.x86.WantedImageBase # Description : Desired memory base address for raw binaries. 0 by default. Type and Default : String(\"0\") .parsers.x86.text.BlockXrefsCount # Description : Maximum number of cross-references displayed at any address Type and Default : Integer(50) .parsers.x86.text.CharBreak64BitAddresses # Description : If not empty, the address column will display 64-bit addresses as two 8-hexdigit parts, separated by the provided character string Type and Default : String(\"'\") .parsers.x86.text.GapPreferRawFormatting # Description : Prefer raw formatting (dr XX, dr XXXX) for gaps and slack spaces instead of regular declarations (eg, db ??) Type and Default : Boolean(false) .parsers.x86.text.GapRawBytesPerLine # Description : For raw formatting, determine the maximum number of bytes per line in gaps and slack spaces. Must be a power of 2, else reverts to the default. Type and Default : Integer(16){0+} .parsers.x86.text.GapRawIntegerSize # Description : For raw formatting, determine the integer length (in bytes) used for rendering. Must be either 1, 2, 4, or 8, else reverts to the default Type and Default : Integer(1){0+} .parsers.x86.text.InstructionAreaLength # Description : Length in characters of the assembly column containing the instructions Type and Default : Integer(40){0+} .parsers.x86.text.LabelAreaLength # Description : Length in characters of the assembly column containing the labels Type and Default : Integer(16){0+} .parsers.x86.text.RoutineSeparatorLength # Description : Number of characters used to build the line separating routines Type and Default : Integer(80){0+} .parsers.x86.text.ShowAddresses # Description : Display addresses of items Type and Default : Boolean(true) .parsers.x86.text.ShowBytesCount # Description : Maximum count of instruction bytes to be displayed before the instruction Type and Default : Integer(0){0+} .parsers.x86.text.ShowSegmentHeaders # Description : Display the segment or section headers Type and Default : Boolean(true) .parsers.x86.text.ShowSpaceBetweenBlocks # Description : Insert blank lines between basic blocks Type and Default : Boolean(false) .parsers.x86_64.AdvancedAnalysisRoutineCountWarning # Description : If the standard analysis yields more routines that this provided threshold, then the user will be prompted for confirmation before starting the optional advanced analysis pass (and subsequent passes). Type and Default : Integer(200){0+} .parsers.x86_64.AllowAdvancedAnalysis # Description : The advanced analysis is an optional analysis pass that comes after the initial standard analysis. It permits discovery of indirect dispatch, therefore providing better routine discovery coverage, and partial resolution of register values. Type and Default : Boolean(false) .parsers.x86_64.AnalysisStyle # Description : Native analysis style: 0 = forced conservative analysis 1 = automatic mode (depends on the file) 2 = forced aggressive analysis 3 = forced lazy analysis 4 = forced lazy no data analysis Type and Default : Integer(1){0-4} .parsers.x86_64.DebugInformationRetrievalPolicy # Description : Policy regarding the retrieval of externally-stored debugging and symbolic information of code objects: 0 = never attempt 1 = retrieve locally stored external symbols 2 = attempt to retrieve locally and network-stored symbols Locations are architecture- and code object- dependent and may be customized via environment variables. Refer to the manual for additional documentation. Type and Default : Integer(2){0-2} .parsers.x86_64.DebugInformationUsagePolicy # Description : Apply and use debug information to improve analysis accuracy (on a best-effort basis): 0 = never use debug information 1 = use internal debug information only 2 = use all available (internal and external) debug information Type and Default : Integer(1){0-2} .parsers.x86_64.IdentifiedCompiler # Description : Identified compiler: 0 = automatic identification (depends on the file) 1 = unknown compiler 2 = generic Linux compiler 3 = Android ART 4 = Android NDK 5 = generic Windows compiler 6 = Microsoft Visual C++ Type and Default : Integer(0){0-6} .parsers.x86_64.PerformClassRecovery # Description : Attempt C++ class discovery and rebuilding (limited to MSVC-compiled x86 executables for now) Type and Default : Boolean(false) .parsers.x86_64.PerformGlobalAnalysis # Description : Global analysis passes are optional passes provided by specific decompiler modules. They may allow recovery of complex artifacts, such as classes or modules. Type and Default : Boolean(false) .parsers.x86_64.PerformRttiRecovery # Description : Attempt C++ Run-Time Type Information (RTTI) discovery and rebuilding (MSVC and Itanium (GCC/CLANG/NDK) are supported) Type and Default : Boolean(true) .parsers.x86_64.PreferSynchronousExecution # Description : Synchronous analysis prevents access to the unit during a code analysis Type and Default : Boolean(false) .parsers.x86_64.TailCallAnalysisStyle # Description : Search for possible tail calls optimized as branches, and build proper routines. Possible modes: 0 = deactivated 1 = automatic mode (heuristics depend on the file) 2 = safe heuristics only 3 = aggressive heuristics Type and Default : Integer(1){0-3} .parsers.x86_64.WantedEndianness # Description : Desired endianness for raw binaries: 'little'/'le', 'big'/'be'. May be overridden by the code parser. Type and Default : String(\"le\") .parsers.x86_64.WantedImageBase # Description : Desired memory base address for raw binaries. 0 by default. Type and Default : String(\"0\") .parsers.x86_64.text.BlockXrefsCount # Description : Maximum number of cross-references displayed at any address Type and Default : Integer(50) .parsers.x86_64.text.CharBreak64BitAddresses # Description : If not empty, the address column will display 64-bit addresses as two 8-hexdigit parts, separated by the provided character string Type and Default : String(\"'\") .parsers.x86_64.text.GapPreferRawFormatting # Description : Prefer raw formatting (dr XX, dr XXXX) for gaps and slack spaces instead of regular declarations (eg, db ??) Type and Default : Boolean(false) .parsers.x86_64.text.GapRawBytesPerLine # Description : For raw formatting, determine the maximum number of bytes per line in gaps and slack spaces. Must be a power of 2, else reverts to the default. Type and Default : Integer(16){0+} .parsers.x86_64.text.GapRawIntegerSize # Description : For raw formatting, determine the integer length (in bytes) used for rendering. Must be either 1, 2, 4, or 8, else reverts to the default Type and Default : Integer(1){0+} .parsers.x86_64.text.InstructionAreaLength # Description : Length in characters of the assembly column containing the instructions Type and Default : Integer(40){0+} .parsers.x86_64.text.LabelAreaLength # Description : Length in characters of the assembly column containing the labels Type and Default : Integer(16){0+} .parsers.x86_64.text.RoutineSeparatorLength # Description : Number of characters used to build the line separating routines Type and Default : Integer(80){0+} .parsers.x86_64.text.ShowAddresses # Description : Display addresses of items Type and Default : Boolean(true) .parsers.x86_64.text.ShowBytesCount # Description : Maximum count of instruction bytes to be displayed before the instruction Type and Default : Integer(0){0+} .parsers.x86_64.text.ShowSegmentHeaders # Description : Display the segment or section headers Type and Default : Boolean(true) .parsers.x86_64.text.ShowSpaceBetweenBlocks # Description : Insert blank lines between basic blocks Type and Default : Boolean(false) .project.AlwaysProcessDuplicateInputs # Description : Always process binary inputs even if that input was seen earlier and processed as another unit already Type and Default : Boolean(false) .project.ArtifactProcessingDepth # Description : Determine the maximum depth an input artifact (eg, a file) will be explored to create units and sub-units representing analysis entities Type and Default : Integer(20){1+} .project.CompressPersistedProject # Description : Compress the JDB2 database (recommended) Type and Default : Boolean(true) .project.PersistenceStrategy # Description : Determine how a project will be saved to JDB2: 0: default (full save) 1: explicit full save 2: quick save Type and Default : Integer(0){0-2}","title":"Engines Configuration"},{"location":"engines-configuration.html#databasebackupbeforesave","text":"Description : Before saving a project to JDB2, the current JDB2 database is copied to the %TEMP% folder and will be used as backup is any problem showed up during saving. Type and Default : Boolean(true)","title":".DatabaseBackupBeforeSave"},{"location":"engines-configuration.html#devpluginclassnames","text":"Description : Classnames of your in-development plugin entry-point classes (they are not JARs) Type and Default : String(\"\")","title":".DevPluginClassnames"},{"location":"engines-configuration.html#devpluginclasspath","text":"Description : Classpath for your in-development plugins (they are not JARs) Type and Default : String(\"\")","title":".DevPluginClasspath"},{"location":"engines-configuration.html#loadpythonplugins","text":"Description : Specify whether or not JEB back-end plugins written in Python are allowed and should be loaded Type and Default : Boolean(true)","title":".LoadPythonPlugins"},{"location":"engines-configuration.html#networkproxy","text":"Description : Network proxy settings for JEB back-end components. The format of this property is: 'protocol|hostname|port|user|pass'. Protocol can be http or socks. User and password are optional (needed only if your proxy requires authentication) Type and Default : String(\"\")","title":".NetworkProxy"},{"location":"engines-configuration.html#pluginsfolder","text":"Description : Location of the JEB back-end plugins folder Type and Default : String(\"$JEB_HOME/coreplugins\")","title":".PluginsFolder"},{"location":"engines-configuration.html#siglibsautoloadpackages","text":"Description : Specify whether or not signature libraries should be automatically loaded when target file is deemed suitable Type and Default : Boolean(true)","title":".SiglibsAutoLoadPackages"},{"location":"engines-configuration.html#siglibsautomodesavecount","text":"Description : Number of signatures that need to be created before saving to a signature package; if 0 the package is not saved by this manager Type and Default : Integer(10)","title":".SiglibsAutoModeSaveCount"},{"location":"engines-configuration.html#siglibsfolder","text":"Description : Folder containing native code signature libraries Type and Default : String(\"$JEB_HOME/siglibs\")","title":".SiglibsFolder"},{"location":"engines-configuration.html#typelibsfolder","text":"Description : Folder containing native type libraries Type and Default : String(\"$JEB_HOME/typelibs\")","title":".TypelibsFolder"},{"location":"engines-configuration.html#parsersenforceversionchecks","text":"Description : Verify that the plugins's requirements in terms for JEB are met. Ex: if enabled, a plugin requiring JEB [2.3.10, 3.0.7] will not be loaded if JEB is older than 2.3.10 or newer than 3.0.7 Type and Default : Boolean(true)","title":".parsers.EnforceVersionChecks"},{"location":"engines-configuration.html#parsersapkandroidjavadocroot","text":"Description : Location of Java/Android API documentation files; by default, local files stored in your Android SDK folder will be preferred over web-based API doc Type and Default : String(\"($ANDROID_HOME/docs|$ANDROID_SDK_HOME/docs|$ANDROID_SDK_ROOT/docs)/reference/;https://developer.android.com/reference/;($JAVA_HOME)/docs/api\")","title":".parsers.apk.AndroidJavadocRoot"},{"location":"engines-configuration.html#parsersapkarscrestructuringmode","text":"Description : Restructuring mode for decoded resource files: either 0 (none), 1 (basic), 2 (moving to better folder), 3 (moving + renaming - the default) Type and Default : Integer(3)","title":".parsers.apk.ArscRestructuringMode"},{"location":"engines-configuration.html#parsersapkdisableassetsprocessingthreshold","text":"Description : The plugin will suggest disabling the auto-processing of APK assets if the number of asset files exceed that threshold (0 to disable) Type and Default : Integer(300){0+}","title":".parsers.apk.DisableAssetsProcessingThreshold"},{"location":"engines-configuration.html#parsersapkdisableresourcesprocessingthreshold","text":"Description : The plugin will suggest disabling the auto-processing of APK resources if the number of resource files exceed that threshold (0 to disable) Type and Default : Integer(500){0+}","title":".parsers.apk.DisableResourcesProcessingThreshold"},{"location":"engines-configuration.html#parsersapkframeworksdirectory","text":"Description : Directory containing additional frameworks. Leave empty to use the default, which is the '.jeb-android-frameworks' directory in your Home folder Type and Default : Path(\"\")","title":".parsers.apk.FrameworksDirectory"},{"location":"engines-configuration.html#parsersapkgenerateaapt2output","text":"Description : Tick to generate an additional text fragment that will describe the APK resources similarly to AAPT2's output Type and Default : Boolean(false)","title":".parsers.apk.GenerateAapt2Output"},{"location":"engines-configuration.html#parsersapkmergemultidex","text":"Description : Attempt to merge the DEX files of a multi-DEX APK into a single, unified DEX unit Type and Default : Boolean(true)","title":".parsers.apk.MergeMultiDex"},{"location":"engines-configuration.html#parsersapkprocessassets","text":"Description : Process files in the APK's Assets directory Type and Default : Boolean(true)","title":".parsers.apk.ProcessAssets"},{"location":"engines-configuration.html#parsersapkprocessbytecode","text":"Description : Process the Dalvik bytecode (classes[N].dex) Type and Default : Boolean(true)","title":".parsers.apk.ProcessBytecode"},{"location":"engines-configuration.html#parsersapkprocesscertificates","text":"Description : Process the APK's certificates data (legacy, v1, and v2) Type and Default : Boolean(true)","title":".parsers.apk.ProcessCertificates"},{"location":"engines-configuration.html#parsersapkprocesslibraries","text":"Description : Process native code (.so) libraries Type and Default : Boolean(true)","title":".parsers.apk.ProcessLibraries"},{"location":"engines-configuration.html#parsersapkprocessmanifest","text":"Description : Decode and process the APK Manifest Type and Default : Boolean(true)","title":".parsers.apk.ProcessManifest"},{"location":"engines-configuration.html#parsersapkprocessresources","text":"Description : Decode and process the Resources (if this option is true, the Manifest is always processed) Type and Default : Boolean(true)","title":".parsers.apk.ProcessResources"},{"location":"engines-configuration.html#parsersarmadvancedanalysisroutinecountwarning","text":"Description : If the standard analysis yields more routines that this provided threshold, then the user will be prompted for confirmation before starting the optional advanced analysis pass (and subsequent passes). Type and Default : Integer(200){0+}","title":".parsers.arm.AdvancedAnalysisRoutineCountWarning"},{"location":"engines-configuration.html#parsersarmallowadvancedanalysis","text":"Description : The advanced analysis is an optional analysis pass that comes after the initial standard analysis. It permits discovery of indirect dispatch, therefore providing better routine discovery coverage, and partial resolution of register values. Type and Default : Boolean(false)","title":".parsers.arm.AllowAdvancedAnalysis"},{"location":"engines-configuration.html#parsersarmanalysisstyle","text":"Description : Native analysis style: 0 = forced conservative analysis 1 = automatic mode (depends on the file) 2 = forced aggressive analysis 3 = forced lazy analysis 4 = forced lazy no data analysis Type and Default : Integer(1){0-4}","title":".parsers.arm.AnalysisStyle"},{"location":"engines-configuration.html#parsersarmdebuginformationretrievalpolicy","text":"Description : Policy regarding the retrieval of externally-stored debugging and symbolic information of code objects: 0 = never attempt 1 = retrieve locally stored external symbols 2 = attempt to retrieve locally and network-stored symbols Locations are architecture- and code object- dependent and may be customized via environment variables. Refer to the manual for additional documentation. Type and Default : Integer(2){0-2}","title":".parsers.arm.DebugInformationRetrievalPolicy"},{"location":"engines-configuration.html#parsersarmdebuginformationusagepolicy","text":"Description : Apply and use debug information to improve analysis accuracy (on a best-effort basis): 0 = never use debug information 1 = use internal debug information only 2 = use all available (internal and external) debug information Type and Default : Integer(1){0-2}","title":".parsers.arm.DebugInformationUsagePolicy"},{"location":"engines-configuration.html#parsersarmidentifiedcompiler","text":"Description : Identified compiler: 0 = automatic identification (depends on the file) 1 = unknown compiler 2 = generic Linux compiler 3 = Android ART 4 = Android NDK 5 = generic Windows compiler 6 = Microsoft Visual C++ Type and Default : Integer(0){0-6}","title":".parsers.arm.IdentifiedCompiler"},{"location":"engines-configuration.html#parsersarmperformclassrecovery","text":"Description : Attempt C++ class discovery and rebuilding (limited to MSVC-compiled x86 executables for now) Type and Default : Boolean(false)","title":".parsers.arm.PerformClassRecovery"},{"location":"engines-configuration.html#parsersarmperformglobalanalysis","text":"Description : Global analysis passes are optional passes provided by specific decompiler modules. They may allow recovery of complex artifacts, such as classes or modules. Type and Default : Boolean(false)","title":".parsers.arm.PerformGlobalAnalysis"},{"location":"engines-configuration.html#parsersarmperformrttirecovery","text":"Description : Attempt C++ Run-Time Type Information (RTTI) discovery and rebuilding (MSVC and Itanium (GCC/CLANG/NDK) are supported) Type and Default : Boolean(true)","title":".parsers.arm.PerformRttiRecovery"},{"location":"engines-configuration.html#parsersarmprefersynchronousexecution","text":"Description : Synchronous analysis prevents access to the unit during a code analysis Type and Default : Boolean(false)","title":".parsers.arm.PreferSynchronousExecution"},{"location":"engines-configuration.html#parsersarmtailcallanalysisstyle","text":"Description : Search for possible tail calls optimized as branches, and build proper routines. Possible modes: 0 = deactivated 1 = automatic mode (heuristics depend on the file) 2 = safe heuristics only 3 = aggressive heuristics Type and Default : Integer(1){0-3}","title":".parsers.arm.TailCallAnalysisStyle"},{"location":"engines-configuration.html#parsersarmwantedendianness","text":"Description : Desired endianness for raw binaries: 'little'/'le', 'big'/'be'. May be overridden by the code parser. Type and Default : String(\"le\")","title":".parsers.arm.WantedEndianness"},{"location":"engines-configuration.html#parsersarmwantedimagebase","text":"Description : Desired memory base address for raw binaries. 0 by default. Type and Default : String(\"0\")","title":".parsers.arm.WantedImageBase"},{"location":"engines-configuration.html#parsersarmtextblockxrefscount","text":"Description : Maximum number of cross-references displayed at any address Type and Default : Integer(50)","title":".parsers.arm.text.BlockXrefsCount"},{"location":"engines-configuration.html#parsersarmtextcharbreak64bitaddresses","text":"Description : If not empty, the address column will display 64-bit addresses as two 8-hexdigit parts, separated by the provided character string Type and Default : String(\"'\")","title":".parsers.arm.text.CharBreak64BitAddresses"},{"location":"engines-configuration.html#parsersarmtextgappreferrawformatting","text":"Description : Prefer raw formatting (dr XX, dr XXXX) for gaps and slack spaces instead of regular declarations (eg, db ??) Type and Default : Boolean(false)","title":".parsers.arm.text.GapPreferRawFormatting"},{"location":"engines-configuration.html#parsersarmtextgaprawbytesperline","text":"Description : For raw formatting, determine the maximum number of bytes per line in gaps and slack spaces. Must be a power of 2, else reverts to the default. Type and Default : Integer(16){0+}","title":".parsers.arm.text.GapRawBytesPerLine"},{"location":"engines-configuration.html#parsersarmtextgaprawintegersize","text":"Description : For raw formatting, determine the integer length (in bytes) used for rendering. Must be either 1, 2, 4, or 8, else reverts to the default Type and Default : Integer(1){0+}","title":".parsers.arm.text.GapRawIntegerSize"},{"location":"engines-configuration.html#parsersarmtextinstructionarealength","text":"Description : Length in characters of the assembly column containing the instructions Type and Default : Integer(40){0+}","title":".parsers.arm.text.InstructionAreaLength"},{"location":"engines-configuration.html#parsersarmtextlabelarealength","text":"Description : Length in characters of the assembly column containing the labels Type and Default : Integer(16){0+}","title":".parsers.arm.text.LabelAreaLength"},{"location":"engines-configuration.html#parsersarmtextroutineseparatorlength","text":"Description : Number of characters used to build the line separating routines Type and Default : Integer(80){0+}","title":".parsers.arm.text.RoutineSeparatorLength"},{"location":"engines-configuration.html#parsersarmtextshowaddresses","text":"Description : Display addresses of items Type and Default : Boolean(true)","title":".parsers.arm.text.ShowAddresses"},{"location":"engines-configuration.html#parsersarmtextshowbytescount","text":"Description : Maximum count of instruction bytes to be displayed before the instruction Type and Default : Integer(0){0+}","title":".parsers.arm.text.ShowBytesCount"},{"location":"engines-configuration.html#parsersarmtextshowsegmentheaders","text":"Description : Display the segment or section headers Type and Default : Boolean(true)","title":".parsers.arm.text.ShowSegmentHeaders"},{"location":"engines-configuration.html#parsersarmtextshowspacebetweenblocks","text":"Description : Insert blank lines between basic blocks Type and Default : Boolean(false)","title":".parsers.arm.text.ShowSpaceBetweenBlocks"},{"location":"engines-configuration.html#parsersarm64advancedanalysisroutinecountwarning","text":"Description : If the standard analysis yields more routines that this provided threshold, then the user will be prompted for confirmation before starting the optional advanced analysis pass (and subsequent passes). Type and Default : Integer(200){0+}","title":".parsers.arm64.AdvancedAnalysisRoutineCountWarning"},{"location":"engines-configuration.html#parsersarm64allowadvancedanalysis","text":"Description : The advanced analysis is an optional analysis pass that comes after the initial standard analysis. It permits discovery of indirect dispatch, therefore providing better routine discovery coverage, and partial resolution of register values. Type and Default : Boolean(false)","title":".parsers.arm64.AllowAdvancedAnalysis"},{"location":"engines-configuration.html#parsersarm64analysisstyle","text":"Description : Native analysis style: 0 = forced conservative analysis 1 = automatic mode (depends on the file) 2 = forced aggressive analysis 3 = forced lazy analysis 4 = forced lazy no data analysis Type and Default : Integer(1){0-4}","title":".parsers.arm64.AnalysisStyle"},{"location":"engines-configuration.html#parsersarm64debuginformationretrievalpolicy","text":"Description : Policy regarding the retrieval of externally-stored debugging and symbolic information of code objects: 0 = never attempt 1 = retrieve locally stored external symbols 2 = attempt to retrieve locally and network-stored symbols Locations are architecture- and code object- dependent and may be customized via environment variables. Refer to the manual for additional documentation. Type and Default : Integer(2){0-2}","title":".parsers.arm64.DebugInformationRetrievalPolicy"},{"location":"engines-configuration.html#parsersarm64debuginformationusagepolicy","text":"Description : Apply and use debug information to improve analysis accuracy (on a best-effort basis): 0 = never use debug information 1 = use internal debug information only 2 = use all available (internal and external) debug information Type and Default : Integer(1){0-2}","title":".parsers.arm64.DebugInformationUsagePolicy"},{"location":"engines-configuration.html#parsersarm64identifiedcompiler","text":"Description : Identified compiler: 0 = automatic identification (depends on the file) 1 = unknown compiler 2 = generic Linux compiler 3 = Android ART 4 = Android NDK 5 = generic Windows compiler 6 = Microsoft Visual C++ Type and Default : Integer(0){0-6}","title":".parsers.arm64.IdentifiedCompiler"},{"location":"engines-configuration.html#parsersarm64performclassrecovery","text":"Description : Attempt C++ class discovery and rebuilding (limited to MSVC-compiled x86 executables for now) Type and Default : Boolean(false)","title":".parsers.arm64.PerformClassRecovery"},{"location":"engines-configuration.html#parsersarm64performglobalanalysis","text":"Description : Global analysis passes are optional passes provided by specific decompiler modules. They may allow recovery of complex artifacts, such as classes or modules. Type and Default : Boolean(false)","title":".parsers.arm64.PerformGlobalAnalysis"},{"location":"engines-configuration.html#parsersarm64performrttirecovery","text":"Description : Attempt C++ Run-Time Type Information (RTTI) discovery and rebuilding (MSVC and Itanium (GCC/CLANG/NDK) are supported) Type and Default : Boolean(true)","title":".parsers.arm64.PerformRttiRecovery"},{"location":"engines-configuration.html#parsersarm64prefersynchronousexecution","text":"Description : Synchronous analysis prevents access to the unit during a code analysis Type and Default : Boolean(false)","title":".parsers.arm64.PreferSynchronousExecution"},{"location":"engines-configuration.html#parsersarm64tailcallanalysisstyle","text":"Description : Search for possible tail calls optimized as branches, and build proper routines. Possible modes: 0 = deactivated 1 = automatic mode (heuristics depend on the file) 2 = safe heuristics only 3 = aggressive heuristics Type and Default : Integer(1){0-3}","title":".parsers.arm64.TailCallAnalysisStyle"},{"location":"engines-configuration.html#parsersarm64wantedendianness","text":"Description : Desired endianness for raw binaries: 'little'/'le', 'big'/'be'. May be overridden by the code parser. Type and Default : String(\"le\")","title":".parsers.arm64.WantedEndianness"},{"location":"engines-configuration.html#parsersarm64wantedimagebase","text":"Description : Desired memory base address for raw binaries. 0 by default. Type and Default : String(\"0\")","title":".parsers.arm64.WantedImageBase"},{"location":"engines-configuration.html#parsersarm64textblockxrefscount","text":"Description : Maximum number of cross-references displayed at any address Type and Default : Integer(50)","title":".parsers.arm64.text.BlockXrefsCount"},{"location":"engines-configuration.html#parsersarm64textcharbreak64bitaddresses","text":"Description : If not empty, the address column will display 64-bit addresses as two 8-hexdigit parts, separated by the provided character string Type and Default : String(\"'\")","title":".parsers.arm64.text.CharBreak64BitAddresses"},{"location":"engines-configuration.html#parsersarm64textgappreferrawformatting","text":"Description : Prefer raw formatting (dr XX, dr XXXX) for gaps and slack spaces instead of regular declarations (eg, db ??) Type and Default : Boolean(false)","title":".parsers.arm64.text.GapPreferRawFormatting"},{"location":"engines-configuration.html#parsersarm64textgaprawbytesperline","text":"Description : For raw formatting, determine the maximum number of bytes per line in gaps and slack spaces. Must be a power of 2, else reverts to the default. Type and Default : Integer(16){0+}","title":".parsers.arm64.text.GapRawBytesPerLine"},{"location":"engines-configuration.html#parsersarm64textgaprawintegersize","text":"Description : For raw formatting, determine the integer length (in bytes) used for rendering. Must be either 1, 2, 4, or 8, else reverts to the default Type and Default : Integer(1){0+}","title":".parsers.arm64.text.GapRawIntegerSize"},{"location":"engines-configuration.html#parsersarm64textinstructionarealength","text":"Description : Length in characters of the assembly column containing the instructions Type and Default : Integer(40){0+}","title":".parsers.arm64.text.InstructionAreaLength"},{"location":"engines-configuration.html#parsersarm64textlabelarealength","text":"Description : Length in characters of the assembly column containing the labels Type and Default : Integer(16){0+}","title":".parsers.arm64.text.LabelAreaLength"},{"location":"engines-configuration.html#parsersarm64textroutineseparatorlength","text":"Description : Number of characters used to build the line separating routines Type and Default : Integer(80){0+}","title":".parsers.arm64.text.RoutineSeparatorLength"},{"location":"engines-configuration.html#parsersarm64textshowaddresses","text":"Description : Display addresses of items Type and Default : Boolean(true)","title":".parsers.arm64.text.ShowAddresses"},{"location":"engines-configuration.html#parsersarm64textshowbytescount","text":"Description : Maximum count of instruction bytes to be displayed before the instruction Type and Default : Integer(0){0+}","title":".parsers.arm64.text.ShowBytesCount"},{"location":"engines-configuration.html#parsersarm64textshowsegmentheaders","text":"Description : Display the segment or section headers Type and Default : Boolean(true)","title":".parsers.arm64.text.ShowSegmentHeaders"},{"location":"engines-configuration.html#parsersarm64textshowspacebetweenblocks","text":"Description : Insert blank lines between basic blocks Type and Default : Boolean(false)","title":".parsers.arm64.text.ShowSpaceBetweenBlocks"},{"location":"engines-configuration.html#parsersarmt32advancedanalysisroutinecountwarning","text":"Description : If the standard analysis yields more routines that this provided threshold, then the user will be prompted for confirmation before starting the optional advanced analysis pass (and subsequent passes). Type and Default : Integer(200){0+}","title":".parsers.armT32.AdvancedAnalysisRoutineCountWarning"},{"location":"engines-configuration.html#parsersarmt32allowadvancedanalysis","text":"Description : The advanced analysis is an optional analysis pass that comes after the initial standard analysis. It permits discovery of indirect dispatch, therefore providing better routine discovery coverage, and partial resolution of register values. Type and Default : Boolean(false)","title":".parsers.armT32.AllowAdvancedAnalysis"},{"location":"engines-configuration.html#parsersarmt32analysisstyle","text":"Description : Native analysis style: 0 = forced conservative analysis 1 = automatic mode (depends on the file) 2 = forced aggressive analysis 3 = forced lazy analysis 4 = forced lazy no data analysis Type and Default : Integer(1){0-4}","title":".parsers.armT32.AnalysisStyle"},{"location":"engines-configuration.html#parsersarmt32debuginformationretrievalpolicy","text":"Description : Policy regarding the retrieval of externally-stored debugging and symbolic information of code objects: 0 = never attempt 1 = retrieve locally stored external symbols 2 = attempt to retrieve locally and network-stored symbols Locations are architecture- and code object- dependent and may be customized via environment variables. Refer to the manual for additional documentation. Type and Default : Integer(2){0-2}","title":".parsers.armT32.DebugInformationRetrievalPolicy"},{"location":"engines-configuration.html#parsersarmt32debuginformationusagepolicy","text":"Description : Apply and use debug information to improve analysis accuracy (on a best-effort basis): 0 = never use debug information 1 = use internal debug information only 2 = use all available (internal and external) debug information Type and Default : Integer(1){0-2}","title":".parsers.armT32.DebugInformationUsagePolicy"},{"location":"engines-configuration.html#parsersarmt32identifiedcompiler","text":"Description : Identified compiler: 0 = automatic identification (depends on the file) 1 = unknown compiler 2 = generic Linux compiler 3 = Android ART 4 = Android NDK 5 = generic Windows compiler 6 = Microsoft Visual C++ Type and Default : Integer(0){0-6}","title":".parsers.armT32.IdentifiedCompiler"},{"location":"engines-configuration.html#parsersarmt32performclassrecovery","text":"Description : Attempt C++ class discovery and rebuilding (limited to MSVC-compiled x86 executables for now) Type and Default : Boolean(false)","title":".parsers.armT32.PerformClassRecovery"},{"location":"engines-configuration.html#parsersarmt32performglobalanalysis","text":"Description : Global analysis passes are optional passes provided by specific decompiler modules. They may allow recovery of complex artifacts, such as classes or modules. Type and Default : Boolean(false)","title":".parsers.armT32.PerformGlobalAnalysis"},{"location":"engines-configuration.html#parsersarmt32performrttirecovery","text":"Description : Attempt C++ Run-Time Type Information (RTTI) discovery and rebuilding (MSVC and Itanium (GCC/CLANG/NDK) are supported) Type and Default : Boolean(true)","title":".parsers.armT32.PerformRttiRecovery"},{"location":"engines-configuration.html#parsersarmt32prefersynchronousexecution","text":"Description : Synchronous analysis prevents access to the unit during a code analysis Type and Default : Boolean(false)","title":".parsers.armT32.PreferSynchronousExecution"},{"location":"engines-configuration.html#parsersarmt32tailcallanalysisstyle","text":"Description : Search for possible tail calls optimized as branches, and build proper routines. Possible modes: 0 = deactivated 1 = automatic mode (heuristics depend on the file) 2 = safe heuristics only 3 = aggressive heuristics Type and Default : Integer(1){0-3}","title":".parsers.armT32.TailCallAnalysisStyle"},{"location":"engines-configuration.html#parsersarmt32wantedendianness","text":"Description : Desired endianness for raw binaries: 'little'/'le', 'big'/'be'. May be overridden by the code parser. Type and Default : String(\"le\")","title":".parsers.armT32.WantedEndianness"},{"location":"engines-configuration.html#parsersarmt32wantedimagebase","text":"Description : Desired memory base address for raw binaries. 0 by default. Type and Default : String(\"0\")","title":".parsers.armT32.WantedImageBase"},{"location":"engines-configuration.html#parsersarmt32textblockxrefscount","text":"Description : Maximum number of cross-references displayed at any address Type and Default : Integer(50)","title":".parsers.armT32.text.BlockXrefsCount"},{"location":"engines-configuration.html#parsersarmt32textcharbreak64bitaddresses","text":"Description : If not empty, the address column will display 64-bit addresses as two 8-hexdigit parts, separated by the provided character string Type and Default : String(\"'\")","title":".parsers.armT32.text.CharBreak64BitAddresses"},{"location":"engines-configuration.html#parsersarmt32textgappreferrawformatting","text":"Description : Prefer raw formatting (dr XX, dr XXXX) for gaps and slack spaces instead of regular declarations (eg, db ??) Type and Default : Boolean(false)","title":".parsers.armT32.text.GapPreferRawFormatting"},{"location":"engines-configuration.html#parsersarmt32textgaprawbytesperline","text":"Description : For raw formatting, determine the maximum number of bytes per line in gaps and slack spaces. Must be a power of 2, else reverts to the default. Type and Default : Integer(16){0+}","title":".parsers.armT32.text.GapRawBytesPerLine"},{"location":"engines-configuration.html#parsersarmt32textgaprawintegersize","text":"Description : For raw formatting, determine the integer length (in bytes) used for rendering. Must be either 1, 2, 4, or 8, else reverts to the default Type and Default : Integer(1){0+}","title":".parsers.armT32.text.GapRawIntegerSize"},{"location":"engines-configuration.html#parsersarmt32textinstructionarealength","text":"Description : Length in characters of the assembly column containing the instructions Type and Default : Integer(40){0+}","title":".parsers.armT32.text.InstructionAreaLength"},{"location":"engines-configuration.html#parsersarmt32textlabelarealength","text":"Description : Length in characters of the assembly column containing the labels Type and Default : Integer(16){0+}","title":".parsers.armT32.text.LabelAreaLength"},{"location":"engines-configuration.html#parsersarmt32textroutineseparatorlength","text":"Description : Number of characters used to build the line separating routines Type and Default : Integer(80){0+}","title":".parsers.armT32.text.RoutineSeparatorLength"},{"location":"engines-configuration.html#parsersarmt32textshowaddresses","text":"Description : Display addresses of items Type and Default : Boolean(true)","title":".parsers.armT32.text.ShowAddresses"},{"location":"engines-configuration.html#parsersarmt32textshowbytescount","text":"Description : Maximum count of instruction bytes to be displayed before the instruction Type and Default : Integer(0){0+}","title":".parsers.armT32.text.ShowBytesCount"},{"location":"engines-configuration.html#parsersarmt32textshowsegmentheaders","text":"Description : Display the segment or section headers Type and Default : Boolean(true)","title":".parsers.armT32.text.ShowSegmentHeaders"},{"location":"engines-configuration.html#parsersarmt32textshowspacebetweenblocks","text":"Description : Insert blank lines between basic blocks Type and Default : Boolean(false)","title":".parsers.armT32.text.ShowSpaceBetweenBlocks"},{"location":"engines-configuration.html#parsersavradvancedanalysisroutinecountwarning","text":"Description : If the standard analysis yields more routines that this provided threshold, then the user will be prompted for confirmation before starting the optional advanced analysis pass (and subsequent passes). Type and Default : Integer(200){0+}","title":".parsers.avr.AdvancedAnalysisRoutineCountWarning"},{"location":"engines-configuration.html#parsersavrallowadvancedanalysis","text":"Description : The advanced analysis is an optional analysis pass that comes after the initial standard analysis. It permits discovery of indirect dispatch, therefore providing better routine discovery coverage, and partial resolution of register values. Type and Default : Boolean(false)","title":".parsers.avr.AllowAdvancedAnalysis"},{"location":"engines-configuration.html#parsersavranalysisstyle","text":"Description : Native analysis style: 0 = forced conservative analysis 1 = automatic mode (depends on the file) 2 = forced aggressive analysis 3 = forced lazy analysis 4 = forced lazy no data analysis Type and Default : Integer(1){0-4}","title":".parsers.avr.AnalysisStyle"},{"location":"engines-configuration.html#parsersavrdebuginformationretrievalpolicy","text":"Description : Policy regarding the retrieval of externally-stored debugging and symbolic information of code objects: 0 = never attempt 1 = retrieve locally stored external symbols 2 = attempt to retrieve locally and network-stored symbols Locations are architecture- and code object- dependent and may be customized via environment variables. Refer to the manual for additional documentation. Type and Default : Integer(2){0-2}","title":".parsers.avr.DebugInformationRetrievalPolicy"},{"location":"engines-configuration.html#parsersavrdebuginformationusagepolicy","text":"Description : Apply and use debug information to improve analysis accuracy (on a best-effort basis): 0 = never use debug information 1 = use internal debug information only 2 = use all available (internal and external) debug information Type and Default : Integer(1){0-2}","title":".parsers.avr.DebugInformationUsagePolicy"},{"location":"engines-configuration.html#parsersavridentifiedcompiler","text":"Description : Identified compiler: 0 = automatic identification (depends on the file) 1 = unknown compiler 2 = generic Linux compiler 3 = Android ART 4 = Android NDK 5 = generic Windows compiler 6 = Microsoft Visual C++ Type and Default : Integer(0){0-6}","title":".parsers.avr.IdentifiedCompiler"},{"location":"engines-configuration.html#parsersavrperformclassrecovery","text":"Description : Attempt C++ class discovery and rebuilding (limited to MSVC-compiled x86 executables for now) Type and Default : Boolean(false)","title":".parsers.avr.PerformClassRecovery"},{"location":"engines-configuration.html#parsersavrperformglobalanalysis","text":"Description : Global analysis passes are optional passes provided by specific decompiler modules. They may allow recovery of complex artifacts, such as classes or modules. Type and Default : Boolean(false)","title":".parsers.avr.PerformGlobalAnalysis"},{"location":"engines-configuration.html#parsersavrperformrttirecovery","text":"Description : Attempt C++ Run-Time Type Information (RTTI) discovery and rebuilding (MSVC and Itanium (GCC/CLANG/NDK) are supported) Type and Default : Boolean(true)","title":".parsers.avr.PerformRttiRecovery"},{"location":"engines-configuration.html#parsersavrprefersynchronousexecution","text":"Description : Synchronous analysis prevents access to the unit during a code analysis Type and Default : Boolean(false)","title":".parsers.avr.PreferSynchronousExecution"},{"location":"engines-configuration.html#parsersavrtailcallanalysisstyle","text":"Description : Search for possible tail calls optimized as branches, and build proper routines. Possible modes: 0 = deactivated 1 = automatic mode (heuristics depend on the file) 2 = safe heuristics only 3 = aggressive heuristics Type and Default : Integer(1){0-3}","title":".parsers.avr.TailCallAnalysisStyle"},{"location":"engines-configuration.html#parsersavrwantedendianness","text":"Description : Desired endianness for raw binaries: 'little'/'le', 'big'/'be'. May be overridden by the code parser. Type and Default : String(\"le\")","title":".parsers.avr.WantedEndianness"},{"location":"engines-configuration.html#parsersavrwantedimagebase","text":"Description : Desired memory base address for raw binaries. 0 by default. Type and Default : String(\"0\")","title":".parsers.avr.WantedImageBase"},{"location":"engines-configuration.html#parsersavrtextblockxrefscount","text":"Description : Maximum number of cross-references displayed at any address Type and Default : Integer(50)","title":".parsers.avr.text.BlockXrefsCount"},{"location":"engines-configuration.html#parsersavrtextcharbreak64bitaddresses","text":"Description : If not empty, the address column will display 64-bit addresses as two 8-hexdigit parts, separated by the provided character string Type and Default : String(\"'\")","title":".parsers.avr.text.CharBreak64BitAddresses"},{"location":"engines-configuration.html#parsersavrtextgappreferrawformatting","text":"Description : Prefer raw formatting (dr XX, dr XXXX) for gaps and slack spaces instead of regular declarations (eg, db ??) Type and Default : Boolean(false)","title":".parsers.avr.text.GapPreferRawFormatting"},{"location":"engines-configuration.html#parsersavrtextgaprawbytesperline","text":"Description : For raw formatting, determine the maximum number of bytes per line in gaps and slack spaces. Must be a power of 2, else reverts to the default. Type and Default : Integer(16){0+}","title":".parsers.avr.text.GapRawBytesPerLine"},{"location":"engines-configuration.html#parsersavrtextgaprawintegersize","text":"Description : For raw formatting, determine the integer length (in bytes) used for rendering. Must be either 1, 2, 4, or 8, else reverts to the default Type and Default : Integer(1){0+}","title":".parsers.avr.text.GapRawIntegerSize"},{"location":"engines-configuration.html#parsersavrtextinstructionarealength","text":"Description : Length in characters of the assembly column containing the instructions Type and Default : Integer(40){0+}","title":".parsers.avr.text.InstructionAreaLength"},{"location":"engines-configuration.html#parsersavrtextlabelarealength","text":"Description : Length in characters of the assembly column containing the labels Type and Default : Integer(16){0+}","title":".parsers.avr.text.LabelAreaLength"},{"location":"engines-configuration.html#parsersavrtextroutineseparatorlength","text":"Description : Number of characters used to build the line separating routines Type and Default : Integer(80){0+}","title":".parsers.avr.text.RoutineSeparatorLength"},{"location":"engines-configuration.html#parsersavrtextshowaddresses","text":"Description : Display addresses of items Type and Default : Boolean(true)","title":".parsers.avr.text.ShowAddresses"},{"location":"engines-configuration.html#parsersavrtextshowbytescount","text":"Description : Maximum count of instruction bytes to be displayed before the instruction Type and Default : Integer(0){0+}","title":".parsers.avr.text.ShowBytesCount"},{"location":"engines-configuration.html#parsersavrtextshowsegmentheaders","text":"Description : Display the segment or section headers Type and Default : Boolean(true)","title":".parsers.avr.text.ShowSegmentHeaders"},{"location":"engines-configuration.html#parsersavrtextshowspacebetweenblocks","text":"Description : Insert blank lines between basic blocks Type and Default : Boolean(false)","title":".parsers.avr.text.ShowSpaceBetweenBlocks"},{"location":"engines-configuration.html#parsersdbug_apkattachportrangesize","text":"Description : Number of ports to try after the preferred port if the preferred port is in useby another program Type and Default : Integer(20){1-100}","title":".parsers.dbug_apk.AttachPortRangeSize"},{"location":"engines-configuration.html#parsersdbug_apkattachportrangestart","text":"Description : Preferred TCP port to use and listen to when attaching to the JDWP debugger Type and Default : Integer(8900){1024-65535}","title":".parsers.dbug_apk.AttachPortRangeStart"},{"location":"engines-configuration.html#parsersdbug_apkblockingquerytimeoutseconds","text":"Description : Maximum time in seconds to wait for a response from the debugger server Type and Default : Integer(15){0+}","title":".parsers.dbug_apk.BlockingQueryTimeoutSeconds"},{"location":"engines-configuration.html#parsersdbug_apknativeattachportrangesize","text":"Description : Number of ports to try after the preferred port if the preferred port is in useby another program Type and Default : Integer(20){1-100}","title":".parsers.dbug_apk.NativeAttachPortRangeSize"},{"location":"engines-configuration.html#parsersdbug_apknativeattachportrangestart","text":"Description : Preferred TCP port to use and listen to when attaching to the native debugger Type and Default : Integer(8950){1024-65535}","title":".parsers.dbug_apk.NativeAttachPortRangeStart"},{"location":"engines-configuration.html#parsersdbug_apkpreferlldbserver","text":"Description : Prefer the use of LLDB server over GDB server for debugging native Android code. Type and Default : Boolean(true)","title":".parsers.dbug_apk.PreferLldbserver"},{"location":"engines-configuration.html#parsersdbug_apkpreferredgdbserverversion","text":"Description : Preferred GDB server version to use. JEB does not ship with all versions of GDB server for all platforms. See the core/assets/ folder in your jeb.jar software archive.It is recommended to use the default. Type and Default : String(\"\")","title":".parsers.dbug_apk.PreferredGdbserverVersion"},{"location":"engines-configuration.html#parsersdbug_apkpreferredlldbserverversion","text":"Description : Preferred LLDB server version to use. JEB does not ship with all versions of LLDB server for all platforms. See the core/assets/ folder in your jeb.jar software archive.It is recommended to use the default. Type and Default : String(\"\")","title":".parsers.dbug_apk.PreferredLldbserverVersion"},{"location":"engines-configuration.html#parsersdbug_apkusenativedebugger","text":"Description : If the client does not provide this information, this setting is used to determine whether the native debugger should be used as well. Use AUTO to let JEB choose (which will result in a yes if and only if a native library folder containing SO files exist), else use ALWAYS or NEVER. Type and Default : String(\"NEVER\")","title":".parsers.dbug_apk.UseNativeDebugger"},{"location":"engines-configuration.html#parsersdbug_elfblockingquerytimeoutseconds","text":"Description : Maximum time in seconds to wait for a response from the debugger server Type and Default : Integer(15){0+}","title":".parsers.dbug_elf.BlockingQueryTimeoutSeconds"},{"location":"engines-configuration.html#parsersdcmp_armastoptimizermaxruncount","text":"Description : Determine how many passes the AST optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(20)","title":".parsers.dcmp_arm.ASTOptimizerMaxRunCount"},{"location":"engines-configuration.html#parsersdcmp_armfailonpipelineerror","text":"Description : Determine whether or not an exception should be thrown on decompilation error. If not, the error will be visible as a comment in the decompiled code output Type and Default : Boolean(true)","title":".parsers.dcmp_arm.FailOnPipelineError"},{"location":"engines-configuration.html#parsersdcmp_armiroptimizerdisableaggressivepass","text":"Description : Disable aggressive IR optimization pass, normally scheduled to run in later IR lifting stages. This pass is used to remove unused out-reaching variables. Type and Default : Boolean(false)","title":".parsers.dcmp_arm.IROptimizerDisableAggressivePass"},{"location":"engines-configuration.html#parsersdcmp_armiroptimizermaxruncount","text":"Description : Determine how many passes the IR optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(5)","title":".parsers.dcmp_arm.IROptimizerMaxRunCount"},{"location":"engines-configuration.html#parsersdcmp_armmemoryresolutionpolicy","text":"Description : A resolution policy guides the memory resolver in terms of what memory dereferences can be directly resolved. Supported policy values are: 0: forbidden (no resolution allowed) 1: allowed if reading takes place in read-only area, and points to a defined item 2: #1 + allowed if reading takes place from \"special\" code object areas (eg, ELF's global offset table) and points to a defined item 3: #1 + allowed if reading takes place from \"special\" code object areas (eg, ELF's global offset table) 100: allowed from any area and points to a defined item 200: allowed from any area Type and Default : Integer(2)","title":".parsers.dcmp_arm.MemoryResolutionPolicy"},{"location":"engines-configuration.html#parsersdcmp_armreconversionmaxcount","text":"Description : Maximum decompilation pipeline restart (reconversion) allowed for a routine Type and Default : Integer(2){0+}","title":".parsers.dcmp_arm.ReconversionMaxCount"},{"location":"engines-configuration.html#parsersdcmp_armstructureruseversion","text":"Description : Version of the structurer to use (0 means use the default structuring algorithms - in release mode, default=newest) Type and Default : Integer(2){0-3}","title":".parsers.dcmp_arm.StructurerUseVersion"},{"location":"engines-configuration.html#parsersdcmp_armusefriendlyvariablenames","text":"Description : Let the AST generate friendly identifier names (eg, based on types) instead of generic names Type and Default : Boolean(true)","title":".parsers.dcmp_arm.UseFriendlyVariableNames"},{"location":"engines-configuration.html#parsersdcmp_armusessaform","text":"Description : Let the decompiler convert intermediate form CFG to SSA forms Type and Default : Boolean(false)","title":".parsers.dcmp_arm.UseSSAForm"},{"location":"engines-configuration.html#parsersdcmp_armtextmergeadjacentdefinitions","text":"Description : Merge same type definitions on a single line (eg, int i = 0, j = 1;) Type and Default : Boolean(true)","title":".parsers.dcmp_arm.text.MergeAdjacentDefinitions"},{"location":"engines-configuration.html#parsersdcmp_armtextspaceoutcompounds","text":"Description : Insert blank lines between compounds Type and Default : Boolean(true)","title":".parsers.dcmp_arm.text.SpaceOutCompounds"},{"location":"engines-configuration.html#parsersdcmp_arm64astoptimizermaxruncount","text":"Description : Determine how many passes the AST optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(20)","title":".parsers.dcmp_arm64.ASTOptimizerMaxRunCount"},{"location":"engines-configuration.html#parsersdcmp_arm64failonpipelineerror","text":"Description : Determine whether or not an exception should be thrown on decompilation error. If not, the error will be visible as a comment in the decompiled code output Type and Default : Boolean(true)","title":".parsers.dcmp_arm64.FailOnPipelineError"},{"location":"engines-configuration.html#parsersdcmp_arm64iroptimizerdisableaggressivepass","text":"Description : Disable aggressive IR optimization pass, normally scheduled to run in later IR lifting stages. This pass is used to remove unused out-reaching variables. Type and Default : Boolean(false)","title":".parsers.dcmp_arm64.IROptimizerDisableAggressivePass"},{"location":"engines-configuration.html#parsersdcmp_arm64iroptimizermaxruncount","text":"Description : Determine how many passes the IR optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(5)","title":".parsers.dcmp_arm64.IROptimizerMaxRunCount"},{"location":"engines-configuration.html#parsersdcmp_arm64memoryresolutionpolicy","text":"Description : A resolution policy guides the memory resolver in terms of what memory dereferences can be directly resolved. Supported policy values are: 0: forbidden (no resolution allowed) 1: allowed if reading takes place in read-only area, and points to a defined item 2: #1 + allowed if reading takes place from \"special\" code object areas (eg, ELF's global offset table) and points to a defined item 3: #1 + allowed if reading takes place from \"special\" code object areas (eg, ELF's global offset table) 100: allowed from any area and points to a defined item 200: allowed from any area Type and Default : Integer(2)","title":".parsers.dcmp_arm64.MemoryResolutionPolicy"},{"location":"engines-configuration.html#parsersdcmp_arm64reconversionmaxcount","text":"Description : Maximum decompilation pipeline restart (reconversion) allowed for a routine Type and Default : Integer(2){0+}","title":".parsers.dcmp_arm64.ReconversionMaxCount"},{"location":"engines-configuration.html#parsersdcmp_arm64structureruseversion","text":"Description : Version of the structurer to use (0 means use the default structuring algorithms - in release mode, default=newest) Type and Default : Integer(2){0-3}","title":".parsers.dcmp_arm64.StructurerUseVersion"},{"location":"engines-configuration.html#parsersdcmp_arm64usefriendlyvariablenames","text":"Description : Let the AST generate friendly identifier names (eg, based on types) instead of generic names Type and Default : Boolean(true)","title":".parsers.dcmp_arm64.UseFriendlyVariableNames"},{"location":"engines-configuration.html#parsersdcmp_arm64usessaform","text":"Description : Let the decompiler convert intermediate form CFG to SSA forms Type and Default : Boolean(false)","title":".parsers.dcmp_arm64.UseSSAForm"},{"location":"engines-configuration.html#parsersdcmp_arm64textmergeadjacentdefinitions","text":"Description : Merge same type definitions on a single line (eg, int i = 0, j = 1;) Type and Default : Boolean(true)","title":".parsers.dcmp_arm64.text.MergeAdjacentDefinitions"},{"location":"engines-configuration.html#parsersdcmp_arm64textspaceoutcompounds","text":"Description : Insert blank lines between compounds Type and Default : Boolean(true)","title":".parsers.dcmp_arm64.text.SpaceOutCompounds"},{"location":"engines-configuration.html#parsersdcmp_avrastoptimizermaxruncount","text":"Description : Determine how many passes the AST optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(20)","title":".parsers.dcmp_avr.ASTOptimizerMaxRunCount"},{"location":"engines-configuration.html#parsersdcmp_avrfailonpipelineerror","text":"Description : Determine whether or not an exception should be thrown on decompilation error. If not, the error will be visible as a comment in the decompiled code output Type and Default : Boolean(true)","title":".parsers.dcmp_avr.FailOnPipelineError"},{"location":"engines-configuration.html#parsersdcmp_avriroptimizerdisableaggressivepass","text":"Description : Disable aggressive IR optimization pass, normally scheduled to run in later IR lifting stages. This pass is used to remove unused out-reaching variables. Type and Default : Boolean(false)","title":".parsers.dcmp_avr.IROptimizerDisableAggressivePass"},{"location":"engines-configuration.html#parsersdcmp_avriroptimizermaxruncount","text":"Description : Determine how many passes the IR optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(5)","title":".parsers.dcmp_avr.IROptimizerMaxRunCount"},{"location":"engines-configuration.html#parsersdcmp_avrmemoryresolutionpolicy","text":"Description : A resolution policy guides the memory resolver in terms of what memory dereferences can be directly resolved. Supported policy values are: 0: forbidden (no resolution allowed) 1: allowed if reading takes place in read-only area, and points to a defined item 2: #1 + allowed if reading takes place from \"special\" code object areas (eg, ELF's global offset table) and points to a defined item 3: #1 + allowed if reading takes place from \"special\" code object areas (eg, ELF's global offset table) 100: allowed from any area and points to a defined item 200: allowed from any area Type and Default : Integer(2)","title":".parsers.dcmp_avr.MemoryResolutionPolicy"},{"location":"engines-configuration.html#parsersdcmp_avrreconversionmaxcount","text":"Description : Maximum decompilation pipeline restart (reconversion) allowed for a routine Type and Default : Integer(2){0+}","title":".parsers.dcmp_avr.ReconversionMaxCount"},{"location":"engines-configuration.html#parsersdcmp_avrstructureruseversion","text":"Description : Version of the structurer to use (0 means use the default structuring algorithms - in release mode, default=newest) Type and Default : Integer(2){0-3}","title":".parsers.dcmp_avr.StructurerUseVersion"},{"location":"engines-configuration.html#parsersdcmp_avrusefriendlyvariablenames","text":"Description : Let the AST generate friendly identifier names (eg, based on types) instead of generic names Type and Default : Boolean(true)","title":".parsers.dcmp_avr.UseFriendlyVariableNames"},{"location":"engines-configuration.html#parsersdcmp_avrusessaform","text":"Description : Let the decompiler convert intermediate form CFG to SSA forms Type and Default : Boolean(false)","title":".parsers.dcmp_avr.UseSSAForm"},{"location":"engines-configuration.html#parsersdcmp_avrtextmergeadjacentdefinitions","text":"Description : Merge same type definitions on a single line (eg, int i = 0, j = 1;) Type and Default : Boolean(true)","title":".parsers.dcmp_avr.text.MergeAdjacentDefinitions"},{"location":"engines-configuration.html#parsersdcmp_avrtextspaceoutcompounds","text":"Description : Insert blank lines between compounds Type and Default : Boolean(true)","title":".parsers.dcmp_avr.text.SpaceOutCompounds"},{"location":"engines-configuration.html#parsersdcmp_dexaggressivesubstitutions","text":"Description : IR optimization: Allow aggressive (potentially unsafe) substitutions Type and Default : Boolean(true)","title":".parsers.dcmp_dex.AggressiveSubstitutions"},{"location":"engines-configuration.html#parsersdcmp_dexemulationsupport","text":"Description : Support for emulation, allowing optimizers to perform complex code cleaning such as decryption: 0: disabled 1: enabled, notify the client to proceed 2: enabled, always proceed Type and Default : Integer(2)","title":".parsers.dcmp_dex.EmulationSupport"},{"location":"engines-configuration.html#parsersdcmp_dexemulatorconfigpath","text":"Description : Path to the emulator configuration file. If the path is relative, the configuration file will be searched in JEB's plugins directory (usually, coreplugins/). Type and Default : Path(\"dexdec-emu.cfg\")","title":".parsers.dcmp_dex.EmulatorConfigPath"},{"location":"engines-configuration.html#parsersdcmp_dexenabledeobfuscators","text":"Description : Enable unsafe deobfuscation optimizers. Those aggressive optimizers can generate code radically different than the underlying bytecode. Type and Default : Boolean(true)","title":".parsers.dcmp_dex.EnableDeobfuscators"},{"location":"engines-configuration.html#parsersdcmp_dexfullcfgsubstitutionsinsncountthreshold","text":"Description : Experimental IR optimization: Allow full-CFG expression propagation for methods having less than threshold instructions (-1 to disable the threshold and enable for all methods regardless of their size) Type and Default : Integer(100)","title":".parsers.dcmp_dex.FullCFGSubstitutionsInsnCountThreshold"},{"location":"engines-configuration.html#parsersdcmp_dexidentifiernamingstrategy","text":"Description : Naming strategy for the identifiers: 0= reflect underlying register usage as much as possible: argN, vN, vN_x 1= derive names from types Type and Default : Integer(0)","title":".parsers.dcmp_dex.IdentifierNamingStrategy"},{"location":"engines-configuration.html#parsersdcmp_dexjarlibraryclasspath","text":"Description : A classpath containing Java classfiles to be used to support the decompiler. Refer to JarLibraryEnabled. If non-empty, this classpath takes precedence over JarLibraryFolder. Type and Default : String(\"\")","title":".parsers.dcmp_dex.JarLibraryClasspath"},{"location":"engines-configuration.html#parsersdcmp_dexjarlibraryenabled","text":"Description : Enable external Java library file parsing. They can be used by the decompiler to achieve better typing (cast reduction). To activate, enable this property and set either one of JarLibraryClasspath or JarLibraryFolder property. Type and Default : Boolean(true)","title":".parsers.dcmp_dex.JarLibraryEnabled"},{"location":"engines-configuration.html#parsersdcmp_dexjarlibraryfolder","text":"Description : A folder containing Jar library files to be used to support the decompiler. Refer to JarLibraryEnabled. The default value (empty) means to use the folder ~/.jeb-android-libraries, which always contains a recent copy of the Android framework (android.jar). You may change the value to point to another folder, or drop additional jars in this folder.Note that JarLibraryClasspath takes precedence over this value. Type and Default : String(\"\")","title":".parsers.dcmp_dex.JarLibraryFolder"},{"location":"engines-configuration.html#parsersdcmp_dexmethoddecompilationtimeout","text":"Description : Maximum time in seconds allowed for a method decompilation (use 0 to specify no time-out) Type and Default : Integer(0){0+}","title":".parsers.dcmp_dex.MethodDecompilationTimeout"},{"location":"engines-configuration.html#parsersdcmp_dexoptimizecreateconditionalassignments","text":"Description : AST optimization: allow condition assignments (using the ternary operator) Type and Default : Boolean(true)","title":".parsers.dcmp_dex.OptimizeCreateConditionalAssignments"},{"location":"engines-configuration.html#parsersdcmp_dexoptimizecreatefinallyblocks","text":"Description : AST optimization: attempt to create try-(catch,multi-catch)-finally blocks. This heuristic is potentially unsafe. Type and Default : Boolean(true)","title":".parsers.dcmp_dex.OptimizeCreateFinallyBlocks"},{"location":"engines-configuration.html#parsersdcmp_dexoptimizecreateforloops","text":"Description : AST optimization: Allow the creation of for-loops Type and Default : Boolean(true)","title":".parsers.dcmp_dex.OptimizeCreateForLoops"},{"location":"engines-configuration.html#parsersdcmp_dexoptimizecreatemultidimarrays","text":"Description : AST optimization: allow the creation of multi-dimensional arrays Type and Default : Boolean(true)","title":".parsers.dcmp_dex.OptimizeCreateMultiDimArrays"},{"location":"engines-configuration.html#parsersdcmp_dexoptimizecreatestringswitches","text":"Description : AST optimization: attempt to create switch-on-strings. This heuristic is potentially unsafe. Type and Default : Boolean(true)","title":".parsers.dcmp_dex.OptimizeCreateStringSwitches"},{"location":"engines-configuration.html#parsersdcmp_dexoptimizecreatesynchronizedblocks","text":"Description : AST optimization: attempt to create synchronized blocks. This heuristic is potentially unsafe. Type and Default : Boolean(true)","title":".parsers.dcmp_dex.OptimizeCreateSynchronizedBlocks"},{"location":"engines-configuration.html#parsersdcmp_dexoptimizecreatevarargs","text":"Description : AST optimization: support the creation of variable-argument methods Type and Default : Boolean(true)","title":".parsers.dcmp_dex.OptimizeCreateVarArgs"},{"location":"engines-configuration.html#parsersdcmp_dexoptimizeinlinesyntheticaccesscalls","text":"Description : AST optimization: Inline calls to accessor (synthetic) methods Type and Default : Boolean(true)","title":".parsers.dcmp_dex.OptimizeInlineSyntheticAccessCalls"},{"location":"engines-configuration.html#parsersdcmp_dexoptimizestringconcatenation","text":"Description : AST optimization: Allow String concatenation Type and Default : Boolean(true)","title":".parsers.dcmp_dex.OptimizeStringConcatenation"},{"location":"engines-configuration.html#parsersdcmp_dexparsedebuginformation","text":"Description : Process debug information. If enabled, debug names can be used to name identifiers. Proceed with caution! DEX metadata is not reliable, it can be forged and/or obfuscated to mislead analysis. Type and Default : Boolean(true)","title":".parsers.dcmp_dex.ParseDebugInformation"},{"location":"engines-configuration.html#parsersdcmp_dexparseexceptionblocks","text":"Description : Parse exception blocks Type and Default : Boolean(true)","title":".parsers.dcmp_dex.ParseExceptionBlocks"},{"location":"engines-configuration.html#parsersdcmp_dexreconstructenums","text":"Description : Discover and rebuild enumerations (and related artifacts such as enumeration-maps). This heuristic is potentially unsafe. Type and Default : Boolean(true)","title":".parsers.dcmp_dex.ReconstructEnums"},{"location":"engines-configuration.html#parsersdcmp_dexreconstructlambdas","text":"Description : Discover and rebuild lambdas (and related higher-order artifacts such as method handles). This heuristic is potentially unsafe. Type and Default : Boolean(true)","title":".parsers.dcmp_dex.ReconstructLambdas"},{"location":"engines-configuration.html#parsersdcmp_dextextdisplaymethodinternalsascomment","text":"Description : When rendering source, prepend method internals as a comment block before rendering the method (0: none, 1: original method signature, 2: signature + flattened AST rendering) Type and Default : Integer(0)","title":".parsers.dcmp_dex.text.DisplayMethodInternalsAsComment"},{"location":"engines-configuration.html#parsersdcmp_dextextdisplayprivatemethodslast","text":"Description : Output private methods last (after public, default and protected methods) Type and Default : Boolean(false)","title":".parsers.dcmp_dex.text.DisplayPrivateMethodsLast"},{"location":"engines-configuration.html#parsersdcmp_dextextgenerateannotations","text":"Description : Generate Java annotations Type and Default : Boolean(true)","title":".parsers.dcmp_dex.text.GenerateAnnotations"},{"location":"engines-configuration.html#parsersdcmp_dextextgeneratelambdas","text":"Description : Favor the generation of lambda functions (Java 8+) if possible. Lambdas must have been reconstructed (engines option) Type and Default : Boolean(true)","title":".parsers.dcmp_dex.text.GenerateLambdas"},{"location":"engines-configuration.html#parsersdcmp_dextextgenerateoverrideannotations","text":"Description : Geneate additional @Override annotations for methods for which super implementations or definitions were found Type and Default : Boolean(true)","title":".parsers.dcmp_dex.text.GenerateOverrideAnnotations"},{"location":"engines-configuration.html#parsersdcmp_dextextgeneratesyntheticfields","text":"Description : Explicitly generate synthetic fields Type and Default : Boolean(false)","title":".parsers.dcmp_dex.text.GenerateSyntheticFields"},{"location":"engines-configuration.html#parsersdcmp_dextextgeneratesyntheticmethods","text":"Description : Explicitly generate synthetic methods Type and Default : Boolean(false)","title":".parsers.dcmp_dex.text.GenerateSyntheticMethods"},{"location":"engines-configuration.html#parsersdcmp_dextextinsertblanklinesaftercompounds","text":"Description : Insert blank lines between compounds Type and Default : Boolean(true)","title":".parsers.dcmp_dex.text.InsertBlankLinesAfterCompounds"},{"location":"engines-configuration.html#parsersdcmp_dextextresolvefieldaccesstargets","text":"Description : Resolve accesses to object and class fields Type and Default : Boolean(true)","title":".parsers.dcmp_dex.text.ResolveFieldAccessTargets"},{"location":"engines-configuration.html#parsersdcmp_dextextresolvemethodcalltargets","text":"Description : Resolve calls to virtual and static methods, possibly offering a list of candidates methods to client code Type and Default : Boolean(true)","title":".parsers.dcmp_dex.text.ResolveMethodCallTargets"},{"location":"engines-configuration.html#parsersdcmp_dextextsortitemsforrendering","text":"Description : Sort class, field and method source items before rendering them (0: no sort (rendered as they appear in native code), 1: alphabetically + access type) Type and Default : Integer(1)","title":".parsers.dcmp_dex.text.SortItemsForRendering"},{"location":"engines-configuration.html#parsersdcmp_dextextusedebuginfonames","text":"Description : Use names located in DEX debug information (if available) Type and Default : Boolean(true)","title":".parsers.dcmp_dex.text.UseDebugInfoNames"},{"location":"engines-configuration.html#parsersdcmp_evmbcastoptimizermaxruncount","text":"Description : Determine how many passes the AST optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(20)","title":".parsers.dcmp_evmbc.ASTOptimizerMaxRunCount"},{"location":"engines-configuration.html#parsersdcmp_evmbcfailonpipelineerror","text":"Description : Determine whether or not an exception should be thrown on decompilation error. If not, the error will be visible as a comment in the decompiled code output Type and Default : Boolean(true)","title":".parsers.dcmp_evmbc.FailOnPipelineError"},{"location":"engines-configuration.html#parsersdcmp_evmbciroptimizerdisableaggressivepass","text":"Description : Disable aggressive IR optimization pass, normally scheduled to run in later IR lifting stages. This pass is used to remove unused out-reaching variables. Type and Default : Boolean(false)","title":".parsers.dcmp_evmbc.IROptimizerDisableAggressivePass"},{"location":"engines-configuration.html#parsersdcmp_evmbciroptimizermaxruncount","text":"Description : Determine how many passes the IR optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(5)","title":".parsers.dcmp_evmbc.IROptimizerMaxRunCount"},{"location":"engines-configuration.html#parsersdcmp_evmbcmemoryresolutionpolicy","text":"Description : A resolution policy guides the memory resolver in terms of what memory dereferences can be directly resolved. Supported policy values are: 0: forbidden (no resolution allowed) 1: allowed if reading takes place in read-only area, and points to a defined item 2: #1 + allowed if reading takes place from \"special\" code object areas (eg, ELF's global offset table) and points to a defined item 3: #1 + allowed if reading takes place from \"special\" code object areas (eg, ELF's global offset table) 100: allowed from any area and points to a defined item 200: allowed from any area Type and Default : Integer(2)","title":".parsers.dcmp_evmbc.MemoryResolutionPolicy"},{"location":"engines-configuration.html#parsersdcmp_evmbcreconversionmaxcount","text":"Description : Maximum decompilation pipeline restart (reconversion) allowed for a routine Type and Default : Integer(2){0+}","title":".parsers.dcmp_evmbc.ReconversionMaxCount"},{"location":"engines-configuration.html#parsersdcmp_evmbcstructureruseversion","text":"Description : Version of the structurer to use (0 means use the default structuring algorithms - in release mode, default=newest) Type and Default : Integer(2){0-3}","title":".parsers.dcmp_evmbc.StructurerUseVersion"},{"location":"engines-configuration.html#parsersdcmp_evmbcusefriendlyvariablenames","text":"Description : Let the AST generate friendly identifier names (eg, based on types) instead of generic names Type and Default : Boolean(false)","title":".parsers.dcmp_evmbc.UseFriendlyVariableNames"},{"location":"engines-configuration.html#parsersdcmp_evmbcusessaform","text":"Description : Let the decompiler convert intermediate form CFG to SSA forms Type and Default : Boolean(false)","title":".parsers.dcmp_evmbc.UseSSAForm"},{"location":"engines-configuration.html#parsersdcmp_evmbctextmergeadjacentdefinitions","text":"Description : Merge same type definitions on a single line (eg, int i = 0, j = 1;) Type and Default : Boolean(true)","title":".parsers.dcmp_evmbc.text.MergeAdjacentDefinitions"},{"location":"engines-configuration.html#parsersdcmp_evmbctextspaceoutcompounds","text":"Description : Insert blank lines between compounds Type and Default : Boolean(true)","title":".parsers.dcmp_evmbc.text.SpaceOutCompounds"},{"location":"engines-configuration.html#parsersdcmp_libravm_bcastoptimizermaxruncount","text":"Description : Determine how many passes the AST optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(20)","title":".parsers.dcmp_libravm_bc.ASTOptimizerMaxRunCount"},{"location":"engines-configuration.html#parsersdcmp_libravm_bcfailonpipelineerror","text":"Description : Determine whether or not an exception should be thrown on decompilation error. If not, the error will be visible as a comment in the decompiled code output Type and Default : Boolean(true)","title":".parsers.dcmp_libravm_bc.FailOnPipelineError"},{"location":"engines-configuration.html#parsersdcmp_libravm_bciroptimizerdisableaggressivepass","text":"Description : Disable aggressive IR optimization pass, normally scheduled to run in later IR lifting stages. This pass is used to remove unused out-reaching variables. Type and Default : Boolean(false)","title":".parsers.dcmp_libravm_bc.IROptimizerDisableAggressivePass"},{"location":"engines-configuration.html#parsersdcmp_libravm_bciroptimizermaxruncount","text":"Description : Determine how many passes the IR optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(5)","title":".parsers.dcmp_libravm_bc.IROptimizerMaxRunCount"},{"location":"engines-configuration.html#parsersdcmp_libravm_bcmemoryresolutionpolicy","text":"Description : A resolution policy guides the memory resolver in terms of what memory dereferences can be directly resolved. Supported policy values are: 0: forbidden (no resolution allowed) 1: allowed if reading takes place in read-only area, and points to a defined item 2: #1 + allowed if reading takes place from \"special\" code object areas (eg, ELF's global offset table) and points to a defined item 3: #1 + allowed if reading takes place from \"special\" code object areas (eg, ELF's global offset table) 100: allowed from any area and points to a defined item 200: allowed from any area Type and Default : Integer(2)","title":".parsers.dcmp_libravm_bc.MemoryResolutionPolicy"},{"location":"engines-configuration.html#parsersdcmp_libravm_bcreconversionmaxcount","text":"Description : Maximum decompilation pipeline restart (reconversion) allowed for a routine Type and Default : Integer(2){0+}","title":".parsers.dcmp_libravm_bc.ReconversionMaxCount"},{"location":"engines-configuration.html#parsersdcmp_libravm_bcstructureruseversion","text":"Description : Version of the structurer to use (0 means use the default structuring algorithms - in release mode, default=newest) Type and Default : Integer(2){0-3}","title":".parsers.dcmp_libravm_bc.StructurerUseVersion"},{"location":"engines-configuration.html#parsersdcmp_libravm_bcusefriendlyvariablenames","text":"Description : Let the AST generate friendly identifier names (eg, based on types) instead of generic names Type and Default : Boolean(false)","title":".parsers.dcmp_libravm_bc.UseFriendlyVariableNames"},{"location":"engines-configuration.html#parsersdcmp_libravm_bcusessaform","text":"Description : Let the decompiler convert intermediate form CFG to SSA forms Type and Default : Boolean(false)","title":".parsers.dcmp_libravm_bc.UseSSAForm"},{"location":"engines-configuration.html#parsersdcmp_libravm_bctextmergeadjacentdefinitions","text":"Description : Merge same type definitions on a single line (eg, int i = 0, j = 1;) Type and Default : Boolean(true)","title":".parsers.dcmp_libravm_bc.text.MergeAdjacentDefinitions"},{"location":"engines-configuration.html#parsersdcmp_libravm_bctextspaceoutcompounds","text":"Description : Insert blank lines between compounds Type and Default : Boolean(true)","title":".parsers.dcmp_libravm_bc.text.SpaceOutCompounds"},{"location":"engines-configuration.html#parsersdcmp_mipsastoptimizermaxruncount","text":"Description : Determine how many passes the AST optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(20)","title":".parsers.dcmp_mips.ASTOptimizerMaxRunCount"},{"location":"engines-configuration.html#parsersdcmp_mipsfailonpipelineerror","text":"Description : Determine whether or not an exception should be thrown on decompilation error. If not, the error will be visible as a comment in the decompiled code output Type and Default : Boolean(true)","title":".parsers.dcmp_mips.FailOnPipelineError"},{"location":"engines-configuration.html#parsersdcmp_mipsiroptimizerdisableaggressivepass","text":"Description : Disable aggressive IR optimization pass, normally scheduled to run in later IR lifting stages. This pass is used to remove unused out-reaching variables. Type and Default : Boolean(false)","title":".parsers.dcmp_mips.IROptimizerDisableAggressivePass"},{"location":"engines-configuration.html#parsersdcmp_mipsiroptimizermaxruncount","text":"Description : Determine how many passes the IR optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(5)","title":".parsers.dcmp_mips.IROptimizerMaxRunCount"},{"location":"engines-configuration.html#parsersdcmp_mipsmemoryresolutionpolicy","text":"Description : A resolution policy guides the memory resolver in terms of what memory dereferences can be directly resolved. Supported policy values are: 0: forbidden (no resolution allowed) 1: allowed if reading takes place in read-only area, and points to a defined item 2: #1 + allowed if reading takes place from \"special\" code object areas (eg, ELF's global offset table) and points to a defined item 3: #1 + allowed if reading takes place from \"special\" code object areas (eg, ELF's global offset table) 100: allowed from any area and points to a defined item 200: allowed from any area Type and Default : Integer(2)","title":".parsers.dcmp_mips.MemoryResolutionPolicy"},{"location":"engines-configuration.html#parsersdcmp_mipsreconversionmaxcount","text":"Description : Maximum decompilation pipeline restart (reconversion) allowed for a routine Type and Default : Integer(2){0+}","title":".parsers.dcmp_mips.ReconversionMaxCount"},{"location":"engines-configuration.html#parsersdcmp_mipsstructureruseversion","text":"Description : Version of the structurer to use (0 means use the default structuring algorithms - in release mode, default=newest) Type and Default : Integer(2){0-3}","title":".parsers.dcmp_mips.StructurerUseVersion"},{"location":"engines-configuration.html#parsersdcmp_mipsusefriendlyvariablenames","text":"Description : Let the AST generate friendly identifier names (eg, based on types) instead of generic names Type and Default : Boolean(true)","title":".parsers.dcmp_mips.UseFriendlyVariableNames"},{"location":"engines-configuration.html#parsersdcmp_mipsusessaform","text":"Description : Let the decompiler convert intermediate form CFG to SSA forms Type and Default : Boolean(false)","title":".parsers.dcmp_mips.UseSSAForm"},{"location":"engines-configuration.html#parsersdcmp_mipstextmergeadjacentdefinitions","text":"Description : Merge same type definitions on a single line (eg, int i = 0, j = 1;) Type and Default : Boolean(true)","title":".parsers.dcmp_mips.text.MergeAdjacentDefinitions"},{"location":"engines-configuration.html#parsersdcmp_mipstextspaceoutcompounds","text":"Description : Insert blank lines between compounds Type and Default : Boolean(true)","title":".parsers.dcmp_mips.text.SpaceOutCompounds"},{"location":"engines-configuration.html#parsersdcmp_mips64astoptimizermaxruncount","text":"Description : Determine how many passes the AST optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(20)","title":".parsers.dcmp_mips64.ASTOptimizerMaxRunCount"},{"location":"engines-configuration.html#parsersdcmp_mips64failonpipelineerror","text":"Description : Determine whether or not an exception should be thrown on decompilation error. If not, the error will be visible as a comment in the decompiled code output Type and Default : Boolean(true)","title":".parsers.dcmp_mips64.FailOnPipelineError"},{"location":"engines-configuration.html#parsersdcmp_mips64iroptimizerdisableaggressivepass","text":"Description : Disable aggressive IR optimization pass, normally scheduled to run in later IR lifting stages. This pass is used to remove unused out-reaching variables. Type and Default : Boolean(false)","title":".parsers.dcmp_mips64.IROptimizerDisableAggressivePass"},{"location":"engines-configuration.html#parsersdcmp_mips64iroptimizermaxruncount","text":"Description : Determine how many passes the IR optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(5)","title":".parsers.dcmp_mips64.IROptimizerMaxRunCount"},{"location":"engines-configuration.html#parsersdcmp_mips64memoryresolutionpolicy","text":"Description : A resolution policy guides the memory resolver in terms of what memory dereferences can be directly resolved. Supported policy values are: 0: forbidden (no resolution allowed) 1: allowed if reading takes place in read-only area, and points to a defined item 2: #1 + allowed if reading takes place from \"special\" code object areas (eg, ELF's global offset table) and points to a defined item 3: #1 + allowed if reading takes place from \"special\" code object areas (eg, ELF's global offset table) 100: allowed from any area and points to a defined item 200: allowed from any area Type and Default : Integer(2)","title":".parsers.dcmp_mips64.MemoryResolutionPolicy"},{"location":"engines-configuration.html#parsersdcmp_mips64reconversionmaxcount","text":"Description : Maximum decompilation pipeline restart (reconversion) allowed for a routine Type and Default : Integer(2){0+}","title":".parsers.dcmp_mips64.ReconversionMaxCount"},{"location":"engines-configuration.html#parsersdcmp_mips64structureruseversion","text":"Description : Version of the structurer to use (0 means use the default structuring algorithms - in release mode, default=newest) Type and Default : Integer(2){0-3}","title":".parsers.dcmp_mips64.StructurerUseVersion"},{"location":"engines-configuration.html#parsersdcmp_mips64usefriendlyvariablenames","text":"Description : Let the AST generate friendly identifier names (eg, based on types) instead of generic names Type and Default : Boolean(true)","title":".parsers.dcmp_mips64.UseFriendlyVariableNames"},{"location":"engines-configuration.html#parsersdcmp_mips64usessaform","text":"Description : Let the decompiler convert intermediate form CFG to SSA forms Type and Default : Boolean(false)","title":".parsers.dcmp_mips64.UseSSAForm"},{"location":"engines-configuration.html#parsersdcmp_mips64textmergeadjacentdefinitions","text":"Description : Merge same type definitions on a single line (eg, int i = 0, j = 1;) Type and Default : Boolean(true)","title":".parsers.dcmp_mips64.text.MergeAdjacentDefinitions"},{"location":"engines-configuration.html#parsersdcmp_mips64textspaceoutcompounds","text":"Description : Insert blank lines between compounds Type and Default : Boolean(true)","title":".parsers.dcmp_mips64.text.SpaceOutCompounds"},{"location":"engines-configuration.html#parsersdcmp_wasmbcastoptimizermaxruncount","text":"Description : Determine how many passes the AST optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(20)","title":".parsers.dcmp_wasmbc.ASTOptimizerMaxRunCount"},{"location":"engines-configuration.html#parsersdcmp_wasmbcfailonpipelineerror","text":"Description : Determine whether or not an exception should be thrown on decompilation error. If not, the error will be visible as a comment in the decompiled code output Type and Default : Boolean(true)","title":".parsers.dcmp_wasmbc.FailOnPipelineError"},{"location":"engines-configuration.html#parsersdcmp_wasmbciroptimizerdisableaggressivepass","text":"Description : Disable aggressive IR optimization pass, normally scheduled to run in later IR lifting stages. This pass is used to remove unused out-reaching variables. Type and Default : Boolean(false)","title":".parsers.dcmp_wasmbc.IROptimizerDisableAggressivePass"},{"location":"engines-configuration.html#parsersdcmp_wasmbciroptimizermaxruncount","text":"Description : Determine how many passes the IR optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(5)","title":".parsers.dcmp_wasmbc.IROptimizerMaxRunCount"},{"location":"engines-configuration.html#parsersdcmp_wasmbcmemoryresolutionpolicy","text":"Description : A resolution policy guides the memory resolver in terms of what memory dereferences can be directly resolved. Supported policy values are: 0: forbidden (no resolution allowed) 1: allowed if reading takes place in read-only area, and points to a defined item 2: #1 + allowed if reading takes place from \"special\" code object areas (eg, ELF's global offset table) and points to a defined item 3: #1 + allowed if reading takes place from \"special\" code object areas (eg, ELF's global offset table) 100: allowed from any area and points to a defined item 200: allowed from any area Type and Default : Integer(2)","title":".parsers.dcmp_wasmbc.MemoryResolutionPolicy"},{"location":"engines-configuration.html#parsersdcmp_wasmbcreconversionmaxcount","text":"Description : Maximum decompilation pipeline restart (reconversion) allowed for a routine Type and Default : Integer(2){0+}","title":".parsers.dcmp_wasmbc.ReconversionMaxCount"},{"location":"engines-configuration.html#parsersdcmp_wasmbcstructureruseversion","text":"Description : Version of the structurer to use (0 means use the default structuring algorithms - in release mode, default=newest) Type and Default : Integer(2){0-3}","title":".parsers.dcmp_wasmbc.StructurerUseVersion"},{"location":"engines-configuration.html#parsersdcmp_wasmbcusefriendlyvariablenames","text":"Description : Let the AST generate friendly identifier names (eg, based on types) instead of generic names Type and Default : Boolean(true)","title":".parsers.dcmp_wasmbc.UseFriendlyVariableNames"},{"location":"engines-configuration.html#parsersdcmp_wasmbcusessaform","text":"Description : Let the decompiler convert intermediate form CFG to SSA forms Type and Default : Boolean(false)","title":".parsers.dcmp_wasmbc.UseSSAForm"},{"location":"engines-configuration.html#parsersdcmp_wasmbctextmergeadjacentdefinitions","text":"Description : Merge same type definitions on a single line (eg, int i = 0, j = 1;) Type and Default : Boolean(true)","title":".parsers.dcmp_wasmbc.text.MergeAdjacentDefinitions"},{"location":"engines-configuration.html#parsersdcmp_wasmbctextspaceoutcompounds","text":"Description : Insert blank lines between compounds Type and Default : Boolean(true)","title":".parsers.dcmp_wasmbc.text.SpaceOutCompounds"},{"location":"engines-configuration.html#parsersdcmp_x86astoptimizermaxruncount","text":"Description : Determine how many passes the AST optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(20)","title":".parsers.dcmp_x86.ASTOptimizerMaxRunCount"},{"location":"engines-configuration.html#parsersdcmp_x86failonpipelineerror","text":"Description : Determine whether or not an exception should be thrown on decompilation error. If not, the error will be visible as a comment in the decompiled code output Type and Default : Boolean(true)","title":".parsers.dcmp_x86.FailOnPipelineError"},{"location":"engines-configuration.html#parsersdcmp_x86iroptimizerdisableaggressivepass","text":"Description : Disable aggressive IR optimization pass, normally scheduled to run in later IR lifting stages. This pass is used to remove unused out-reaching variables. Type and Default : Boolean(false)","title":".parsers.dcmp_x86.IROptimizerDisableAggressivePass"},{"location":"engines-configuration.html#parsersdcmp_x86iroptimizermaxruncount","text":"Description : Determine how many passes the IR optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(5)","title":".parsers.dcmp_x86.IROptimizerMaxRunCount"},{"location":"engines-configuration.html#parsersdcmp_x86memoryresolutionpolicy","text":"Description : A resolution policy guides the memory resolver in terms of what memory dereferences can be directly resolved. Supported policy values are: 0: forbidden (no resolution allowed) 1: allowed if reading takes place in read-only area, and points to a defined item 2: #1 + allowed if reading takes place from \"special\" code object areas (eg, ELF's global offset table) and points to a defined item 3: #1 + allowed if reading takes place from \"special\" code object areas (eg, ELF's global offset table) 100: allowed from any area and points to a defined item 200: allowed from any area Type and Default : Integer(2)","title":".parsers.dcmp_x86.MemoryResolutionPolicy"},{"location":"engines-configuration.html#parsersdcmp_x86reconversionmaxcount","text":"Description : Maximum decompilation pipeline restart (reconversion) allowed for a routine Type and Default : Integer(2){0+}","title":".parsers.dcmp_x86.ReconversionMaxCount"},{"location":"engines-configuration.html#parsersdcmp_x86structureruseversion","text":"Description : Version of the structurer to use (0 means use the default structuring algorithms - in release mode, default=newest) Type and Default : Integer(2){0-3}","title":".parsers.dcmp_x86.StructurerUseVersion"},{"location":"engines-configuration.html#parsersdcmp_x86usefriendlyvariablenames","text":"Description : Let the AST generate friendly identifier names (eg, based on types) instead of generic names Type and Default : Boolean(true)","title":".parsers.dcmp_x86.UseFriendlyVariableNames"},{"location":"engines-configuration.html#parsersdcmp_x86usessaform","text":"Description : Let the decompiler convert intermediate form CFG to SSA forms Type and Default : Boolean(false)","title":".parsers.dcmp_x86.UseSSAForm"},{"location":"engines-configuration.html#parsersdcmp_x86textmergeadjacentdefinitions","text":"Description : Merge same type definitions on a single line (eg, int i = 0, j = 1;) Type and Default : Boolean(true)","title":".parsers.dcmp_x86.text.MergeAdjacentDefinitions"},{"location":"engines-configuration.html#parsersdcmp_x86textspaceoutcompounds","text":"Description : Insert blank lines between compounds Type and Default : Boolean(true)","title":".parsers.dcmp_x86.text.SpaceOutCompounds"},{"location":"engines-configuration.html#parsersdcmp_x86_64astoptimizermaxruncount","text":"Description : Determine how many passes the AST optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(20)","title":".parsers.dcmp_x86_64.ASTOptimizerMaxRunCount"},{"location":"engines-configuration.html#parsersdcmp_x86_64failonpipelineerror","text":"Description : Determine whether or not an exception should be thrown on decompilation error. If not, the error will be visible as a comment in the decompiled code output Type and Default : Boolean(true)","title":".parsers.dcmp_x86_64.FailOnPipelineError"},{"location":"engines-configuration.html#parsersdcmp_x86_64iroptimizerdisableaggressivepass","text":"Description : Disable aggressive IR optimization pass, normally scheduled to run in later IR lifting stages. This pass is used to remove unused out-reaching variables. Type and Default : Boolean(false)","title":".parsers.dcmp_x86_64.IROptimizerDisableAggressivePass"},{"location":"engines-configuration.html#parsersdcmp_x86_64iroptimizermaxruncount","text":"Description : Determine how many passes the IR optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(5)","title":".parsers.dcmp_x86_64.IROptimizerMaxRunCount"},{"location":"engines-configuration.html#parsersdcmp_x86_64memoryresolutionpolicy","text":"Description : A resolution policy guides the memory resolver in terms of what memory dereferences can be directly resolved. Supported policy values are: 0: forbidden (no resolution allowed) 1: allowed if reading takes place in read-only area, and points to a defined item 2: #1 + allowed if reading takes place from \"special\" code object areas (eg, ELF's global offset table) and points to a defined item 3: #1 + allowed if reading takes place from \"special\" code object areas (eg, ELF's global offset table) 100: allowed from any area and points to a defined item 200: allowed from any area Type and Default : Integer(2)","title":".parsers.dcmp_x86_64.MemoryResolutionPolicy"},{"location":"engines-configuration.html#parsersdcmp_x86_64reconversionmaxcount","text":"Description : Maximum decompilation pipeline restart (reconversion) allowed for a routine Type and Default : Integer(2){0+}","title":".parsers.dcmp_x86_64.ReconversionMaxCount"},{"location":"engines-configuration.html#parsersdcmp_x86_64structureruseversion","text":"Description : Version of the structurer to use (0 means use the default structuring algorithms - in release mode, default=newest) Type and Default : Integer(2){0-3}","title":".parsers.dcmp_x86_64.StructurerUseVersion"},{"location":"engines-configuration.html#parsersdcmp_x86_64usefriendlyvariablenames","text":"Description : Let the AST generate friendly identifier names (eg, based on types) instead of generic names Type and Default : Boolean(true)","title":".parsers.dcmp_x86_64.UseFriendlyVariableNames"},{"location":"engines-configuration.html#parsersdcmp_x86_64usessaform","text":"Description : Let the decompiler convert intermediate form CFG to SSA forms Type and Default : Boolean(false)","title":".parsers.dcmp_x86_64.UseSSAForm"},{"location":"engines-configuration.html#parsersdcmp_x86_64textmergeadjacentdefinitions","text":"Description : Merge same type definitions on a single line (eg, int i = 0, j = 1;) Type and Default : Boolean(true)","title":".parsers.dcmp_x86_64.text.MergeAdjacentDefinitions"},{"location":"engines-configuration.html#parsersdcmp_x86_64textspaceoutcompounds","text":"Description : Insert blank lines between compounds Type and Default : Boolean(true)","title":".parsers.dcmp_x86_64.text.SpaceOutCompounds"},{"location":"engines-configuration.html#parsersdexandroidjavadocroot","text":"Description : Location of Java/Android API documentation files; by default, local files stored in your Android SDK folder will be preferred over web-based API doc Type and Default : String(\"($ANDROID_HOME/docs|$ANDROID_SDK_HOME/docs|$ANDROID_SDK_ROOT/docs)/reference/;https://developer.android.com/reference/;($JAVA_HOME)/docs/api\")","title":".parsers.dex.AndroidJavadocRoot"},{"location":"engines-configuration.html#parsersdexdalvikparsermode","text":"Description : Dalvik parser mode: 0: Legacy DEX, including odex and extended opcodes (0xFFxx) - designed for DEX <=37 If DEX version >= 38 is detected, the mode will be bumped to 100, 110, or more, automatically 50: ART introduction 100: DEX version 38 (+invoke-polymorphic, +invoke-custom, and variants) 110: DEX version 39 (+const-method-handle, +const-method-type) 1000: Newest, including things that may not be supported in JEB yet Type and Default : Integer(50)","title":".parsers.dex.DalvikParserMode"},{"location":"engines-configuration.html#parsersdexparseextendedopcodes","text":"Description : Support parsing for the extended opcodes Type and Default : Boolean(true)","title":".parsers.dex.ParseExtendedOpcodes"},{"location":"engines-configuration.html#parsersdexparseoptimizedopcodes","text":"Description : Support parsing for the optimized opcodes Type and Default : Boolean(true)","title":".parsers.dex.ParseOptimizedOpcodes"},{"location":"engines-configuration.html#parsersdexprovideextrainfoincodenodelabels","text":"Description : Provide additional information in code node items to client components. Currently, when this option is enabled, method labels for concrete non-native methods are appended with a ' /N' string where N is the instruction count of the method. Type and Default : Boolean(false)","title":".parsers.dex.ProvideExtraInfoInCodeNodeLabels"},{"location":"engines-configuration.html#parsersdexprovidefriendlycodenodelabels","text":"Description : Provide user-friendly code node items (non-qualified, non-internal Java names) to client components. Methods and field signatures will be more readable, at the risk of potentially appearing conflicting, esp. on obfuscated samples that heavily reuse names across methods, fields, and types. Type and Default : Boolean(true)","title":".parsers.dex.ProvideFriendlyCodeNodeLabels"},{"location":"engines-configuration.html#parsersdexverifyaccessflags","text":"Description : Fail parsing if the access flags of a class, method, or field appear to be illegal Type and Default : Boolean(false)","title":".parsers.dex.VerifyAccessFlags"},{"location":"engines-configuration.html#parsersdexverifyhashes","text":"Description : Fail parsing if the DEX Adler checksum is not the expected one Type and Default : Boolean(false)","title":".parsers.dex.VerifyHashes"},{"location":"engines-configuration.html#parsersdexverifyversion","text":"Description : Fail parsing if the DEX version number is not in the range [35, 39] Type and Default : Boolean(false)","title":".parsers.dex.VerifyVersion"},{"location":"engines-configuration.html#parsersdexwellknownlibrarypackages","text":"Description : CSL of well-known packages that may not be provided as fully-expanded in code hierarchy tree documents. Use * to prevent auto-expansion for all packages. In practice, the JEB UI client will not auto-expand those packages by default to avoid cluttering the code hierarchy fragment view. Type and Default : String(\"android,androidx,android_src,com.google,java,javax,org.acra,org.json,org.apache\")","title":".parsers.dex.WellKnownLibraryPackages"},{"location":"engines-configuration.html#parsersdextextclassseparatorlength","text":"Description : Length of the class separator line in characters Type and Default : Integer(0){0+}","title":".parsers.dex.text.ClassSeparatorLength"},{"location":"engines-configuration.html#parsersdextextmethodseparatorlength","text":"Description : Length of the method separator line in characters Type and Default : Integer(0){0+}","title":".parsers.dex.text.MethodSeparatorLength"},{"location":"engines-configuration.html#parsersdextextshowaddresses","text":"Description : Display addresses of items Type and Default : Boolean(true)","title":".parsers.dex.text.ShowAddresses"},{"location":"engines-configuration.html#parsersdextextshowannotations","text":"Description : Show the DEX annotations Type and Default : Boolean(true)","title":".parsers.dex.text.ShowAnnotations"},{"location":"engines-configuration.html#parsersdextextshowbytecode","text":"Description : Display the instruction bytecode Type and Default : Boolean(false)","title":".parsers.dex.text.ShowBytecode"},{"location":"engines-configuration.html#parsersdextextshowdebugdirectives","text":"Description : Show the debug directives (metadata) Type and Default : Boolean(false)","title":".parsers.dex.text.ShowDebugDirectives"},{"location":"engines-configuration.html#parsersdextextshowinstructionsingaps","text":"Description : Parse byte gaps (aka slack space, or unsued data bytes, that can be present of method's body) and display those bytes as Dalvik instructions Type and Default : Boolean(false)","title":".parsers.dex.text.ShowInstructionsInGaps"},{"location":"engines-configuration.html#parsersdextextshowlinenumbers","text":"Description : Show the source line numbers (metadata) Type and Default : Boolean(false)","title":".parsers.dex.text.ShowLineNumbers"},{"location":"engines-configuration.html#parsersdextextshowspacebetweenblocks","text":"Description : Insert a blank line between basic blocks Type and Default : Boolean(false)","title":".parsers.dex.text.ShowSpaceBetweenBlocks"},{"location":"engines-configuration.html#parsersdextextsmalicompatibility","text":"Description : Generate assembly code closer to (sometimes, compatible with) Smali, eg, using fully-qualified names everywhere Type and Default : Boolean(false)","title":".parsers.dex.text.SmaliCompatibility"},{"location":"engines-configuration.html#parsersdextextusepforparameters","text":"Description : Use p0,p1,... instead of v0,v1,... for variables Type and Default : Boolean(true)","title":".parsers.dex.text.UsePForParameters"},{"location":"engines-configuration.html#parsersevmbcadvancedanalysisroutinecountwarning","text":"Description : If the standard analysis yields more routines that this provided threshold, then the user will be prompted for confirmation before starting the optional advanced analysis pass (and subsequent passes). Type and Default : Integer(200){0+}","title":".parsers.evmbc.AdvancedAnalysisRoutineCountWarning"},{"location":"engines-configuration.html#parsersevmbcallowadvancedanalysis","text":"Description : The advanced analysis is an optional analysis pass that comes after the initial standard analysis. It permits discovery of indirect dispatch, therefore providing better routine discovery coverage, and partial resolution of register values. Type and Default : Boolean(false)","title":".parsers.evmbc.AllowAdvancedAnalysis"},{"location":"engines-configuration.html#parsersevmbcanalysisstyle","text":"Description : Native analysis style: 0 = forced conservative analysis 1 = automatic mode (depends on the file) 2 = forced aggressive analysis 3 = forced lazy analysis 4 = forced lazy no data analysis Type and Default : Integer(1){0-4}","title":".parsers.evmbc.AnalysisStyle"},{"location":"engines-configuration.html#parsersevmbcdebuginformationretrievalpolicy","text":"Description : Policy regarding the retrieval of externally-stored debugging and symbolic information of code objects: 0 = never attempt 1 = retrieve locally stored external symbols 2 = attempt to retrieve locally and network-stored symbols Locations are architecture- and code object- dependent and may be customized via environment variables. Refer to the manual for additional documentation. Type and Default : Integer(2){0-2}","title":".parsers.evmbc.DebugInformationRetrievalPolicy"},{"location":"engines-configuration.html#parsersevmbcdebuginformationusagepolicy","text":"Description : Apply and use debug information to improve analysis accuracy (on a best-effort basis): 0 = never use debug information 1 = use internal debug information only 2 = use all available (internal and external) debug information Type and Default : Integer(1){0-2}","title":".parsers.evmbc.DebugInformationUsagePolicy"},{"location":"engines-configuration.html#parsersevmbcidentifiedcompiler","text":"Description : Identified compiler: 0 = automatic identification (depends on the file) 1 = unknown compiler 2 = generic Linux compiler 3 = Android ART 4 = Android NDK 5 = generic Windows compiler 6 = Microsoft Visual C++ Type and Default : Integer(0){0-6}","title":".parsers.evmbc.IdentifiedCompiler"},{"location":"engines-configuration.html#parsersevmbcperformclassrecovery","text":"Description : Attempt C++ class discovery and rebuilding (limited to MSVC-compiled x86 executables for now) Type and Default : Boolean(false)","title":".parsers.evmbc.PerformClassRecovery"},{"location":"engines-configuration.html#parsersevmbcperformglobalanalysis","text":"Description : Global analysis passes are optional passes provided by specific decompiler modules. They may allow recovery of complex artifacts, such as classes or modules. Type and Default : Boolean(false)","title":".parsers.evmbc.PerformGlobalAnalysis"},{"location":"engines-configuration.html#parsersevmbcperformrttirecovery","text":"Description : Attempt C++ Run-Time Type Information (RTTI) discovery and rebuilding (MSVC and Itanium (GCC/CLANG/NDK) are supported) Type and Default : Boolean(true)","title":".parsers.evmbc.PerformRttiRecovery"},{"location":"engines-configuration.html#parsersevmbcprefersynchronousexecution","text":"Description : Synchronous analysis prevents access to the unit during a code analysis Type and Default : Boolean(false)","title":".parsers.evmbc.PreferSynchronousExecution"},{"location":"engines-configuration.html#parsersevmbctailcallanalysisstyle","text":"Description : Search for possible tail calls optimized as branches, and build proper routines. Possible modes: 0 = deactivated 1 = automatic mode (heuristics depend on the file) 2 = safe heuristics only 3 = aggressive heuristics Type and Default : Integer(1){0-3}","title":".parsers.evmbc.TailCallAnalysisStyle"},{"location":"engines-configuration.html#parsersevmbcwantedendianness","text":"Description : Desired endianness for raw binaries: 'little'/'le', 'big'/'be'. May be overridden by the code parser. Type and Default : String(\"le\")","title":".parsers.evmbc.WantedEndianness"},{"location":"engines-configuration.html#parsersevmbcwantedimagebase","text":"Description : Desired memory base address for raw binaries. 0 by default. Type and Default : String(\"0\")","title":".parsers.evmbc.WantedImageBase"},{"location":"engines-configuration.html#parsersevmbctextblockxrefscount","text":"Description : Maximum number of cross-references displayed at any address Type and Default : Integer(50)","title":".parsers.evmbc.text.BlockXrefsCount"},{"location":"engines-configuration.html#parsersevmbctextcharbreak64bitaddresses","text":"Description : If not empty, the address column will display 64-bit addresses as two 8-hexdigit parts, separated by the provided character string Type and Default : String(\"'\")","title":".parsers.evmbc.text.CharBreak64BitAddresses"},{"location":"engines-configuration.html#parsersevmbctextgappreferrawformatting","text":"Description : Prefer raw formatting (dr XX, dr XXXX) for gaps and slack spaces instead of regular declarations (eg, db ??) Type and Default : Boolean(false)","title":".parsers.evmbc.text.GapPreferRawFormatting"},{"location":"engines-configuration.html#parsersevmbctextgaprawbytesperline","text":"Description : For raw formatting, determine the maximum number of bytes per line in gaps and slack spaces. Must be a power of 2, else reverts to the default. Type and Default : Integer(16){0+}","title":".parsers.evmbc.text.GapRawBytesPerLine"},{"location":"engines-configuration.html#parsersevmbctextgaprawintegersize","text":"Description : For raw formatting, determine the integer length (in bytes) used for rendering. Must be either 1, 2, 4, or 8, else reverts to the default Type and Default : Integer(1){0+}","title":".parsers.evmbc.text.GapRawIntegerSize"},{"location":"engines-configuration.html#parsersevmbctextinstructionarealength","text":"Description : Length in characters of the assembly column containing the instructions Type and Default : Integer(40){0+}","title":".parsers.evmbc.text.InstructionAreaLength"},{"location":"engines-configuration.html#parsersevmbctextlabelarealength","text":"Description : Length in characters of the assembly column containing the labels Type and Default : Integer(16){0+}","title":".parsers.evmbc.text.LabelAreaLength"},{"location":"engines-configuration.html#parsersevmbctextroutineseparatorlength","text":"Description : Number of characters used to build the line separating routines Type and Default : Integer(80){0+}","title":".parsers.evmbc.text.RoutineSeparatorLength"},{"location":"engines-configuration.html#parsersevmbctextshowaddresses","text":"Description : Display addresses of items Type and Default : Boolean(true)","title":".parsers.evmbc.text.ShowAddresses"},{"location":"engines-configuration.html#parsersevmbctextshowbytescount","text":"Description : Maximum count of instruction bytes to be displayed before the instruction Type and Default : Integer(0){0+}","title":".parsers.evmbc.text.ShowBytesCount"},{"location":"engines-configuration.html#parsersevmbctextshowsegmentheaders","text":"Description : Display the segment or section headers Type and Default : Boolean(true)","title":".parsers.evmbc.text.ShowSegmentHeaders"},{"location":"engines-configuration.html#parsersevmbctextshowspacebetweenblocks","text":"Description : Insert blank lines between basic blocks Type and Default : Boolean(false)","title":".parsers.evmbc.text.ShowSpaceBetweenBlocks"},{"location":"engines-configuration.html#parsersihexbigendian","text":"Description : Set to true to specify big-endian. The default is little-endian, unless a specific processor setting overrides it. Type and Default : Boolean(false)","title":".parsers.ihex.BigEndian"},{"location":"engines-configuration.html#parsersihexprocessor","text":"Description : Target processor/microcontroller code: 'x86', 'x86_64', 'arm', 'arm64', 'mips', 'avr', etc. The default is x86 Type and Default : String(\"x86\")","title":".parsers.ihex.Processor"},{"location":"engines-configuration.html#parsersihexwantedimagebase","text":"Description : Base address hint. Leave empty to let the plugin decide Type and Default : String(\"\")","title":".parsers.ihex.WantedImageBase"},{"location":"engines-configuration.html#parsersihexwantedwordsize","text":"Description : Desired wordsize in bits: 8, 16, 32, etc. Leave empty to let the plugin decide by heuristics Type and Default : String(\"\")","title":".parsers.ihex.WantedWordsize"},{"location":"engines-configuration.html#parsersjavaclassused8fordexconversion","text":"Description : Prefer the new d8/r8 compiler over the legacy dx compiler to perform Java bytecode to Dalvik bytecode transpilation Type and Default : Boolean(false)","title":".parsers.javaclass.UseD8ForDexConversion"},{"location":"engines-configuration.html#parserslibravm_bcadvancedanalysisroutinecountwarning","text":"Description : If the standard analysis yields more routines that this provided threshold, then the user will be prompted for confirmation before starting the optional advanced analysis pass (and subsequent passes). Type and Default : Integer(200){0+}","title":".parsers.libravm_bc.AdvancedAnalysisRoutineCountWarning"},{"location":"engines-configuration.html#parserslibravm_bcallowadvancedanalysis","text":"Description : The advanced analysis is an optional analysis pass that comes after the initial standard analysis. It permits discovery of indirect dispatch, therefore providing better routine discovery coverage, and partial resolution of register values. Type and Default : Boolean(false)","title":".parsers.libravm_bc.AllowAdvancedAnalysis"},{"location":"engines-configuration.html#parserslibravm_bcanalysisstyle","text":"Description : Native analysis style: 0 = forced conservative analysis 1 = automatic mode (depends on the file) 2 = forced aggressive analysis 3 = forced lazy analysis 4 = forced lazy no data analysis Type and Default : Integer(1){0-4}","title":".parsers.libravm_bc.AnalysisStyle"},{"location":"engines-configuration.html#parserslibravm_bcdebuginformationretrievalpolicy","text":"Description : Policy regarding the retrieval of externally-stored debugging and symbolic information of code objects: 0 = never attempt 1 = retrieve locally stored external symbols 2 = attempt to retrieve locally and network-stored symbols Locations are architecture- and code object- dependent and may be customized via environment variables. Refer to the manual for additional documentation. Type and Default : Integer(2){0-2}","title":".parsers.libravm_bc.DebugInformationRetrievalPolicy"},{"location":"engines-configuration.html#parserslibravm_bcdebuginformationusagepolicy","text":"Description : Apply and use debug information to improve analysis accuracy (on a best-effort basis): 0 = never use debug information 1 = use internal debug information only 2 = use all available (internal and external) debug information Type and Default : Integer(1){0-2}","title":".parsers.libravm_bc.DebugInformationUsagePolicy"},{"location":"engines-configuration.html#parserslibravm_bcidentifiedcompiler","text":"Description : Identified compiler: 0 = automatic identification (depends on the file) 1 = unknown compiler 2 = generic Linux compiler 3 = Android ART 4 = Android NDK 5 = generic Windows compiler 6 = Microsoft Visual C++ Type and Default : Integer(0){0-6}","title":".parsers.libravm_bc.IdentifiedCompiler"},{"location":"engines-configuration.html#parserslibravm_bcperformclassrecovery","text":"Description : Attempt C++ class discovery and rebuilding (limited to MSVC-compiled x86 executables for now) Type and Default : Boolean(false)","title":".parsers.libravm_bc.PerformClassRecovery"},{"location":"engines-configuration.html#parserslibravm_bcperformglobalanalysis","text":"Description : Global analysis passes are optional passes provided by specific decompiler modules. They may allow recovery of complex artifacts, such as classes or modules. Type and Default : Boolean(false)","title":".parsers.libravm_bc.PerformGlobalAnalysis"},{"location":"engines-configuration.html#parserslibravm_bcperformrttirecovery","text":"Description : Attempt C++ Run-Time Type Information (RTTI) discovery and rebuilding (MSVC and Itanium (GCC/CLANG/NDK) are supported) Type and Default : Boolean(true)","title":".parsers.libravm_bc.PerformRttiRecovery"},{"location":"engines-configuration.html#parserslibravm_bcprefersynchronousexecution","text":"Description : Synchronous analysis prevents access to the unit during a code analysis Type and Default : Boolean(false)","title":".parsers.libravm_bc.PreferSynchronousExecution"},{"location":"engines-configuration.html#parserslibravm_bctailcallanalysisstyle","text":"Description : Search for possible tail calls optimized as branches, and build proper routines. Possible modes: 0 = deactivated 1 = automatic mode (heuristics depend on the file) 2 = safe heuristics only 3 = aggressive heuristics Type and Default : Integer(1){0-3}","title":".parsers.libravm_bc.TailCallAnalysisStyle"},{"location":"engines-configuration.html#parserslibravm_bcwantedendianness","text":"Description : Desired endianness for raw binaries: 'little'/'le', 'big'/'be'. May be overridden by the code parser. Type and Default : String(\"le\")","title":".parsers.libravm_bc.WantedEndianness"},{"location":"engines-configuration.html#parserslibravm_bcwantedimagebase","text":"Description : Desired memory base address for raw binaries. 0 by default. Type and Default : String(\"0\")","title":".parsers.libravm_bc.WantedImageBase"},{"location":"engines-configuration.html#parserslibravm_bctextblockxrefscount","text":"Description : Maximum number of cross-references displayed at any address Type and Default : Integer(50)","title":".parsers.libravm_bc.text.BlockXrefsCount"},{"location":"engines-configuration.html#parserslibravm_bctextcharbreak64bitaddresses","text":"Description : If not empty, the address column will display 64-bit addresses as two 8-hexdigit parts, separated by the provided character string Type and Default : String(\"'\")","title":".parsers.libravm_bc.text.CharBreak64BitAddresses"},{"location":"engines-configuration.html#parserslibravm_bctextgappreferrawformatting","text":"Description : Prefer raw formatting (dr XX, dr XXXX) for gaps and slack spaces instead of regular declarations (eg, db ??) Type and Default : Boolean(false)","title":".parsers.libravm_bc.text.GapPreferRawFormatting"},{"location":"engines-configuration.html#parserslibravm_bctextgaprawbytesperline","text":"Description : For raw formatting, determine the maximum number of bytes per line in gaps and slack spaces. Must be a power of 2, else reverts to the default. Type and Default : Integer(16){0+}","title":".parsers.libravm_bc.text.GapRawBytesPerLine"},{"location":"engines-configuration.html#parserslibravm_bctextgaprawintegersize","text":"Description : For raw formatting, determine the integer length (in bytes) used for rendering. Must be either 1, 2, 4, or 8, else reverts to the default Type and Default : Integer(1){0+}","title":".parsers.libravm_bc.text.GapRawIntegerSize"},{"location":"engines-configuration.html#parserslibravm_bctextinstructionarealength","text":"Description : Length in characters of the assembly column containing the instructions Type and Default : Integer(40){0+}","title":".parsers.libravm_bc.text.InstructionAreaLength"},{"location":"engines-configuration.html#parserslibravm_bctextlabelarealength","text":"Description : Length in characters of the assembly column containing the labels Type and Default : Integer(16){0+}","title":".parsers.libravm_bc.text.LabelAreaLength"},{"location":"engines-configuration.html#parserslibravm_bctextroutineseparatorlength","text":"Description : Number of characters used to build the line separating routines Type and Default : Integer(80){0+}","title":".parsers.libravm_bc.text.RoutineSeparatorLength"},{"location":"engines-configuration.html#parserslibravm_bctextshowaddresses","text":"Description : Display addresses of items Type and Default : Boolean(true)","title":".parsers.libravm_bc.text.ShowAddresses"},{"location":"engines-configuration.html#parserslibravm_bctextshowbytescount","text":"Description : Maximum count of instruction bytes to be displayed before the instruction Type and Default : Integer(0){0+}","title":".parsers.libravm_bc.text.ShowBytesCount"},{"location":"engines-configuration.html#parserslibravm_bctextshowsegmentheaders","text":"Description : Display the segment or section headers Type and Default : Boolean(true)","title":".parsers.libravm_bc.text.ShowSegmentHeaders"},{"location":"engines-configuration.html#parserslibravm_bctextshowspacebetweenblocks","text":"Description : Insert blank lines between basic blocks Type and Default : Boolean(false)","title":".parsers.libravm_bc.text.ShowSpaceBetweenBlocks"},{"location":"engines-configuration.html#parsersmipsadvancedanalysisroutinecountwarning","text":"Description : If the standard analysis yields more routines that this provided threshold, then the user will be prompted for confirmation before starting the optional advanced analysis pass (and subsequent passes). Type and Default : Integer(200){0+}","title":".parsers.mips.AdvancedAnalysisRoutineCountWarning"},{"location":"engines-configuration.html#parsersmipsallowadvancedanalysis","text":"Description : The advanced analysis is an optional analysis pass that comes after the initial standard analysis. It permits discovery of indirect dispatch, therefore providing better routine discovery coverage, and partial resolution of register values. Type and Default : Boolean(false)","title":".parsers.mips.AllowAdvancedAnalysis"},{"location":"engines-configuration.html#parsersmipsanalysisstyle","text":"Description : Native analysis style: 0 = forced conservative analysis 1 = automatic mode (depends on the file) 2 = forced aggressive analysis 3 = forced lazy analysis 4 = forced lazy no data analysis Type and Default : Integer(1){0-4}","title":".parsers.mips.AnalysisStyle"},{"location":"engines-configuration.html#parsersmipsdebuginformationretrievalpolicy","text":"Description : Policy regarding the retrieval of externally-stored debugging and symbolic information of code objects: 0 = never attempt 1 = retrieve locally stored external symbols 2 = attempt to retrieve locally and network-stored symbols Locations are architecture- and code object- dependent and may be customized via environment variables. Refer to the manual for additional documentation. Type and Default : Integer(2){0-2}","title":".parsers.mips.DebugInformationRetrievalPolicy"},{"location":"engines-configuration.html#parsersmipsdebuginformationusagepolicy","text":"Description : Apply and use debug information to improve analysis accuracy (on a best-effort basis): 0 = never use debug information 1 = use internal debug information only 2 = use all available (internal and external) debug information Type and Default : Integer(1){0-2}","title":".parsers.mips.DebugInformationUsagePolicy"},{"location":"engines-configuration.html#parsersmipsidentifiedcompiler","text":"Description : Identified compiler: 0 = automatic identification (depends on the file) 1 = unknown compiler 2 = generic Linux compiler 3 = Android ART 4 = Android NDK 5 = generic Windows compiler 6 = Microsoft Visual C++ Type and Default : Integer(0){0-6}","title":".parsers.mips.IdentifiedCompiler"},{"location":"engines-configuration.html#parsersmipsperformclassrecovery","text":"Description : Attempt C++ class discovery and rebuilding (limited to MSVC-compiled x86 executables for now) Type and Default : Boolean(false)","title":".parsers.mips.PerformClassRecovery"},{"location":"engines-configuration.html#parsersmipsperformglobalanalysis","text":"Description : Global analysis passes are optional passes provided by specific decompiler modules. They may allow recovery of complex artifacts, such as classes or modules. Type and Default : Boolean(false)","title":".parsers.mips.PerformGlobalAnalysis"},{"location":"engines-configuration.html#parsersmipsperformrttirecovery","text":"Description : Attempt C++ Run-Time Type Information (RTTI) discovery and rebuilding (MSVC and Itanium (GCC/CLANG/NDK) are supported) Type and Default : Boolean(true)","title":".parsers.mips.PerformRttiRecovery"},{"location":"engines-configuration.html#parsersmipsprefersynchronousexecution","text":"Description : Synchronous analysis prevents access to the unit during a code analysis Type and Default : Boolean(false)","title":".parsers.mips.PreferSynchronousExecution"},{"location":"engines-configuration.html#parsersmipstailcallanalysisstyle","text":"Description : Search for possible tail calls optimized as branches, and build proper routines. Possible modes: 0 = deactivated 1 = automatic mode (heuristics depend on the file) 2 = safe heuristics only 3 = aggressive heuristics Type and Default : Integer(1){0-3}","title":".parsers.mips.TailCallAnalysisStyle"},{"location":"engines-configuration.html#parsersmipswantedendianness","text":"Description : Desired endianness for raw binaries: 'little'/'le', 'big'/'be'. May be overridden by the code parser. Type and Default : String(\"le\")","title":".parsers.mips.WantedEndianness"},{"location":"engines-configuration.html#parsersmipswantedimagebase","text":"Description : Desired memory base address for raw binaries. 0 by default. Type and Default : String(\"0\")","title":".parsers.mips.WantedImageBase"},{"location":"engines-configuration.html#parsersmipstextblockxrefscount","text":"Description : Maximum number of cross-references displayed at any address Type and Default : Integer(50)","title":".parsers.mips.text.BlockXrefsCount"},{"location":"engines-configuration.html#parsersmipstextcharbreak64bitaddresses","text":"Description : If not empty, the address column will display 64-bit addresses as two 8-hexdigit parts, separated by the provided character string Type and Default : String(\"'\")","title":".parsers.mips.text.CharBreak64BitAddresses"},{"location":"engines-configuration.html#parsersmipstextgappreferrawformatting","text":"Description : Prefer raw formatting (dr XX, dr XXXX) for gaps and slack spaces instead of regular declarations (eg, db ??) Type and Default : Boolean(false)","title":".parsers.mips.text.GapPreferRawFormatting"},{"location":"engines-configuration.html#parsersmipstextgaprawbytesperline","text":"Description : For raw formatting, determine the maximum number of bytes per line in gaps and slack spaces. Must be a power of 2, else reverts to the default. Type and Default : Integer(16){0+}","title":".parsers.mips.text.GapRawBytesPerLine"},{"location":"engines-configuration.html#parsersmipstextgaprawintegersize","text":"Description : For raw formatting, determine the integer length (in bytes) used for rendering. Must be either 1, 2, 4, or 8, else reverts to the default Type and Default : Integer(1){0+}","title":".parsers.mips.text.GapRawIntegerSize"},{"location":"engines-configuration.html#parsersmipstextinstructionarealength","text":"Description : Length in characters of the assembly column containing the instructions Type and Default : Integer(40){0+}","title":".parsers.mips.text.InstructionAreaLength"},{"location":"engines-configuration.html#parsersmipstextlabelarealength","text":"Description : Length in characters of the assembly column containing the labels Type and Default : Integer(16){0+}","title":".parsers.mips.text.LabelAreaLength"},{"location":"engines-configuration.html#parsersmipstextroutineseparatorlength","text":"Description : Number of characters used to build the line separating routines Type and Default : Integer(80){0+}","title":".parsers.mips.text.RoutineSeparatorLength"},{"location":"engines-configuration.html#parsersmipstextshowaddresses","text":"Description : Display addresses of items Type and Default : Boolean(true)","title":".parsers.mips.text.ShowAddresses"},{"location":"engines-configuration.html#parsersmipstextshowbytescount","text":"Description : Maximum count of instruction bytes to be displayed before the instruction Type and Default : Integer(0){0+}","title":".parsers.mips.text.ShowBytesCount"},{"location":"engines-configuration.html#parsersmipstextshowsegmentheaders","text":"Description : Display the segment or section headers Type and Default : Boolean(true)","title":".parsers.mips.text.ShowSegmentHeaders"},{"location":"engines-configuration.html#parsersmipstextshowspacebetweenblocks","text":"Description : Insert blank lines between basic blocks Type and Default : Boolean(false)","title":".parsers.mips.text.ShowSpaceBetweenBlocks"},{"location":"engines-configuration.html#parsersmips64advancedanalysisroutinecountwarning","text":"Description : If the standard analysis yields more routines that this provided threshold, then the user will be prompted for confirmation before starting the optional advanced analysis pass (and subsequent passes). Type and Default : Integer(200){0+}","title":".parsers.mips64.AdvancedAnalysisRoutineCountWarning"},{"location":"engines-configuration.html#parsersmips64allowadvancedanalysis","text":"Description : The advanced analysis is an optional analysis pass that comes after the initial standard analysis. It permits discovery of indirect dispatch, therefore providing better routine discovery coverage, and partial resolution of register values. Type and Default : Boolean(false)","title":".parsers.mips64.AllowAdvancedAnalysis"},{"location":"engines-configuration.html#parsersmips64analysisstyle","text":"Description : Native analysis style: 0 = forced conservative analysis 1 = automatic mode (depends on the file) 2 = forced aggressive analysis 3 = forced lazy analysis 4 = forced lazy no data analysis Type and Default : Integer(1){0-4}","title":".parsers.mips64.AnalysisStyle"},{"location":"engines-configuration.html#parsersmips64debuginformationretrievalpolicy","text":"Description : Policy regarding the retrieval of externally-stored debugging and symbolic information of code objects: 0 = never attempt 1 = retrieve locally stored external symbols 2 = attempt to retrieve locally and network-stored symbols Locations are architecture- and code object- dependent and may be customized via environment variables. Refer to the manual for additional documentation. Type and Default : Integer(2){0-2}","title":".parsers.mips64.DebugInformationRetrievalPolicy"},{"location":"engines-configuration.html#parsersmips64debuginformationusagepolicy","text":"Description : Apply and use debug information to improve analysis accuracy (on a best-effort basis): 0 = never use debug information 1 = use internal debug information only 2 = use all available (internal and external) debug information Type and Default : Integer(1){0-2}","title":".parsers.mips64.DebugInformationUsagePolicy"},{"location":"engines-configuration.html#parsersmips64identifiedcompiler","text":"Description : Identified compiler: 0 = automatic identification (depends on the file) 1 = unknown compiler 2 = generic Linux compiler 3 = Android ART 4 = Android NDK 5 = generic Windows compiler 6 = Microsoft Visual C++ Type and Default : Integer(0){0-6}","title":".parsers.mips64.IdentifiedCompiler"},{"location":"engines-configuration.html#parsersmips64performclassrecovery","text":"Description : Attempt C++ class discovery and rebuilding (limited to MSVC-compiled x86 executables for now) Type and Default : Boolean(false)","title":".parsers.mips64.PerformClassRecovery"},{"location":"engines-configuration.html#parsersmips64performglobalanalysis","text":"Description : Global analysis passes are optional passes provided by specific decompiler modules. They may allow recovery of complex artifacts, such as classes or modules. Type and Default : Boolean(false)","title":".parsers.mips64.PerformGlobalAnalysis"},{"location":"engines-configuration.html#parsersmips64performrttirecovery","text":"Description : Attempt C++ Run-Time Type Information (RTTI) discovery and rebuilding (MSVC and Itanium (GCC/CLANG/NDK) are supported) Type and Default : Boolean(true)","title":".parsers.mips64.PerformRttiRecovery"},{"location":"engines-configuration.html#parsersmips64prefersynchronousexecution","text":"Description : Synchronous analysis prevents access to the unit during a code analysis Type and Default : Boolean(false)","title":".parsers.mips64.PreferSynchronousExecution"},{"location":"engines-configuration.html#parsersmips64tailcallanalysisstyle","text":"Description : Search for possible tail calls optimized as branches, and build proper routines. Possible modes: 0 = deactivated 1 = automatic mode (heuristics depend on the file) 2 = safe heuristics only 3 = aggressive heuristics Type and Default : Integer(1){0-3}","title":".parsers.mips64.TailCallAnalysisStyle"},{"location":"engines-configuration.html#parsersmips64wantedendianness","text":"Description : Desired endianness for raw binaries: 'little'/'le', 'big'/'be'. May be overridden by the code parser. Type and Default : String(\"le\")","title":".parsers.mips64.WantedEndianness"},{"location":"engines-configuration.html#parsersmips64wantedimagebase","text":"Description : Desired memory base address for raw binaries. 0 by default. Type and Default : String(\"0\")","title":".parsers.mips64.WantedImageBase"},{"location":"engines-configuration.html#parsersmips64textblockxrefscount","text":"Description : Maximum number of cross-references displayed at any address Type and Default : Integer(50)","title":".parsers.mips64.text.BlockXrefsCount"},{"location":"engines-configuration.html#parsersmips64textcharbreak64bitaddresses","text":"Description : If not empty, the address column will display 64-bit addresses as two 8-hexdigit parts, separated by the provided character string Type and Default : String(\"'\")","title":".parsers.mips64.text.CharBreak64BitAddresses"},{"location":"engines-configuration.html#parsersmips64textgappreferrawformatting","text":"Description : Prefer raw formatting (dr XX, dr XXXX) for gaps and slack spaces instead of regular declarations (eg, db ??) Type and Default : Boolean(false)","title":".parsers.mips64.text.GapPreferRawFormatting"},{"location":"engines-configuration.html#parsersmips64textgaprawbytesperline","text":"Description : For raw formatting, determine the maximum number of bytes per line in gaps and slack spaces. Must be a power of 2, else reverts to the default. Type and Default : Integer(16){0+}","title":".parsers.mips64.text.GapRawBytesPerLine"},{"location":"engines-configuration.html#parsersmips64textgaprawintegersize","text":"Description : For raw formatting, determine the integer length (in bytes) used for rendering. Must be either 1, 2, 4, or 8, else reverts to the default Type and Default : Integer(1){0+}","title":".parsers.mips64.text.GapRawIntegerSize"},{"location":"engines-configuration.html#parsersmips64textinstructionarealength","text":"Description : Length in characters of the assembly column containing the instructions Type and Default : Integer(40){0+}","title":".parsers.mips64.text.InstructionAreaLength"},{"location":"engines-configuration.html#parsersmips64textlabelarealength","text":"Description : Length in characters of the assembly column containing the labels Type and Default : Integer(16){0+}","title":".parsers.mips64.text.LabelAreaLength"},{"location":"engines-configuration.html#parsersmips64textroutineseparatorlength","text":"Description : Number of characters used to build the line separating routines Type and Default : Integer(80){0+}","title":".parsers.mips64.text.RoutineSeparatorLength"},{"location":"engines-configuration.html#parsersmips64textshowaddresses","text":"Description : Display addresses of items Type and Default : Boolean(true)","title":".parsers.mips64.text.ShowAddresses"},{"location":"engines-configuration.html#parsersmips64textshowbytescount","text":"Description : Maximum count of instruction bytes to be displayed before the instruction Type and Default : Integer(0){0+}","title":".parsers.mips64.text.ShowBytesCount"},{"location":"engines-configuration.html#parsersmips64textshowsegmentheaders","text":"Description : Display the segment or section headers Type and Default : Boolean(true)","title":".parsers.mips64.text.ShowSegmentHeaders"},{"location":"engines-configuration.html#parsersmips64textshowspacebetweenblocks","text":"Description : Insert blank lines between basic blocks Type and Default : Boolean(false)","title":".parsers.mips64.text.ShowSpaceBetweenBlocks"},{"location":"engines-configuration.html#parserswasmbcadvancedanalysisroutinecountwarning","text":"Description : If the standard analysis yields more routines that this provided threshold, then the user will be prompted for confirmation before starting the optional advanced analysis pass (and subsequent passes). Type and Default : Integer(200){0+}","title":".parsers.wasmbc.AdvancedAnalysisRoutineCountWarning"},{"location":"engines-configuration.html#parserswasmbcallowadvancedanalysis","text":"Description : The advanced analysis is an optional analysis pass that comes after the initial standard analysis. It permits discovery of indirect dispatch, therefore providing better routine discovery coverage, and partial resolution of register values. Type and Default : Boolean(false)","title":".parsers.wasmbc.AllowAdvancedAnalysis"},{"location":"engines-configuration.html#parserswasmbcanalysisstyle","text":"Description : Native analysis style: 0 = forced conservative analysis 1 = automatic mode (depends on the file) 2 = forced aggressive analysis 3 = forced lazy analysis 4 = forced lazy no data analysis Type and Default : Integer(1){0-4}","title":".parsers.wasmbc.AnalysisStyle"},{"location":"engines-configuration.html#parserswasmbcdebuginformationretrievalpolicy","text":"Description : Policy regarding the retrieval of externally-stored debugging and symbolic information of code objects: 0 = never attempt 1 = retrieve locally stored external symbols 2 = attempt to retrieve locally and network-stored symbols Locations are architecture- and code object- dependent and may be customized via environment variables. Refer to the manual for additional documentation. Type and Default : Integer(2){0-2}","title":".parsers.wasmbc.DebugInformationRetrievalPolicy"},{"location":"engines-configuration.html#parserswasmbcdebuginformationusagepolicy","text":"Description : Apply and use debug information to improve analysis accuracy (on a best-effort basis): 0 = never use debug information 1 = use internal debug information only 2 = use all available (internal and external) debug information Type and Default : Integer(1){0-2}","title":".parsers.wasmbc.DebugInformationUsagePolicy"},{"location":"engines-configuration.html#parserswasmbcidentifiedcompiler","text":"Description : Identified compiler: 0 = automatic identification (depends on the file) 1 = unknown compiler 2 = generic Linux compiler 3 = Android ART 4 = Android NDK 5 = generic Windows compiler 6 = Microsoft Visual C++ Type and Default : Integer(0){0-6}","title":".parsers.wasmbc.IdentifiedCompiler"},{"location":"engines-configuration.html#parserswasmbcperformclassrecovery","text":"Description : Attempt C++ class discovery and rebuilding (limited to MSVC-compiled x86 executables for now) Type and Default : Boolean(false)","title":".parsers.wasmbc.PerformClassRecovery"},{"location":"engines-configuration.html#parserswasmbcperformglobalanalysis","text":"Description : Global analysis passes are optional passes provided by specific decompiler modules. They may allow recovery of complex artifacts, such as classes or modules. Type and Default : Boolean(false)","title":".parsers.wasmbc.PerformGlobalAnalysis"},{"location":"engines-configuration.html#parserswasmbcperformrttirecovery","text":"Description : Attempt C++ Run-Time Type Information (RTTI) discovery and rebuilding (MSVC and Itanium (GCC/CLANG/NDK) are supported) Type and Default : Boolean(true)","title":".parsers.wasmbc.PerformRttiRecovery"},{"location":"engines-configuration.html#parserswasmbcprefersynchronousexecution","text":"Description : Synchronous analysis prevents access to the unit during a code analysis Type and Default : Boolean(false)","title":".parsers.wasmbc.PreferSynchronousExecution"},{"location":"engines-configuration.html#parserswasmbctailcallanalysisstyle","text":"Description : Search for possible tail calls optimized as branches, and build proper routines. Possible modes: 0 = deactivated 1 = automatic mode (heuristics depend on the file) 2 = safe heuristics only 3 = aggressive heuristics Type and Default : Integer(1){0-3}","title":".parsers.wasmbc.TailCallAnalysisStyle"},{"location":"engines-configuration.html#parserswasmbcwantedendianness","text":"Description : Desired endianness for raw binaries: 'little'/'le', 'big'/'be'. May be overridden by the code parser. Type and Default : String(\"le\")","title":".parsers.wasmbc.WantedEndianness"},{"location":"engines-configuration.html#parserswasmbcwantedimagebase","text":"Description : Desired memory base address for raw binaries. 0 by default. Type and Default : String(\"0\")","title":".parsers.wasmbc.WantedImageBase"},{"location":"engines-configuration.html#parserswasmbctextblockxrefscount","text":"Description : Maximum number of cross-references displayed at any address Type and Default : Integer(50)","title":".parsers.wasmbc.text.BlockXrefsCount"},{"location":"engines-configuration.html#parserswasmbctextcharbreak64bitaddresses","text":"Description : If not empty, the address column will display 64-bit addresses as two 8-hexdigit parts, separated by the provided character string Type and Default : String(\"'\")","title":".parsers.wasmbc.text.CharBreak64BitAddresses"},{"location":"engines-configuration.html#parserswasmbctextgappreferrawformatting","text":"Description : Prefer raw formatting (dr XX, dr XXXX) for gaps and slack spaces instead of regular declarations (eg, db ??) Type and Default : Boolean(false)","title":".parsers.wasmbc.text.GapPreferRawFormatting"},{"location":"engines-configuration.html#parserswasmbctextgaprawbytesperline","text":"Description : For raw formatting, determine the maximum number of bytes per line in gaps and slack spaces. Must be a power of 2, else reverts to the default. Type and Default : Integer(16){0+}","title":".parsers.wasmbc.text.GapRawBytesPerLine"},{"location":"engines-configuration.html#parserswasmbctextgaprawintegersize","text":"Description : For raw formatting, determine the integer length (in bytes) used for rendering. Must be either 1, 2, 4, or 8, else reverts to the default Type and Default : Integer(1){0+}","title":".parsers.wasmbc.text.GapRawIntegerSize"},{"location":"engines-configuration.html#parserswasmbctextinstructionarealength","text":"Description : Length in characters of the assembly column containing the instructions Type and Default : Integer(40){0+}","title":".parsers.wasmbc.text.InstructionAreaLength"},{"location":"engines-configuration.html#parserswasmbctextlabelarealength","text":"Description : Length in characters of the assembly column containing the labels Type and Default : Integer(16){0+}","title":".parsers.wasmbc.text.LabelAreaLength"},{"location":"engines-configuration.html#parserswasmbctextroutineseparatorlength","text":"Description : Number of characters used to build the line separating routines Type and Default : Integer(80){0+}","title":".parsers.wasmbc.text.RoutineSeparatorLength"},{"location":"engines-configuration.html#parserswasmbctextshowaddresses","text":"Description : Display addresses of items Type and Default : Boolean(true)","title":".parsers.wasmbc.text.ShowAddresses"},{"location":"engines-configuration.html#parserswasmbctextshowbytescount","text":"Description : Maximum count of instruction bytes to be displayed before the instruction Type and Default : Integer(0){0+}","title":".parsers.wasmbc.text.ShowBytesCount"},{"location":"engines-configuration.html#parserswasmbctextshowsegmentheaders","text":"Description : Display the segment or section headers Type and Default : Boolean(true)","title":".parsers.wasmbc.text.ShowSegmentHeaders"},{"location":"engines-configuration.html#parserswasmbctextshowspacebetweenblocks","text":"Description : Insert blank lines between basic blocks Type and Default : Boolean(false)","title":".parsers.wasmbc.text.ShowSpaceBetweenBlocks"},{"location":"engines-configuration.html#parsersx86advancedanalysisroutinecountwarning","text":"Description : If the standard analysis yields more routines that this provided threshold, then the user will be prompted for confirmation before starting the optional advanced analysis pass (and subsequent passes). Type and Default : Integer(200){0+}","title":".parsers.x86.AdvancedAnalysisRoutineCountWarning"},{"location":"engines-configuration.html#parsersx86allowadvancedanalysis","text":"Description : The advanced analysis is an optional analysis pass that comes after the initial standard analysis. It permits discovery of indirect dispatch, therefore providing better routine discovery coverage, and partial resolution of register values. Type and Default : Boolean(false)","title":".parsers.x86.AllowAdvancedAnalysis"},{"location":"engines-configuration.html#parsersx86analysisstyle","text":"Description : Native analysis style: 0 = forced conservative analysis 1 = automatic mode (depends on the file) 2 = forced aggressive analysis 3 = forced lazy analysis 4 = forced lazy no data analysis Type and Default : Integer(1){0-4}","title":".parsers.x86.AnalysisStyle"},{"location":"engines-configuration.html#parsersx86debuginformationretrievalpolicy","text":"Description : Policy regarding the retrieval of externally-stored debugging and symbolic information of code objects: 0 = never attempt 1 = retrieve locally stored external symbols 2 = attempt to retrieve locally and network-stored symbols Locations are architecture- and code object- dependent and may be customized via environment variables. Refer to the manual for additional documentation. Type and Default : Integer(2){0-2}","title":".parsers.x86.DebugInformationRetrievalPolicy"},{"location":"engines-configuration.html#parsersx86debuginformationusagepolicy","text":"Description : Apply and use debug information to improve analysis accuracy (on a best-effort basis): 0 = never use debug information 1 = use internal debug information only 2 = use all available (internal and external) debug information Type and Default : Integer(1){0-2}","title":".parsers.x86.DebugInformationUsagePolicy"},{"location":"engines-configuration.html#parsersx86identifiedcompiler","text":"Description : Identified compiler: 0 = automatic identification (depends on the file) 1 = unknown compiler 2 = generic Linux compiler 3 = Android ART 4 = Android NDK 5 = generic Windows compiler 6 = Microsoft Visual C++ Type and Default : Integer(0){0-6}","title":".parsers.x86.IdentifiedCompiler"},{"location":"engines-configuration.html#parsersx86performclassrecovery","text":"Description : Attempt C++ class discovery and rebuilding (limited to MSVC-compiled x86 executables for now) Type and Default : Boolean(false)","title":".parsers.x86.PerformClassRecovery"},{"location":"engines-configuration.html#parsersx86performglobalanalysis","text":"Description : Global analysis passes are optional passes provided by specific decompiler modules. They may allow recovery of complex artifacts, such as classes or modules. Type and Default : Boolean(false)","title":".parsers.x86.PerformGlobalAnalysis"},{"location":"engines-configuration.html#parsersx86performrttirecovery","text":"Description : Attempt C++ Run-Time Type Information (RTTI) discovery and rebuilding (MSVC and Itanium (GCC/CLANG/NDK) are supported) Type and Default : Boolean(true)","title":".parsers.x86.PerformRttiRecovery"},{"location":"engines-configuration.html#parsersx86prefersynchronousexecution","text":"Description : Synchronous analysis prevents access to the unit during a code analysis Type and Default : Boolean(false)","title":".parsers.x86.PreferSynchronousExecution"},{"location":"engines-configuration.html#parsersx86tailcallanalysisstyle","text":"Description : Search for possible tail calls optimized as branches, and build proper routines. Possible modes: 0 = deactivated 1 = automatic mode (heuristics depend on the file) 2 = safe heuristics only 3 = aggressive heuristics Type and Default : Integer(1){0-3}","title":".parsers.x86.TailCallAnalysisStyle"},{"location":"engines-configuration.html#parsersx86wantedendianness","text":"Description : Desired endianness for raw binaries: 'little'/'le', 'big'/'be'. May be overridden by the code parser. Type and Default : String(\"le\")","title":".parsers.x86.WantedEndianness"},{"location":"engines-configuration.html#parsersx86wantedimagebase","text":"Description : Desired memory base address for raw binaries. 0 by default. Type and Default : String(\"0\")","title":".parsers.x86.WantedImageBase"},{"location":"engines-configuration.html#parsersx86textblockxrefscount","text":"Description : Maximum number of cross-references displayed at any address Type and Default : Integer(50)","title":".parsers.x86.text.BlockXrefsCount"},{"location":"engines-configuration.html#parsersx86textcharbreak64bitaddresses","text":"Description : If not empty, the address column will display 64-bit addresses as two 8-hexdigit parts, separated by the provided character string Type and Default : String(\"'\")","title":".parsers.x86.text.CharBreak64BitAddresses"},{"location":"engines-configuration.html#parsersx86textgappreferrawformatting","text":"Description : Prefer raw formatting (dr XX, dr XXXX) for gaps and slack spaces instead of regular declarations (eg, db ??) Type and Default : Boolean(false)","title":".parsers.x86.text.GapPreferRawFormatting"},{"location":"engines-configuration.html#parsersx86textgaprawbytesperline","text":"Description : For raw formatting, determine the maximum number of bytes per line in gaps and slack spaces. Must be a power of 2, else reverts to the default. Type and Default : Integer(16){0+}","title":".parsers.x86.text.GapRawBytesPerLine"},{"location":"engines-configuration.html#parsersx86textgaprawintegersize","text":"Description : For raw formatting, determine the integer length (in bytes) used for rendering. Must be either 1, 2, 4, or 8, else reverts to the default Type and Default : Integer(1){0+}","title":".parsers.x86.text.GapRawIntegerSize"},{"location":"engines-configuration.html#parsersx86textinstructionarealength","text":"Description : Length in characters of the assembly column containing the instructions Type and Default : Integer(40){0+}","title":".parsers.x86.text.InstructionAreaLength"},{"location":"engines-configuration.html#parsersx86textlabelarealength","text":"Description : Length in characters of the assembly column containing the labels Type and Default : Integer(16){0+}","title":".parsers.x86.text.LabelAreaLength"},{"location":"engines-configuration.html#parsersx86textroutineseparatorlength","text":"Description : Number of characters used to build the line separating routines Type and Default : Integer(80){0+}","title":".parsers.x86.text.RoutineSeparatorLength"},{"location":"engines-configuration.html#parsersx86textshowaddresses","text":"Description : Display addresses of items Type and Default : Boolean(true)","title":".parsers.x86.text.ShowAddresses"},{"location":"engines-configuration.html#parsersx86textshowbytescount","text":"Description : Maximum count of instruction bytes to be displayed before the instruction Type and Default : Integer(0){0+}","title":".parsers.x86.text.ShowBytesCount"},{"location":"engines-configuration.html#parsersx86textshowsegmentheaders","text":"Description : Display the segment or section headers Type and Default : Boolean(true)","title":".parsers.x86.text.ShowSegmentHeaders"},{"location":"engines-configuration.html#parsersx86textshowspacebetweenblocks","text":"Description : Insert blank lines between basic blocks Type and Default : Boolean(false)","title":".parsers.x86.text.ShowSpaceBetweenBlocks"},{"location":"engines-configuration.html#parsersx86_64advancedanalysisroutinecountwarning","text":"Description : If the standard analysis yields more routines that this provided threshold, then the user will be prompted for confirmation before starting the optional advanced analysis pass (and subsequent passes). Type and Default : Integer(200){0+}","title":".parsers.x86_64.AdvancedAnalysisRoutineCountWarning"},{"location":"engines-configuration.html#parsersx86_64allowadvancedanalysis","text":"Description : The advanced analysis is an optional analysis pass that comes after the initial standard analysis. It permits discovery of indirect dispatch, therefore providing better routine discovery coverage, and partial resolution of register values. Type and Default : Boolean(false)","title":".parsers.x86_64.AllowAdvancedAnalysis"},{"location":"engines-configuration.html#parsersx86_64analysisstyle","text":"Description : Native analysis style: 0 = forced conservative analysis 1 = automatic mode (depends on the file) 2 = forced aggressive analysis 3 = forced lazy analysis 4 = forced lazy no data analysis Type and Default : Integer(1){0-4}","title":".parsers.x86_64.AnalysisStyle"},{"location":"engines-configuration.html#parsersx86_64debuginformationretrievalpolicy","text":"Description : Policy regarding the retrieval of externally-stored debugging and symbolic information of code objects: 0 = never attempt 1 = retrieve locally stored external symbols 2 = attempt to retrieve locally and network-stored symbols Locations are architecture- and code object- dependent and may be customized via environment variables. Refer to the manual for additional documentation. Type and Default : Integer(2){0-2}","title":".parsers.x86_64.DebugInformationRetrievalPolicy"},{"location":"engines-configuration.html#parsersx86_64debuginformationusagepolicy","text":"Description : Apply and use debug information to improve analysis accuracy (on a best-effort basis): 0 = never use debug information 1 = use internal debug information only 2 = use all available (internal and external) debug information Type and Default : Integer(1){0-2}","title":".parsers.x86_64.DebugInformationUsagePolicy"},{"location":"engines-configuration.html#parsersx86_64identifiedcompiler","text":"Description : Identified compiler: 0 = automatic identification (depends on the file) 1 = unknown compiler 2 = generic Linux compiler 3 = Android ART 4 = Android NDK 5 = generic Windows compiler 6 = Microsoft Visual C++ Type and Default : Integer(0){0-6}","title":".parsers.x86_64.IdentifiedCompiler"},{"location":"engines-configuration.html#parsersx86_64performclassrecovery","text":"Description : Attempt C++ class discovery and rebuilding (limited to MSVC-compiled x86 executables for now) Type and Default : Boolean(false)","title":".parsers.x86_64.PerformClassRecovery"},{"location":"engines-configuration.html#parsersx86_64performglobalanalysis","text":"Description : Global analysis passes are optional passes provided by specific decompiler modules. They may allow recovery of complex artifacts, such as classes or modules. Type and Default : Boolean(false)","title":".parsers.x86_64.PerformGlobalAnalysis"},{"location":"engines-configuration.html#parsersx86_64performrttirecovery","text":"Description : Attempt C++ Run-Time Type Information (RTTI) discovery and rebuilding (MSVC and Itanium (GCC/CLANG/NDK) are supported) Type and Default : Boolean(true)","title":".parsers.x86_64.PerformRttiRecovery"},{"location":"engines-configuration.html#parsersx86_64prefersynchronousexecution","text":"Description : Synchronous analysis prevents access to the unit during a code analysis Type and Default : Boolean(false)","title":".parsers.x86_64.PreferSynchronousExecution"},{"location":"engines-configuration.html#parsersx86_64tailcallanalysisstyle","text":"Description : Search for possible tail calls optimized as branches, and build proper routines. Possible modes: 0 = deactivated 1 = automatic mode (heuristics depend on the file) 2 = safe heuristics only 3 = aggressive heuristics Type and Default : Integer(1){0-3}","title":".parsers.x86_64.TailCallAnalysisStyle"},{"location":"engines-configuration.html#parsersx86_64wantedendianness","text":"Description : Desired endianness for raw binaries: 'little'/'le', 'big'/'be'. May be overridden by the code parser. Type and Default : String(\"le\")","title":".parsers.x86_64.WantedEndianness"},{"location":"engines-configuration.html#parsersx86_64wantedimagebase","text":"Description : Desired memory base address for raw binaries. 0 by default. Type and Default : String(\"0\")","title":".parsers.x86_64.WantedImageBase"},{"location":"engines-configuration.html#parsersx86_64textblockxrefscount","text":"Description : Maximum number of cross-references displayed at any address Type and Default : Integer(50)","title":".parsers.x86_64.text.BlockXrefsCount"},{"location":"engines-configuration.html#parsersx86_64textcharbreak64bitaddresses","text":"Description : If not empty, the address column will display 64-bit addresses as two 8-hexdigit parts, separated by the provided character string Type and Default : String(\"'\")","title":".parsers.x86_64.text.CharBreak64BitAddresses"},{"location":"engines-configuration.html#parsersx86_64textgappreferrawformatting","text":"Description : Prefer raw formatting (dr XX, dr XXXX) for gaps and slack spaces instead of regular declarations (eg, db ??) Type and Default : Boolean(false)","title":".parsers.x86_64.text.GapPreferRawFormatting"},{"location":"engines-configuration.html#parsersx86_64textgaprawbytesperline","text":"Description : For raw formatting, determine the maximum number of bytes per line in gaps and slack spaces. Must be a power of 2, else reverts to the default. Type and Default : Integer(16){0+}","title":".parsers.x86_64.text.GapRawBytesPerLine"},{"location":"engines-configuration.html#parsersx86_64textgaprawintegersize","text":"Description : For raw formatting, determine the integer length (in bytes) used for rendering. Must be either 1, 2, 4, or 8, else reverts to the default Type and Default : Integer(1){0+}","title":".parsers.x86_64.text.GapRawIntegerSize"},{"location":"engines-configuration.html#parsersx86_64textinstructionarealength","text":"Description : Length in characters of the assembly column containing the instructions Type and Default : Integer(40){0+}","title":".parsers.x86_64.text.InstructionAreaLength"},{"location":"engines-configuration.html#parsersx86_64textlabelarealength","text":"Description : Length in characters of the assembly column containing the labels Type and Default : Integer(16){0+}","title":".parsers.x86_64.text.LabelAreaLength"},{"location":"engines-configuration.html#parsersx86_64textroutineseparatorlength","text":"Description : Number of characters used to build the line separating routines Type and Default : Integer(80){0+}","title":".parsers.x86_64.text.RoutineSeparatorLength"},{"location":"engines-configuration.html#parsersx86_64textshowaddresses","text":"Description : Display addresses of items Type and Default : Boolean(true)","title":".parsers.x86_64.text.ShowAddresses"},{"location":"engines-configuration.html#parsersx86_64textshowbytescount","text":"Description : Maximum count of instruction bytes to be displayed before the instruction Type and Default : Integer(0){0+}","title":".parsers.x86_64.text.ShowBytesCount"},{"location":"engines-configuration.html#parsersx86_64textshowsegmentheaders","text":"Description : Display the segment or section headers Type and Default : Boolean(true)","title":".parsers.x86_64.text.ShowSegmentHeaders"},{"location":"engines-configuration.html#parsersx86_64textshowspacebetweenblocks","text":"Description : Insert blank lines between basic blocks Type and Default : Boolean(false)","title":".parsers.x86_64.text.ShowSpaceBetweenBlocks"},{"location":"engines-configuration.html#projectalwaysprocessduplicateinputs","text":"Description : Always process binary inputs even if that input was seen earlier and processed as another unit already Type and Default : Boolean(false)","title":".project.AlwaysProcessDuplicateInputs"},{"location":"engines-configuration.html#projectartifactprocessingdepth","text":"Description : Determine the maximum depth an input artifact (eg, a file) will be explored to create units and sub-units representing analysis entities Type and Default : Integer(20){1+}","title":".project.ArtifactProcessingDepth"},{"location":"engines-configuration.html#projectcompresspersistedproject","text":"Description : Compress the JDB2 database (recommended) Type and Default : Boolean(true)","title":".project.CompressPersistedProject"},{"location":"engines-configuration.html#projectpersistencestrategy","text":"Description : Determine how a project will be saved to JDB2: 0: default (full save) 1: explicit full save 2: quick save Type and Default : Integer(0){0-2}","title":".project.PersistenceStrategy"},{"location":"ethereum.html","text":"Info This manual page assumes familiarity with common JEB actions and views . We also assume a minimal amount of knowledge of the Ethereum Virtual Machine bytecode and framework of operations. This was adapted from contents we published on our blog . Note The EVM decompiler update shipping with JEB 4, whose pre-release is planned for Q2 2020, fills up several gaps present in the first version of the decompiler. Capabilities # The Ethereum plugin provides the following specific capabilities: The EVM code analyzer determines a contract public and private methods, including implementations of public methods synthetically generated by compilers. This analysis attempts to determine method and event names and prototypes, without access to an ABI. The EVM decompiler decompiled the analyzed EVM code to Solidity-like source code. The decompiler attempts to recover various high-level constructs, including: Implementations of well-known interfaces, such as ERC20 for standard tokens, ERC721 for non-fungible tokens, MultiSigWallet contracts, etc. Storage variables and types High-level Solidity artifacts and idioms, including: Function mutability attributes Function payability state Event emission, including event name Invocations of address.send() or address.transfer() Precompiled contracts invocations Basic usage # Open a contract via the File, Open smart contract... menu entry. You will be offered two options: Open a binary file already stored on disk Or download and open a contract from one of the principal Ethereum networks: mainnet , rinkeby , ropsten , or kovan : Select the network Provide the contract 20-byte address Click Download and select a file destination Open a contract via the File, Open smart contract menu entry Note To be recognized as EVM code, a file must: have a \".evm-bytecode\" extension: in this case, the file may contain binary or hex-encoded code; or have a \".runtime\" or \".bin-runtime\" extension (as generated by the solc Solidity compiler) and contain hex-encoded Solidity generated code. If you are opening raw files, we recommend you append the \".evm-extension\" to them in order to guarantee that they will be processed as EVM contract code. Contract Processing # JEB will process your contract file and generate a class item to represent it: The Assembly view on the right panel shows the processed code. To switch to the decompiled view, select the \"Decompiled Contract\" node in the Code Hierarchy view, and press Tab (or right-click, Decompile). Right-click on items to bring up context menus showing the principal commands and shortcuts. The decompiled view of a contract. A decompiled contract is rendered in Solidity-like code: it is mostly Solidity code, but not entirely. Constructs that are illegal in Solidity are used throughout the code to represent instructions that the decompiler could not represent otherwise. Examples include: statements representing some low-level EVM instructions, memory accesses, or very rarely, goto statements. Do not expect a DecompiledContract to be easily recompiled. Code views # You may adjust the View panels to have side-by-side views if you wish to navigate the assembly and high-level code at the same time. In the assembly view, within a routine, press Space to visualize its control flow graph. To navigate from assembly to source, and back, press the Tab key. The caret will be positioned on the closest matching instruction. Side by side views: assembly and source Contract information # In the Project Explorer panel, double click the contract node (the node with the official Ethereum Foundation logo), and then select the Description tab in the opened view to see interesting information about the processed contract, such as: The detected compiler and/or its version (currently supported are variants of Solidity and Vyper compilers). The list of detected routines (private and public, with their hashes). The Swarm hash of the metadata file, if any. The contract was identified as being compiled with Solidity <= 0.4.21 Commands # The usual commands can be used to refactor and annotate the assembly or decompiled code. You will find the exhaustive list in the Action and Native menus. Here are basic commands: Rename items (methods, variables, globals, ...) using the N key Navigate the code by examining cross-references using the X key (e.g., find all callers of a method and jump to one of them) Comment using the Slash key As said earlier, the Tab key is useful to navigate back and forth from low-level EVM code to high-level decompiled code Rename an item (e.g., a variable) by pressing the N key Immediate number bases and rendering can be changed by using the B key. In the example below, you can see a couple of strings present in the bad Fomo3D contract, initially rendered in Hex: All immediates are rendered as hex-strings by default. Use the B key to cycle through base (10, 16, etc.) and rendering (number, ascii) Understanding decompiled contracts # This section highlights idioms you will encounter throughout decompiled pseudo-Solidity code. The examples below show the UI client set up to display EVM disassembly on the left side, and high-level decompiled code on the right side. The contracts used as examples are live contracts active on mainnet . Dispatcher and public functions # The entry-point function of a contract, at address 0, is generally its dispatcher. It is named start() by JEB, and in most cases will consist in an if-statement comparing the input CALLDATA hash (the first 4 bytes) to pre-calculated hashes, to determine which routine is to be executed. JEB attempts to determine public method names by using a hash dictionary (currently containing more than 140,000 entries). Contracts compiled by Solidity generally use synthetic (compiler generated) methods as bridges between public routines, that use the public Ethereum ABI, and internal routines, using a compiler-specific ABI. Those routines are identified as well and, if their corresponding public method was named, will be assigned a similar name __impl_{PUBLIC_NAME} . Limitation Currently, JEB does not attempt to process input data of public routines and massage it back into an explicit prototype with regular variables. Therefore, you will see low-level access to CALLDATA bytes within public methods. A dispatcher. Below, see the public method collectToken() , which is retrieving its first parameter \u2013 a 20 byte address \u2013 from the calldata . A public method reading its arguments from CALLDATA bytes. Interface discovery # At the time of writing, implementation of the following interfaces can be detected: ERC20, ERC165, ERC721, ERC721TokenReceiver, ERC721Metadata, ERC721Enumerable, ERC820, ERC223, ERC777, TokenFallback used by ERC223/ERC777 interfaces, as well as the common MultiSigWallet interface. E.g., the contract below was identified as an ERC20 token implementation: This contract implements all methods specified by the ERC20 interface. Function attributes # JEB does its best to retrieve: low-level state mutability attributes (pure, read-only, read-write) the high-level Solidity \u2018payable\u2019 attribute, reserved for public methods Explicitly non-payable functions have lower-level synthetic stubs that verify that no Ether is being received. They REVERT if it is is the case. If JEB decides to remove this stub, the function will always have an inline comment /* non payable */ to avoid any ambiguity. The contract below shows two public methods, one has a default mutability state (non-payable); the other one is payable. Note that the hash 0xFF03AD56 was not resolved, therefore the name of the method is unknown and was set to sub_AF ; you may also see a call to collect() \u2019s bridge function __impl_collect() , as was mentioned in the previous section. Two public methods, one is payable, the other is not and will revert if it receives Ether. Storage variables # The current decompiler has a rather limited storage reconstructor module. Accesses to primitives (int8 to int256, uint8 to uint256) is reconstructed in most cases Packed small primitives in storage words are extracted (e.g., a 256-bit storage word containing 2x uint8 and 1x int32, and accessed as such throughout the code, will yield 3 contract variables, as one would expect to see in a Solidity contract Four primitive storage variables were reconstructed. Limitation Currently, accesses to complex storage variables, such as mappings, mappings of mappings, mappings of structures, etc. are not simplified. This limitation will be addressed in a future update. When a storage variable is not resolved, you will see simple storage[...] assignments, such as: Unresolved storage assignment, here, to a mapping. Due to how storage on Ethereum is designed (a key-value store of uint256 to uint256), Solidity internally uses a two-or-more indirection level for computing actual storage keys. Those low-level storage keys depend on the position of the high level storage variables. The KECCAK256 opcode can be used to calculate intermediate and final keys. We will detail this mechanism in detail in a future blog post. Precompiled contracts # Ethereum defines at least four pre-compiled contracts at addresses 1, 2, 3, 4. Other addresses (5-8) have been reserved for additional pre-compiled contracts. JEB identifies CALLs that will eventually lead to pre-compiled code execution, and marks them as such in decompiled code: call_{specific}. The example below shows the __impl_Receive (named recovered) method of the 34C3 CTF contract, which calls into address #2, a pre-compiled contract providing a fast implementation of SHA-256. This contract calls address 2 to calculate the SHA-256 of a binary blob. Ether send() # Solidity's send can be translated into a lower-level call with a standard gas stipend and zero parameters. It is essentially used to send Ether to a contract through the target contract fall-back function. Currently, JEB renders them as send(address, amount) instead of address.send(amount) . The contract below is live on mainnet . It is a simple forwarder, that does not store ether: it forwards the received amount to another contract. This contract makes use of address.send(...) to send Ether Ether transfer() # Solidity\u2019s transfer is an even higher-level variant of send that checks and REVERTs with data if CALL failed. JEB identifies those calls as well. Currently, JEB renders them as transfer(address, amount) instead of address.transfer(amount) . This contract makes use of address.transfer(...) to send Ether Event emission # JEB attempts to partially reconstruct LOGx (x in 1..4) opcodes back into high-level Solidity emit Event(...) . The event name is resolved by reversing the Event method prototype hash. If JEB cannot reverse a LOGx instruction, or if LOG0 is used, then a lower-level log(...) call will be used. Currently, the event parameters are not processed; therefore, the emit construct used in the decompiled code has the following form: emit Event(memory, size[, topic2[, topic3[, topic4]]]) . topic1 is always used to store the event prototype hash. An Invocation of LOG4 reversed to an emit Deposit(...) event emission API # The EVM analysis modules are built onto the native code analysis pipeline of JEB. Therefore, standard APIs can be used to automate analysis tasks. In particular, the decompiler API gives access to: the intermediate representation (IR) the final Solidity-like representation (AST) Example This sample script demonstrates how to retrieve the decompiled EVM code of an Ethereum contract and print out AST nodes: code Refer to \"Extending JEB\" to get started with developing scripts or plugins for JEB.","title":"Ethereum Analysis"},{"location":"ethereum.html#capabilities","text":"The Ethereum plugin provides the following specific capabilities: The EVM code analyzer determines a contract public and private methods, including implementations of public methods synthetically generated by compilers. This analysis attempts to determine method and event names and prototypes, without access to an ABI. The EVM decompiler decompiled the analyzed EVM code to Solidity-like source code. The decompiler attempts to recover various high-level constructs, including: Implementations of well-known interfaces, such as ERC20 for standard tokens, ERC721 for non-fungible tokens, MultiSigWallet contracts, etc. Storage variables and types High-level Solidity artifacts and idioms, including: Function mutability attributes Function payability state Event emission, including event name Invocations of address.send() or address.transfer() Precompiled contracts invocations","title":"Capabilities"},{"location":"ethereum.html#basic-usage","text":"Open a contract via the File, Open smart contract... menu entry. You will be offered two options: Open a binary file already stored on disk Or download and open a contract from one of the principal Ethereum networks: mainnet , rinkeby , ropsten , or kovan : Select the network Provide the contract 20-byte address Click Download and select a file destination Open a contract via the File, Open smart contract menu entry Note To be recognized as EVM code, a file must: have a \".evm-bytecode\" extension: in this case, the file may contain binary or hex-encoded code; or have a \".runtime\" or \".bin-runtime\" extension (as generated by the solc Solidity compiler) and contain hex-encoded Solidity generated code. If you are opening raw files, we recommend you append the \".evm-extension\" to them in order to guarantee that they will be processed as EVM contract code.","title":"Basic usage"},{"location":"ethereum.html#contract-processing","text":"JEB will process your contract file and generate a class item to represent it: The Assembly view on the right panel shows the processed code. To switch to the decompiled view, select the \"Decompiled Contract\" node in the Code Hierarchy view, and press Tab (or right-click, Decompile). Right-click on items to bring up context menus showing the principal commands and shortcuts. The decompiled view of a contract. A decompiled contract is rendered in Solidity-like code: it is mostly Solidity code, but not entirely. Constructs that are illegal in Solidity are used throughout the code to represent instructions that the decompiler could not represent otherwise. Examples include: statements representing some low-level EVM instructions, memory accesses, or very rarely, goto statements. Do not expect a DecompiledContract to be easily recompiled.","title":"Contract Processing"},{"location":"ethereum.html#code-views","text":"You may adjust the View panels to have side-by-side views if you wish to navigate the assembly and high-level code at the same time. In the assembly view, within a routine, press Space to visualize its control flow graph. To navigate from assembly to source, and back, press the Tab key. The caret will be positioned on the closest matching instruction. Side by side views: assembly and source","title":"Code views"},{"location":"ethereum.html#contract-information","text":"In the Project Explorer panel, double click the contract node (the node with the official Ethereum Foundation logo), and then select the Description tab in the opened view to see interesting information about the processed contract, such as: The detected compiler and/or its version (currently supported are variants of Solidity and Vyper compilers). The list of detected routines (private and public, with their hashes). The Swarm hash of the metadata file, if any. The contract was identified as being compiled with Solidity <= 0.4.21","title":"Contract information"},{"location":"ethereum.html#commands","text":"The usual commands can be used to refactor and annotate the assembly or decompiled code. You will find the exhaustive list in the Action and Native menus. Here are basic commands: Rename items (methods, variables, globals, ...) using the N key Navigate the code by examining cross-references using the X key (e.g., find all callers of a method and jump to one of them) Comment using the Slash key As said earlier, the Tab key is useful to navigate back and forth from low-level EVM code to high-level decompiled code Rename an item (e.g., a variable) by pressing the N key Immediate number bases and rendering can be changed by using the B key. In the example below, you can see a couple of strings present in the bad Fomo3D contract, initially rendered in Hex: All immediates are rendered as hex-strings by default. Use the B key to cycle through base (10, 16, etc.) and rendering (number, ascii)","title":"Commands"},{"location":"ethereum.html#understanding-decompiled-contracts","text":"This section highlights idioms you will encounter throughout decompiled pseudo-Solidity code. The examples below show the UI client set up to display EVM disassembly on the left side, and high-level decompiled code on the right side. The contracts used as examples are live contracts active on mainnet .","title":"Understanding decompiled contracts"},{"location":"ethereum.html#dispatcher-and-public-functions","text":"The entry-point function of a contract, at address 0, is generally its dispatcher. It is named start() by JEB, and in most cases will consist in an if-statement comparing the input CALLDATA hash (the first 4 bytes) to pre-calculated hashes, to determine which routine is to be executed. JEB attempts to determine public method names by using a hash dictionary (currently containing more than 140,000 entries). Contracts compiled by Solidity generally use synthetic (compiler generated) methods as bridges between public routines, that use the public Ethereum ABI, and internal routines, using a compiler-specific ABI. Those routines are identified as well and, if their corresponding public method was named, will be assigned a similar name __impl_{PUBLIC_NAME} . Limitation Currently, JEB does not attempt to process input data of public routines and massage it back into an explicit prototype with regular variables. Therefore, you will see low-level access to CALLDATA bytes within public methods. A dispatcher. Below, see the public method collectToken() , which is retrieving its first parameter \u2013 a 20 byte address \u2013 from the calldata . A public method reading its arguments from CALLDATA bytes.","title":"Dispatcher and public functions"},{"location":"ethereum.html#interface-discovery","text":"At the time of writing, implementation of the following interfaces can be detected: ERC20, ERC165, ERC721, ERC721TokenReceiver, ERC721Metadata, ERC721Enumerable, ERC820, ERC223, ERC777, TokenFallback used by ERC223/ERC777 interfaces, as well as the common MultiSigWallet interface. E.g., the contract below was identified as an ERC20 token implementation: This contract implements all methods specified by the ERC20 interface.","title":"Interface discovery"},{"location":"ethereum.html#function-attributes","text":"JEB does its best to retrieve: low-level state mutability attributes (pure, read-only, read-write) the high-level Solidity \u2018payable\u2019 attribute, reserved for public methods Explicitly non-payable functions have lower-level synthetic stubs that verify that no Ether is being received. They REVERT if it is is the case. If JEB decides to remove this stub, the function will always have an inline comment /* non payable */ to avoid any ambiguity. The contract below shows two public methods, one has a default mutability state (non-payable); the other one is payable. Note that the hash 0xFF03AD56 was not resolved, therefore the name of the method is unknown and was set to sub_AF ; you may also see a call to collect() \u2019s bridge function __impl_collect() , as was mentioned in the previous section. Two public methods, one is payable, the other is not and will revert if it receives Ether.","title":"Function attributes"},{"location":"ethereum.html#storage-variables","text":"The current decompiler has a rather limited storage reconstructor module. Accesses to primitives (int8 to int256, uint8 to uint256) is reconstructed in most cases Packed small primitives in storage words are extracted (e.g., a 256-bit storage word containing 2x uint8 and 1x int32, and accessed as such throughout the code, will yield 3 contract variables, as one would expect to see in a Solidity contract Four primitive storage variables were reconstructed. Limitation Currently, accesses to complex storage variables, such as mappings, mappings of mappings, mappings of structures, etc. are not simplified. This limitation will be addressed in a future update. When a storage variable is not resolved, you will see simple storage[...] assignments, such as: Unresolved storage assignment, here, to a mapping. Due to how storage on Ethereum is designed (a key-value store of uint256 to uint256), Solidity internally uses a two-or-more indirection level for computing actual storage keys. Those low-level storage keys depend on the position of the high level storage variables. The KECCAK256 opcode can be used to calculate intermediate and final keys. We will detail this mechanism in detail in a future blog post.","title":"Storage variables"},{"location":"ethereum.html#precompiled-contracts","text":"Ethereum defines at least four pre-compiled contracts at addresses 1, 2, 3, 4. Other addresses (5-8) have been reserved for additional pre-compiled contracts. JEB identifies CALLs that will eventually lead to pre-compiled code execution, and marks them as such in decompiled code: call_{specific}. The example below shows the __impl_Receive (named recovered) method of the 34C3 CTF contract, which calls into address #2, a pre-compiled contract providing a fast implementation of SHA-256. This contract calls address 2 to calculate the SHA-256 of a binary blob.","title":"Precompiled contracts"},{"location":"ethereum.html#ether-send","text":"Solidity's send can be translated into a lower-level call with a standard gas stipend and zero parameters. It is essentially used to send Ether to a contract through the target contract fall-back function. Currently, JEB renders them as send(address, amount) instead of address.send(amount) . The contract below is live on mainnet . It is a simple forwarder, that does not store ether: it forwards the received amount to another contract. This contract makes use of address.send(...) to send Ether","title":"Ether send()"},{"location":"ethereum.html#ether-transfer","text":"Solidity\u2019s transfer is an even higher-level variant of send that checks and REVERTs with data if CALL failed. JEB identifies those calls as well. Currently, JEB renders them as transfer(address, amount) instead of address.transfer(amount) . This contract makes use of address.transfer(...) to send Ether","title":"Ether transfer()"},{"location":"ethereum.html#event-emission","text":"JEB attempts to partially reconstruct LOGx (x in 1..4) opcodes back into high-level Solidity emit Event(...) . The event name is resolved by reversing the Event method prototype hash. If JEB cannot reverse a LOGx instruction, or if LOG0 is used, then a lower-level log(...) call will be used. Currently, the event parameters are not processed; therefore, the emit construct used in the decompiled code has the following form: emit Event(memory, size[, topic2[, topic3[, topic4]]]) . topic1 is always used to store the event prototype hash. An Invocation of LOG4 reversed to an emit Deposit(...) event emission","title":"Event emission"},{"location":"ethereum.html#api","text":"The EVM analysis modules are built onto the native code analysis pipeline of JEB. Therefore, standard APIs can be used to automate analysis tasks. In particular, the decompiler API gives access to: the intermediate representation (IR) the final Solidity-like representation (AST) Example This sample script demonstrates how to retrieve the decompiled EVM code of an Ethereum contract and print out AST nodes: code Refer to \"Extending JEB\" to get started with developing scripts or plugins for JEB.","title":"API"},{"location":"faq.html","text":"Frequently asked answers to common questions and issues regarding JEB 3+. The last section is for questions regarding JEB 2, and is kept for reference only. All users are encouraged to migrate to the latest version of JEB. Licensing # Where is the end-user license agreement? # The up-to-date end-user license agreement for JEB can be found here . Can I generate license keys for additional machines? # Yes, as long as the additional machines are operated by the licensee, they may install JEB on them. Contact licensing to request the ability to generate additional keys. We handle those requests promptly. Can I revoke license keys? # Yes, JEB license keys can be deprecated. Contact licensing to request key revocation. We handle those requests promptly. How do I check my license type, license identifier, or license key? # From the command-line: execute JEB with the -c --license switches, eg: $ jeb_wincon.bat -c --license From the UI client: open the menu entry Help, About . How do floating licenses work? # Floating licenses work on a per-seat basis, as opposed to other license types that work on a per-user basis. Example: A floating build valid for 3 seats allow any 3 users within your organization concurrently. A non-floating build valid for 3 users allow 3 fixed, determined users to use JEB. No other user can use it. Therefore, floating builds provide great flexibility for organizations where many users are planning to use JEB irregularly and/or at different times (e.g., teams split across various regions). Please refer to this Manual entry to learn about setting up floating Controller and Clients. What happens when my license subscription expires? # JEB works on subscription. Past the expiration date, your software will continue to work and allow you to open and work on existing JDB2 projects, but you will not be able to create new projects. Do subscriptions renew automatically? # No. We do not perform auto-payments or auto-renewals. Please email sales when you need to renew a subscription. Do you offer subscriptions valid for more than one year? # Yes, we do offer custom subscriptions for up to 3 years. Email us at sales for details. Do you offer perpetual licenses? # No, we do not offer perpetual licenses at this point. However, we recommend you email sales and let us know your specific needs: we always strive to accommodate our customer's needs. Do you provide professional support? # We do offer an additional support plan for JEB Pro and JEB Pro Floating licenses. Refer to the Buy page for details. Do you offer large volume subscriptions? # Yes, we do have plans for large enterprise and government. Those plans include the possibility to generate large amount of license keys. Reach out to sales for additional details. We developed internal tools built around JEB. Can other users in my organization use them without breaking the EULA? # Yes. As long as your JEB subscription is valid, users in your organization may access and use data produced by JEB. Java # Which version of Java shall I use to run JEB UI client? # We recommend users to run the JEB client with a recent version of the Java 8 JDK . You may use newer versions of Java (9 and above, so called \"modern\" Java) as well. However, at the time of writing, the native launcher (jeb.exe on Windows, jeb on Linux, jeb.app/ on macOS) may not start as smoothly with those newer JDK. If that happens, you can bypass the native launcher by using the -j flag with your start-up script. Example, on Linux: jeb_linux.sh -j . If you have installed multiple versions of Java, we recommend you set the JAVA_HOME environment variable to point to your JDK version 8 folder. Finally, the JEB client can always be started directly by running jebc.jar on the command line: java -jar bin/app/jebc.jar Which version of Java shall I use to run non-UI clients? # The back-end components of JEB (jeb.jar) work fine with with any version of Java 8.191 or above. JEB complains that it \"requires a Java runtime environment\", although I have one installed. # Your java binary should be accessible from the PATH environment variable. It is also recommended to set a JAVA_HOME environment variable pointing to your Java installation folder (bin/). Make sure to install a 64-bit Java environment. A common source of problems are 64-bit systems having a 32-bit JRE accessible from the PATH or JAVA_HOME. You may have different versions of Java installed, but always make sure that paths refer to one that matches your system specifications. How can I increase the maximum amount of memory usable by JEB? # Edit the jvmopt.txt file at the root of your JEB folder. To increase the maximum amount of memory usable by JEB, adjust the -Xmx value. Example: -Xmx8G : allow JEB to use up to 8 Gb of memory. The settings in jvmopt.txt must be on a single line. After modifying this file, restart JEB with your usual start-up script. On start-up, a message in the logger output will reflect the updated capability: Warning Do not edit the configuration files buried in bin/app/... or bin/jeb.app/... folders. The memory settings in those files are automatically pulled from jvmopt.txt. Program # On which platforms can I run JEB? # The UI desktop client runs on 64-bit Windows, Linux, and macOS. The JEB back-end components, which can be used separately to build other clients or analysis pipelines, run on all systems (64-bit and 32-bit) for which a Java Runtime Environment version 8 or above is available. What do I need to run JEB? # The only external dependency is a Java JRE or JDK. We encourage users to install and use a recent Java JDK 8 to have a smooth JEB experience. How can I run multiple instances of JEB? # Multiple instances of JEB can run natively without configuration changes. How can I redirect JEB logs to files on disk? # Command-line runners, such as the floating license Controller or a script runner, can easily write log output to files. JEB version 3.1.1+ is required. (Note that other clients, such as the UI desktop client, can do that via scripting - refer to GlobalLog .) Use the --logfile=... flag. Consult the Usage info for additional details on that switch ( \"--help\" ) Example: Start a JEB Controller on Windows and log all INFO-level (or above) output to \"controller.log.N\" files (max. 5 rotating files, max. 2 Mb of log per file): jeb_wincon.bat -c --controller --logfiles=controller.log,INFO,5,2 UI # JEB messages and strings are in my current (non-English) locale. How do I switch to English? # By default, JEB does its best to display messages in the current user's language settings. You may change the locale to English (or another one of the 10 supported languages ) via the Edit, Language menu. See the Settings for details. I am trying to debug an Android application, but my device cannot be found. # JEB relies on the Android Debug Bridge ( adb ) to debug Android applications. Make sure to: install the Android SDK (or at least have a stand-alone, working adb binary accessible from your PATH - some Linux distributions ship adb and other SDK platform tools in separate, leaner packages) have the SDK path referenced in one of the following environment variables: ANDROID_SDK_ROOT (preferred) or ANDROID_HOME (legacy). To troubleshoot your system, you may enable Developer Mode in your JEB options and examine the logger output. You will see lines like the following indicating how and where JEB is attempting to find adb : [adb] ANDROID_HOME: Environment variable added to list of candidate Android SDK locations [adb] ANDROID_SDK_ROOT: Environment variable NOT found [adb] PATH: added to list of searched folders: (redacted) [adb] Searching for 'adb.exe' in folders, by order: (redacted) [adb] Found and using: C:\\Users\\nicol\\AppData\\Local\\Android\\sdk\\platform-tools\\adb.exe Inside \"Find text\" widgets or filter fields, why are my regular expressions invalid or not working? # JEB uses Java-style regular expressions, not PCRE, Boost, or other type of regex. Although the differences are minimal and subtle, complex regular expressions need to be carefully crafted and abide by the Java Pattern standard (refer to the \"Comparison to Perl 5\" section specifically). Updating # I work in a limited-connectivity environment, how can I update the software manually? # If you are updating from JEB 2.2.5 or above, simply follow the prompt when JEB starts up or follow the procedure when executing the menu entry Help, Software Update . If you are updating from JEB 2.2.4 or below, the procedure is the following: Check your registered email address for a JEB update email ( \"JEB xxx is available...\" ) Download the software archive Copy the archive to the root of your JEB folder and rename the file to update.zip Create a text file named update.pwd Store the email-provided password inside this file Start JEB as normal; the update will be installed automatically I access Internet via a proxy. Can I still use JEB? # First, make sure to use JEB 3.0.8 or above. Proxy settings can be stored at those two locations: The UI client's settings, stored in jeb-client.cfg . If you are using the UI desktop client, they can be modified via the Options panel. In headless mode, set the proxy settings in jeb-engines.cfg instead. In each aforementioned configuration file, the network proxy data is stored as a key-value pair having the following format: .NetworkProxy = type|hostname|port|<username>|<password>|<whitelist> Allowed types: http , socks . 'username'/'password' can be left blank if your proxy does not require authentication 'whitelist' is an optional, comma-separated list of wildcard hostnames/IPs to which JEB should always attempt to direct-connect (no proxy) A few examples of valid proxy strings: - http|10.0.0.123|8080 - http|10.0.0.123|8080|| - http|10.0.0.123|8080||| - http|10.0.0.123|8080|||*.pnfsoftware.com - socks|proxy0.intranet.com|8088|user|pass|*.pnfsoftware.com Warning Do not forget the leading dot in .NetworkProxy! How do I update from JEB 2 to JEB 3? # At the time of writing, you must install JEB 3 in a separate location. The auto-updater of JEB 2 will only notify you that a JEB 3 build is available for you to install. Check your email to download and install JEB 3. Can I update from the command-line? # Yes, you can run: $ <jeb_startup_script> -c --check-update After the update is downloaded, execute JEB normally. JEB just auto-updated and I am now experiencing strange runtime issues. What can I do? # If the issues you are experiencing are showing up after a software update, at seemingly random times during program execution, and involve error messages like \"Error invoking method\" or \"Failed to launch JVM\" , it is likely that your last JEB update did not fully complete. Try to execute your start-up script (eg, on Windows, jeb_wincon.bat ) instead of any native launcher you may have been previously using (such as an OS desktop task bar shortcut). If the issue is recurring, please email Support . Scripting # Can I execute a JEB Python script from the command line? # Yes. Here's how to use the built-in script runner. You will need a Pro license. Make sure your JEB scripts/ folder contains the jython-xxx.jar . It should be the case if you are using JEB 3.1. Execute your JEB startup script with --srv2 and --script parameters, as well as optional script arguments after -- Example on Windows: $ jeb_wincon.bat -c --srv2 --script = SampleScript.py -- foo bar Use -c --help to learn about other options. API Command-line arguments (in the example above: foo , bar ) can be retrieved via IClientContext . Extensions Alternate ways exist to run scripts or plugins in headless contexts. Read through this guide and associated sample code if you want to know more about writing your own front-end clients. Can I write back-end extensions (plugins, contributions, etc.) in Python? # Not at the moment. Back-end extensions should be written in Java (or any other language compiling to Java classfile, e.g. Kotlin). Other # Is there a public bug/feature tracker? # Not at the moment. We are pretty responsive when it comes to answering users' queries though. Here's how to reach out: Send an email to Support Join us on Slack Ask your question on the JEB Google Groups Tweet or DM us @jebdec JEB 2 (Legacy) # (JEB 2) Can I run the JEB 2 desktop client on my 32-bit machine? # Yes. Prior to JEB 3.0-beta.8, JEB UI can also run on Windows 32-bit and Linux 32-bit. (JEB 2) Which version of Java shall I use to run JEB 2? # The desktop client requires Java 8. The back-end components ( jeb.jar ) work fine with with Java 8 and beyond. (JEB 2) How can I increase the maximum amount of memory usable by JEB? # If unspecified, the memory cap is automatically decided upon starting up - and it will almost certainly be lower than what your system can offer. In order to manually specify the maximum amount of memory usable by JEB, edit the file bin/jeb.ini located in your JEB folder. Add the following lines: -vmargs -Xmx????m Replace ???? by the size amount of your choice, in Mb; eg, 4096 to allow JEB to use up to 4Gb. Note that other Java Virtual Machine options may be provided after the -vmargs (one option per line). Refer to the JVM manual for a complete list of options. (JEB 2) I just upgraded to Java 8u131 or above (or Java 7u131), and JEB close immediately after start-up. What can I do? # The probable reason is that you must be using JEB 2.2.10 or below. Older versions of JEB are no compatible with the newer JDK/SDK. There are two ways to solve this problem: If you wish to stay on the JEB 2.2.x branch, install the latest update 2.2.11. You may use Java 7 or Java 8. We recommend you upgrade to the latest version of JEB, on the 2.3 or 3.0 branch. Make sure to use Java 8. (JEB 2) How can I run multiple instances of JEB? # Start your second and more instances of the UI client by using the -data @none command-line argument. Example on Windows: $ jeb_wincon.bat -data @none Note that the customization of your UI workspace will not be ported over to this new instance, and will not be persisted upon closing either. (JEB 2) JEB closes unexpectedly at start-up. How do I troubleshoot potential issues? # By default, console messages generated by JEB are logged to the workspace/*log or workspace/.metadata/.log file within your JEB directory. If you are using the UI client, adding those settings to your bin/jeb.ini file will instruct the UI framework to log debug messages to the console: -debug -consoleLog -noExit Make sure to add them before any -vmarg parameter! Restart JEB and examine the console log. If all else fails, please reach out to Support . (JEB 2) How to execute a JEB Python script from the command line with JEB 2.3.4 (or older)? # Here is how to run Python scripts in a headless environment with JEB 2.3.4 or older: Make sure to drop a copy of Jython stand-alone JAR into your scripts folder Navigate to your JEB folder, sub-folder bin/cl Execute jeb.jar with --script and --libdir parameters, as well as optional script arguments (preceded by -- ) Also remember to set up two Java properties, using -Dkey=value command-lines flags: jeb.engcfg : points to your jeb-engines.cfg file jeb.lickey : contains a valid JEB license key (such as the value referenced in .LicenseKey in your jeb-client.cfg file) Example: $ java -Djeb.engcfg = jeb-engines.cfg -Djeb.lickey = xxxxxxx -jar jeb.jar --script = 1 .py --libdir = xxxxx -- arg1 arg2 ... API The command-line arguments (arg1, arg2, ...) can be retrieved via IClientContext . (JEB 2) I cannot find menu entry [xxx] , where is it? # You may need to reset the user interface state, via the Reset, UI State menu entry. A hard reset is to remove your workspace/ folder within your JEB installation folder. (JEB 2) What are the views marked as \"Unbound\" in the UI Client? # Those entries are layout placeholders from previous JEB sessions. They help JEB determine the best location to display a unit of a given type. (Note that \"Unbound Views\" can be closed at any time.) In the example below, DEX views and Java Decompiled views would be opened in their corresponding placeholders before attempting to create additional views.","title":"FAQ"},{"location":"faq.html#licensing","text":"","title":"Licensing"},{"location":"faq.html#where-is-the-end-user-license-agreement","text":"The up-to-date end-user license agreement for JEB can be found here .","title":"Where is the end-user license agreement?"},{"location":"faq.html#can-i-generate-license-keys-for-additional-machines","text":"Yes, as long as the additional machines are operated by the licensee, they may install JEB on them. Contact licensing to request the ability to generate additional keys. We handle those requests promptly.","title":"Can I generate license keys for additional machines?"},{"location":"faq.html#can-i-revoke-license-keys","text":"Yes, JEB license keys can be deprecated. Contact licensing to request key revocation. We handle those requests promptly.","title":"Can I revoke license keys?"},{"location":"faq.html#how-do-i-check-my-license-type-license-identifier-or-license-key","text":"From the command-line: execute JEB with the -c --license switches, eg: $ jeb_wincon.bat -c --license From the UI client: open the menu entry Help, About .","title":"How do I check my license type, license identifier, or license key?"},{"location":"faq.html#how-do-floating-licenses-work","text":"Floating licenses work on a per-seat basis, as opposed to other license types that work on a per-user basis. Example: A floating build valid for 3 seats allow any 3 users within your organization concurrently. A non-floating build valid for 3 users allow 3 fixed, determined users to use JEB. No other user can use it. Therefore, floating builds provide great flexibility for organizations where many users are planning to use JEB irregularly and/or at different times (e.g., teams split across various regions). Please refer to this Manual entry to learn about setting up floating Controller and Clients.","title":"How do floating licenses work?"},{"location":"faq.html#what-happens-when-my-license-subscription-expires","text":"JEB works on subscription. Past the expiration date, your software will continue to work and allow you to open and work on existing JDB2 projects, but you will not be able to create new projects.","title":"What happens when my license subscription expires?"},{"location":"faq.html#do-subscriptions-renew-automatically","text":"No. We do not perform auto-payments or auto-renewals. Please email sales when you need to renew a subscription.","title":"Do subscriptions renew automatically?"},{"location":"faq.html#do-you-offer-subscriptions-valid-for-more-than-one-year","text":"Yes, we do offer custom subscriptions for up to 3 years. Email us at sales for details.","title":"Do you offer subscriptions valid for more than one year?"},{"location":"faq.html#do-you-offer-perpetual-licenses","text":"No, we do not offer perpetual licenses at this point. However, we recommend you email sales and let us know your specific needs: we always strive to accommodate our customer's needs.","title":"Do you offer perpetual licenses?"},{"location":"faq.html#do-you-provide-professional-support","text":"We do offer an additional support plan for JEB Pro and JEB Pro Floating licenses. Refer to the Buy page for details.","title":"Do you provide professional support?"},{"location":"faq.html#do-you-offer-large-volume-subscriptions","text":"Yes, we do have plans for large enterprise and government. Those plans include the possibility to generate large amount of license keys. Reach out to sales for additional details.","title":"Do you offer large volume subscriptions?"},{"location":"faq.html#we-developed-internal-tools-built-around-jeb-can-other-users-in-my-organization-use-them-without-breaking-the-eula","text":"Yes. As long as your JEB subscription is valid, users in your organization may access and use data produced by JEB.","title":"We developed internal tools built around JEB. Can other users in my organization use them without breaking the EULA?"},{"location":"faq.html#java","text":"","title":"Java"},{"location":"faq.html#which-version-of-java-shall-i-use-to-run-jeb-ui-client","text":"We recommend users to run the JEB client with a recent version of the Java 8 JDK . You may use newer versions of Java (9 and above, so called \"modern\" Java) as well. However, at the time of writing, the native launcher (jeb.exe on Windows, jeb on Linux, jeb.app/ on macOS) may not start as smoothly with those newer JDK. If that happens, you can bypass the native launcher by using the -j flag with your start-up script. Example, on Linux: jeb_linux.sh -j . If you have installed multiple versions of Java, we recommend you set the JAVA_HOME environment variable to point to your JDK version 8 folder. Finally, the JEB client can always be started directly by running jebc.jar on the command line: java -jar bin/app/jebc.jar","title":"Which version of Java shall I use to run JEB UI client?"},{"location":"faq.html#which-version-of-java-shall-i-use-to-run-non-ui-clients","text":"The back-end components of JEB (jeb.jar) work fine with with any version of Java 8.191 or above.","title":"Which version of Java shall I use to run non-UI clients?"},{"location":"faq.html#jeb-complains-that-it-requires-a-java-runtime-environment-although-i-have-one-installed","text":"Your java binary should be accessible from the PATH environment variable. It is also recommended to set a JAVA_HOME environment variable pointing to your Java installation folder (bin/). Make sure to install a 64-bit Java environment. A common source of problems are 64-bit systems having a 32-bit JRE accessible from the PATH or JAVA_HOME. You may have different versions of Java installed, but always make sure that paths refer to one that matches your system specifications.","title":"JEB complains that it \"requires a Java runtime environment\", although I have one installed."},{"location":"faq.html#how-can-i-increase-the-maximum-amount-of-memory-usable-by-jeb","text":"Edit the jvmopt.txt file at the root of your JEB folder. To increase the maximum amount of memory usable by JEB, adjust the -Xmx value. Example: -Xmx8G : allow JEB to use up to 8 Gb of memory. The settings in jvmopt.txt must be on a single line. After modifying this file, restart JEB with your usual start-up script. On start-up, a message in the logger output will reflect the updated capability: Warning Do not edit the configuration files buried in bin/app/... or bin/jeb.app/... folders. The memory settings in those files are automatically pulled from jvmopt.txt.","title":"How can I increase the maximum amount of memory usable by JEB?"},{"location":"faq.html#program","text":"","title":"Program"},{"location":"faq.html#on-which-platforms-can-i-run-jeb","text":"The UI desktop client runs on 64-bit Windows, Linux, and macOS. The JEB back-end components, which can be used separately to build other clients or analysis pipelines, run on all systems (64-bit and 32-bit) for which a Java Runtime Environment version 8 or above is available.","title":"On which platforms can I run JEB?"},{"location":"faq.html#what-do-i-need-to-run-jeb","text":"The only external dependency is a Java JRE or JDK. We encourage users to install and use a recent Java JDK 8 to have a smooth JEB experience.","title":"What do I need to run JEB?"},{"location":"faq.html#how-can-i-run-multiple-instances-of-jeb","text":"Multiple instances of JEB can run natively without configuration changes.","title":"How can I run multiple instances of JEB?"},{"location":"faq.html#how-can-i-redirect-jeb-logs-to-files-on-disk","text":"Command-line runners, such as the floating license Controller or a script runner, can easily write log output to files. JEB version 3.1.1+ is required. (Note that other clients, such as the UI desktop client, can do that via scripting - refer to GlobalLog .) Use the --logfile=... flag. Consult the Usage info for additional details on that switch ( \"--help\" ) Example: Start a JEB Controller on Windows and log all INFO-level (or above) output to \"controller.log.N\" files (max. 5 rotating files, max. 2 Mb of log per file): jeb_wincon.bat -c --controller --logfiles=controller.log,INFO,5,2","title":"How can I redirect JEB logs to files on disk?"},{"location":"faq.html#ui","text":"","title":"UI"},{"location":"faq.html#jeb-messages-and-strings-are-in-my-current-non-english-locale-how-do-i-switch-to-english","text":"By default, JEB does its best to display messages in the current user's language settings. You may change the locale to English (or another one of the 10 supported languages ) via the Edit, Language menu. See the Settings for details.","title":"JEB messages and strings are in my current (non-English) locale. How do I switch to English?"},{"location":"faq.html#i-am-trying-to-debug-an-android-application-but-my-device-cannot-be-found","text":"JEB relies on the Android Debug Bridge ( adb ) to debug Android applications. Make sure to: install the Android SDK (or at least have a stand-alone, working adb binary accessible from your PATH - some Linux distributions ship adb and other SDK platform tools in separate, leaner packages) have the SDK path referenced in one of the following environment variables: ANDROID_SDK_ROOT (preferred) or ANDROID_HOME (legacy). To troubleshoot your system, you may enable Developer Mode in your JEB options and examine the logger output. You will see lines like the following indicating how and where JEB is attempting to find adb : [adb] ANDROID_HOME: Environment variable added to list of candidate Android SDK locations [adb] ANDROID_SDK_ROOT: Environment variable NOT found [adb] PATH: added to list of searched folders: (redacted) [adb] Searching for 'adb.exe' in folders, by order: (redacted) [adb] Found and using: C:\\Users\\nicol\\AppData\\Local\\Android\\sdk\\platform-tools\\adb.exe","title":"I am trying to debug an Android application, but my device cannot be found."},{"location":"faq.html#inside-find-text-widgets-or-filter-fields-why-are-my-regular-expressions-invalid-or-not-working","text":"JEB uses Java-style regular expressions, not PCRE, Boost, or other type of regex. Although the differences are minimal and subtle, complex regular expressions need to be carefully crafted and abide by the Java Pattern standard (refer to the \"Comparison to Perl 5\" section specifically).","title":"Inside \"Find text\" widgets or filter fields, why are my regular expressions invalid or not working?"},{"location":"faq.html#updating","text":"","title":"Updating"},{"location":"faq.html#i-work-in-a-limited-connectivity-environment-how-can-i-update-the-software-manually","text":"If you are updating from JEB 2.2.5 or above, simply follow the prompt when JEB starts up or follow the procedure when executing the menu entry Help, Software Update . If you are updating from JEB 2.2.4 or below, the procedure is the following: Check your registered email address for a JEB update email ( \"JEB xxx is available...\" ) Download the software archive Copy the archive to the root of your JEB folder and rename the file to update.zip Create a text file named update.pwd Store the email-provided password inside this file Start JEB as normal; the update will be installed automatically","title":"I work in a limited-connectivity environment, how can I update the software manually?"},{"location":"faq.html#i-access-internet-via-a-proxy-can-i-still-use-jeb","text":"First, make sure to use JEB 3.0.8 or above. Proxy settings can be stored at those two locations: The UI client's settings, stored in jeb-client.cfg . If you are using the UI desktop client, they can be modified via the Options panel. In headless mode, set the proxy settings in jeb-engines.cfg instead. In each aforementioned configuration file, the network proxy data is stored as a key-value pair having the following format: .NetworkProxy = type|hostname|port|<username>|<password>|<whitelist> Allowed types: http , socks . 'username'/'password' can be left blank if your proxy does not require authentication 'whitelist' is an optional, comma-separated list of wildcard hostnames/IPs to which JEB should always attempt to direct-connect (no proxy) A few examples of valid proxy strings: - http|10.0.0.123|8080 - http|10.0.0.123|8080|| - http|10.0.0.123|8080||| - http|10.0.0.123|8080|||*.pnfsoftware.com - socks|proxy0.intranet.com|8088|user|pass|*.pnfsoftware.com Warning Do not forget the leading dot in .NetworkProxy!","title":"I access Internet via a proxy. Can I still use JEB?"},{"location":"faq.html#how-do-i-update-from-jeb-2-to-jeb-3","text":"At the time of writing, you must install JEB 3 in a separate location. The auto-updater of JEB 2 will only notify you that a JEB 3 build is available for you to install. Check your email to download and install JEB 3.","title":"How do I update from JEB 2 to JEB 3?"},{"location":"faq.html#can-i-update-from-the-command-line","text":"Yes, you can run: $ <jeb_startup_script> -c --check-update After the update is downloaded, execute JEB normally.","title":"Can I update from the command-line?"},{"location":"faq.html#jeb-just-auto-updated-and-i-am-now-experiencing-strange-runtime-issues-what-can-i-do","text":"If the issues you are experiencing are showing up after a software update, at seemingly random times during program execution, and involve error messages like \"Error invoking method\" or \"Failed to launch JVM\" , it is likely that your last JEB update did not fully complete. Try to execute your start-up script (eg, on Windows, jeb_wincon.bat ) instead of any native launcher you may have been previously using (such as an OS desktop task bar shortcut). If the issue is recurring, please email Support .","title":"JEB just auto-updated and I am now experiencing strange runtime issues. What can I do?"},{"location":"faq.html#scripting","text":"","title":"Scripting"},{"location":"faq.html#can-i-execute-a-jeb-python-script-from-the-command-line","text":"Yes. Here's how to use the built-in script runner. You will need a Pro license. Make sure your JEB scripts/ folder contains the jython-xxx.jar . It should be the case if you are using JEB 3.1. Execute your JEB startup script with --srv2 and --script parameters, as well as optional script arguments after -- Example on Windows: $ jeb_wincon.bat -c --srv2 --script = SampleScript.py -- foo bar Use -c --help to learn about other options. API Command-line arguments (in the example above: foo , bar ) can be retrieved via IClientContext . Extensions Alternate ways exist to run scripts or plugins in headless contexts. Read through this guide and associated sample code if you want to know more about writing your own front-end clients.","title":"Can I execute a JEB Python script from the command line?"},{"location":"faq.html#can-i-write-back-end-extensions-plugins-contributions-etc-in-python","text":"Not at the moment. Back-end extensions should be written in Java (or any other language compiling to Java classfile, e.g. Kotlin).","title":"Can I write back-end extensions (plugins, contributions, etc.) in Python?"},{"location":"faq.html#other","text":"","title":"Other"},{"location":"faq.html#is-there-a-public-bugfeature-tracker","text":"Not at the moment. We are pretty responsive when it comes to answering users' queries though. Here's how to reach out: Send an email to Support Join us on Slack Ask your question on the JEB Google Groups Tweet or DM us @jebdec","title":"Is there a public bug/feature tracker?"},{"location":"faq.html#jeb-2-legacy","text":"","title":"JEB 2 (Legacy)"},{"location":"faq.html#jeb-2-can-i-run-the-jeb-2-desktop-client-on-my-32-bit-machine","text":"Yes. Prior to JEB 3.0-beta.8, JEB UI can also run on Windows 32-bit and Linux 32-bit.","title":"(JEB 2) Can I run the JEB 2 desktop client on my 32-bit machine?"},{"location":"faq.html#jeb-2-which-version-of-java-shall-i-use-to-run-jeb-2","text":"The desktop client requires Java 8. The back-end components ( jeb.jar ) work fine with with Java 8 and beyond.","title":"(JEB 2) Which version of Java shall I use to run JEB 2?"},{"location":"faq.html#jeb-2-how-can-i-increase-the-maximum-amount-of-memory-usable-by-jeb","text":"If unspecified, the memory cap is automatically decided upon starting up - and it will almost certainly be lower than what your system can offer. In order to manually specify the maximum amount of memory usable by JEB, edit the file bin/jeb.ini located in your JEB folder. Add the following lines: -vmargs -Xmx????m Replace ???? by the size amount of your choice, in Mb; eg, 4096 to allow JEB to use up to 4Gb. Note that other Java Virtual Machine options may be provided after the -vmargs (one option per line). Refer to the JVM manual for a complete list of options.","title":"(JEB 2) How can I increase the maximum amount of memory usable by JEB?"},{"location":"faq.html#jeb-2-i-just-upgraded-to-java-8u131-or-above-or-java-7u131-and-jeb-close-immediately-after-start-up-what-can-i-do","text":"The probable reason is that you must be using JEB 2.2.10 or below. Older versions of JEB are no compatible with the newer JDK/SDK. There are two ways to solve this problem: If you wish to stay on the JEB 2.2.x branch, install the latest update 2.2.11. You may use Java 7 or Java 8. We recommend you upgrade to the latest version of JEB, on the 2.3 or 3.0 branch. Make sure to use Java 8.","title":"(JEB 2) I just upgraded to Java 8u131 or above (or Java 7u131), and JEB close immediately after start-up. What can I do?"},{"location":"faq.html#jeb-2-how-can-i-run-multiple-instances-of-jeb","text":"Start your second and more instances of the UI client by using the -data @none command-line argument. Example on Windows: $ jeb_wincon.bat -data @none Note that the customization of your UI workspace will not be ported over to this new instance, and will not be persisted upon closing either.","title":"(JEB 2) How can I run multiple instances of JEB?"},{"location":"faq.html#jeb-2-jeb-closes-unexpectedly-at-start-up-how-do-i-troubleshoot-potential-issues","text":"By default, console messages generated by JEB are logged to the workspace/*log or workspace/.metadata/.log file within your JEB directory. If you are using the UI client, adding those settings to your bin/jeb.ini file will instruct the UI framework to log debug messages to the console: -debug -consoleLog -noExit Make sure to add them before any -vmarg parameter! Restart JEB and examine the console log. If all else fails, please reach out to Support .","title":"(JEB 2) JEB closes unexpectedly at start-up. How do I troubleshoot potential issues?"},{"location":"faq.html#jeb-2-how-to-execute-a-jeb-python-script-from-the-command-line-with-jeb-234-or-older","text":"Here is how to run Python scripts in a headless environment with JEB 2.3.4 or older: Make sure to drop a copy of Jython stand-alone JAR into your scripts folder Navigate to your JEB folder, sub-folder bin/cl Execute jeb.jar with --script and --libdir parameters, as well as optional script arguments (preceded by -- ) Also remember to set up two Java properties, using -Dkey=value command-lines flags: jeb.engcfg : points to your jeb-engines.cfg file jeb.lickey : contains a valid JEB license key (such as the value referenced in .LicenseKey in your jeb-client.cfg file) Example: $ java -Djeb.engcfg = jeb-engines.cfg -Djeb.lickey = xxxxxxx -jar jeb.jar --script = 1 .py --libdir = xxxxx -- arg1 arg2 ... API The command-line arguments (arg1, arg2, ...) can be retrieved via IClientContext .","title":"(JEB 2) How to execute a JEB Python script from the command line with JEB 2.3.4 (or older)?"},{"location":"faq.html#jeb-2-i-cannot-find-menu-entry-xxx-where-is-it","text":"You may need to reset the user interface state, via the Reset, UI State menu entry. A hard reset is to remove your workspace/ folder within your JEB installation folder.","title":"(JEB 2) I cannot find menu entry [xxx], where is it?"},{"location":"faq.html#jeb-2-what-are-the-views-marked-as-unbound-in-the-ui-client","text":"Those entries are layout placeholders from previous JEB sessions. They help JEB determine the best location to display a unit of a given type. (Note that \"Unbound Views\" can be closed at any time.) In the example below, DEX views and Java Decompiled views would be opened in their corresponding placeholders before attempting to create additional views.","title":"(JEB 2) What are the views marked as \"Unbound\" in the UI Client?"},{"location":"floating.html","text":"Getting Started # JEB Pro Floating builds provide more flexibility than individual builds, and can be distributed to many users within an organization. A floating build licensed for N seats will allow N clients to connect to it concurrently. When a client leaves, its seat is vacated, allowing another JEB client to start by connecting to the Controller. JEB Clients regularly probe the Controller to determine whether or not they are allowed to run. The check is based on the number of seats available in your licensed build: for example, a floating license for 5 seats allows 5 different users to run JEB concurrently. In order to start the Controller, use the --controller flag along with the -c flag: Windows $ jeb_wincon.bat -c --controller Linux $ jeb_linux.sh -c --controller macOS $ jeb_macos.sh -c --controller Additional Controller-specific command-line flags ( --interface , --port , --protocol ) are detailed below. After starting the Controller, follow the prompt: You will be asked to input your password, accept the license agreement, and generate a license key. Sample log output: C:\\jeb>jeb_wincon.bat -c --controller JEB decryption password: *************** ... <EULA> ... Write \"yes\" to agree, then press enter: yes Hello Nicolas Falliere. Set up your JEB controller by generating a license key. This one-time operation will only take a few seconds. Please visit https://www.pnfsoftware.com/genlk, and use the following \"license data\" blob to generate a key License data: ............................................. Input your license key: xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx Mode: Controller for floating clients Note: X client(s) may simultaneously connect to this controller instance Listening on 0.0.0.0/0.0.0.0:23477... If you need to customize the Controller's address or protocol, you may now stop it with the Ctrl+C keyboard command. Controller Settings # After the first step is completed successfully, executing the controller should display something like the following: C:\\jeb>jeb_wincon.bat -c --controller Mode: Controller for floating clients Note: X client(s) may simultaneously connect to this controller instance Listening on 0.0.0.0/0.0.0.0:23477... As can be seen, by default, the controller is listening on port 23477 on all interfaces, and uses the HTTP protocol. This can be changed by editing the configuration file bin/jeb-client.cfg and adding entries: .ControllerInterface , .ControllerPort , and .ControllerProtocol . Protocols currently supported are HTTP (0, the default) and HTTPS (1). Example 1: the Controller listens exclusively on localhost, port 30000: .ControllerInterface = localhost .ControllerPort = 35000 Example 2: the Controller listens on 10.0.0.25, port 8443, and uses HTTPS instead of HTTP: .ControllerInterface = 10.0.0.25 .ControllerPort = 8443 .ControllerProtocol = 1 Client Settings # Start your desktop client using one of the standard start-up scripts. For example, on a Windows machine: $ jeb_wincon.bat Your JEB Client settings should mirror your Controller settings: specify the controller hostname/interface, port, and protocol, in your client's jeb-client.cfg. The first time you start your JEB Desktop client, a dialog box will request you to specify your Controller's location. You will also have the opportunity to configure your proxy settings, if you are using one. Technical Notes # JEB Clients as well as JEB Controller are the same binary file: there is no separate package for the Controller. The --controller flag is only available for Floating builds. The Controller should be started before Clients. Clients regularly contact the Controller. Therefore, the Controller should always be reachable by running instances of JEB. In order to minimize potential problems due to network latency, it is recommended to run JEB and the Controller within the same local network. By default, the Controller listens on all interfaces, on port 23477. This can be changed by setting the .ControllerInterface and .ControllerPort values in your configuration file. By default, the Controller and Clients use HTTP for communication. In order to use HTTPS, make sure to set the .ControllerProtocol value in your configuration file to 1. (HTTPS is only available for JEB 3.0.6 and above.) JEB Client instance and the Controller may be run in different environments (e.g., a Controller on Linux, Clients on Windows or macOS, etc.) The controller property .ControllerMessage is used to provide messages, visible by clients on the Controller portal. Updating the Controller # There is no auto-update feature in the controller. The update procedure is: Check your registered email address for a JEB update email ( \"JEB xxx is available...\" ) Download the software archive Copy the archive to the root of your JEB folder and rename the file to update.zip Create a text file named update.pwd Store the email-provided password inside this file Start your controller as normal (e.g., ... -c --controller ); the update will be installed automatically","title":"Floating Controller"},{"location":"floating.html#getting-started","text":"JEB Pro Floating builds provide more flexibility than individual builds, and can be distributed to many users within an organization. A floating build licensed for N seats will allow N clients to connect to it concurrently. When a client leaves, its seat is vacated, allowing another JEB client to start by connecting to the Controller. JEB Clients regularly probe the Controller to determine whether or not they are allowed to run. The check is based on the number of seats available in your licensed build: for example, a floating license for 5 seats allows 5 different users to run JEB concurrently. In order to start the Controller, use the --controller flag along with the -c flag: Windows $ jeb_wincon.bat -c --controller Linux $ jeb_linux.sh -c --controller macOS $ jeb_macos.sh -c --controller Additional Controller-specific command-line flags ( --interface , --port , --protocol ) are detailed below. After starting the Controller, follow the prompt: You will be asked to input your password, accept the license agreement, and generate a license key. Sample log output: C:\\jeb>jeb_wincon.bat -c --controller JEB decryption password: *************** ... <EULA> ... Write \"yes\" to agree, then press enter: yes Hello Nicolas Falliere. Set up your JEB controller by generating a license key. This one-time operation will only take a few seconds. Please visit https://www.pnfsoftware.com/genlk, and use the following \"license data\" blob to generate a key License data: ............................................. Input your license key: xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx Mode: Controller for floating clients Note: X client(s) may simultaneously connect to this controller instance Listening on 0.0.0.0/0.0.0.0:23477... If you need to customize the Controller's address or protocol, you may now stop it with the Ctrl+C keyboard command.","title":"Getting Started"},{"location":"floating.html#controller-settings","text":"After the first step is completed successfully, executing the controller should display something like the following: C:\\jeb>jeb_wincon.bat -c --controller Mode: Controller for floating clients Note: X client(s) may simultaneously connect to this controller instance Listening on 0.0.0.0/0.0.0.0:23477... As can be seen, by default, the controller is listening on port 23477 on all interfaces, and uses the HTTP protocol. This can be changed by editing the configuration file bin/jeb-client.cfg and adding entries: .ControllerInterface , .ControllerPort , and .ControllerProtocol . Protocols currently supported are HTTP (0, the default) and HTTPS (1). Example 1: the Controller listens exclusively on localhost, port 30000: .ControllerInterface = localhost .ControllerPort = 35000 Example 2: the Controller listens on 10.0.0.25, port 8443, and uses HTTPS instead of HTTP: .ControllerInterface = 10.0.0.25 .ControllerPort = 8443 .ControllerProtocol = 1","title":"Controller Settings"},{"location":"floating.html#client-settings","text":"Start your desktop client using one of the standard start-up scripts. For example, on a Windows machine: $ jeb_wincon.bat Your JEB Client settings should mirror your Controller settings: specify the controller hostname/interface, port, and protocol, in your client's jeb-client.cfg. The first time you start your JEB Desktop client, a dialog box will request you to specify your Controller's location. You will also have the opportunity to configure your proxy settings, if you are using one.","title":"Client Settings"},{"location":"floating.html#technical-notes","text":"JEB Clients as well as JEB Controller are the same binary file: there is no separate package for the Controller. The --controller flag is only available for Floating builds. The Controller should be started before Clients. Clients regularly contact the Controller. Therefore, the Controller should always be reachable by running instances of JEB. In order to minimize potential problems due to network latency, it is recommended to run JEB and the Controller within the same local network. By default, the Controller listens on all interfaces, on port 23477. This can be changed by setting the .ControllerInterface and .ControllerPort values in your configuration file. By default, the Controller and Clients use HTTP for communication. In order to use HTTPS, make sure to set the .ControllerProtocol value in your configuration file to 1. (HTTPS is only available for JEB 3.0.6 and above.) JEB Client instance and the Controller may be run in different environments (e.g., a Controller on Linux, Clients on Windows or macOS, etc.) The controller property .ControllerMessage is used to provide messages, visible by clients on the Controller portal.","title":"Technical Notes"},{"location":"floating.html#updating-the-controller","text":"There is no auto-update feature in the controller. The update procedure is: Check your registered email address for a JEB update email ( \"JEB xxx is available...\" ) Download the software archive Copy the archive to the root of your JEB folder and rename the file to update.zip Create a text file named update.pwd Store the email-provided password inside this file Start your controller as normal (e.g., ... -c --controller ); the update will be installed automatically","title":"Updating the Controller"},{"location":"misc.html","text":"This section describes miscellaneous features offered by the UI client. Saving and Loading # A JEB project can be persisted to a file on disk called a JEB Database file. They have a .jdb2 extension. JDB2 files can be shared among users, and reloaded at a later time. They can grow significantly larger than the original artifact(s), as they contain the analysis results for all - or most of all, see below - units in your project. They are encrypted and compressed . Each JEB plugin/module is responsible for providing persistence of their result units. All PNF Software modules support persistence. Warning Make sure to load a JDB2 with a version of JEB equal or newer than the one that generated that JDB2. Quick Save # The analysis of large artifacts, yielding potentially hundreds or thousands of units, can translate into very large JDB2. For such projects, the UI client may offer the user to \"quick-save\" instead of performing a \"regular (full) save\". Quick saves are almost instantaneous, and generate lean JDB2 files. However, not all data is persisted in QuickSave'd JDB2. At the time of writing, QuickSave is supported for APK/DEX units and Native Code analysis units. The data items saved in a QuickSave JDB2 are: comments labels renamed items (packages, classes, methods, fields, etc.) identifier names See the back-end property .project.PersistenceStrategy to customize this behavior. Notifications # Notifications are generated by modules when they encounter areas of interest during analysis of their input data. The menu entry File, Unit notifications allows the user to view notifications for all units produced in the currently opened project. In the example below, the Android DEX plugin has generated a notification indicating that the Android app contained multiple DEX files, and that those were merged successfully: Notifications are generated at the discretion of the analysis modules. They can be classified in one of nine levels: Type Description AREA_OF_INTEREST A generic type to signify an area of interest within a unit. CORRUPTION Input corruption has been detected. DEPRECATED_FEATURE The unit has detected features that have been deprecated. ERROR A generic type to signify an error in the unit. INFO A generic type similar to AREA_OF_INTEREST. MALICIOUS The intent is malicious. POTENTIALLY_HARMFUL This type indicates usage of a feature not recommended by guidelines due to its potential dangerousness. UNSUPPORTED_FEATURE Some input cannot be parsed because of a limitation within the unit itself. WARNING A generic type to signify a warning in the unit. Note See this reference page for additional details on notification types. Exporting Output # Users may export analyzed data via one the sub-commands in the File, Export menu entries: Export some or all decompilations. Export all binary units to multiple files on disk Export the active fragment to raw text or html (with coloration similar to JEB's text views). Make sure to focus a code view or a decompiled code view before attempting to run this command. This command is accessible via the File, Export menu entry. Project Properties # The properties of a project can be examined by right-clicking the project node in the Project Explorer view, via the File menu, or by using the Alt+Enter key combo when the project node is selected. The name is customizable. The default name is always derived from the primary artifact, with a JDB2 extension. This extension stands for \"JEB Database Version 2\", and represent a serialized version of your project which users can save and load on their JEB version 2 software. The creation and modification timestamps are read-only. The user-notes are obviously writable and saved with the JDB2. Artifact Properties # Similarly to Project properties, the properties of an artifact can be examined by right-clicking the artifact node in the Project Explorer view, via the File menu, or by using the Alt+Enter key combo when the artifact node is selected. Unit Properties # Similar to Project and Artifact properties, the properties of a unit can be examined by right-clicking the corresponding unit node in the Project Explorer view, via the File menu, or by using the Alt+Enter key combo when the unit node is selected. The unit name is customizable, however, we recommend users to not change unit names . The unit type corresponds to the module type that created the unit (in this example, 'apk') The creation timestamp is the time at which the unit was created from its parent artifact or unit The status field indicates potential problems: N/A means the unit was processed properly, and its contents can be examined; other string messages can be reported by modules to indicate processing error, or simply, lack of processing in the case of lazy processing. Listing Parsers # The full list of input processor plugins (whose term was simplified to parsers in the UI) loaded within your JEB instance context can be seen by running the File, Engines, Parsers command. Parsers can be selectively disabled if you would like JEB. For example, if you would like JEB to not process ZIP files as such (i.e., treat them as plain binary files), you may disable the zip parser. API Technically speaking, parsers are JEB plugins that implement the IUnitIdentifier interface. Refer to the Developing with JEB section of this guide for more information. Adding Artifacts # Commonly, most projects will contain a single artifact file, such as a binary executable or an application file. However, you may add as many artifacts as you want to a project Select the menu entry File, Add an Artifact to add an artifact to an existing project. The newly added artifact will be processed, and added to the current project tree: Reparsing Data # This advanced feature is available by right-clicking a unit in the Project Explorer view, and selecting Parse at... : Reparsing allows a user to (re)parse a unit or parts of a unit by specifying explicitly what the input data should be parsed as. For instance, you may have input data identified as XML data, and initially parsed as such - therefore yielding an XML unit. However, you may discover that this XML data contains bytes that would correspond to a ZIP file (eg, starting with PK... ). By reparsing the XML data at the given ZIP header offset using the ZIP module, you ask JEB to process that data as ZIP and create a ZIP unit out of it: Reparsing can be helpful when dealing with complicated, obfuscated, or multi-layered files.","title":"Miscellaneous"},{"location":"misc.html#saving-and-loading","text":"A JEB project can be persisted to a file on disk called a JEB Database file. They have a .jdb2 extension. JDB2 files can be shared among users, and reloaded at a later time. They can grow significantly larger than the original artifact(s), as they contain the analysis results for all - or most of all, see below - units in your project. They are encrypted and compressed . Each JEB plugin/module is responsible for providing persistence of their result units. All PNF Software modules support persistence. Warning Make sure to load a JDB2 with a version of JEB equal or newer than the one that generated that JDB2.","title":"Saving and Loading"},{"location":"misc.html#quick-save","text":"The analysis of large artifacts, yielding potentially hundreds or thousands of units, can translate into very large JDB2. For such projects, the UI client may offer the user to \"quick-save\" instead of performing a \"regular (full) save\". Quick saves are almost instantaneous, and generate lean JDB2 files. However, not all data is persisted in QuickSave'd JDB2. At the time of writing, QuickSave is supported for APK/DEX units and Native Code analysis units. The data items saved in a QuickSave JDB2 are: comments labels renamed items (packages, classes, methods, fields, etc.) identifier names See the back-end property .project.PersistenceStrategy to customize this behavior.","title":"Quick Save"},{"location":"misc.html#notifications","text":"Notifications are generated by modules when they encounter areas of interest during analysis of their input data. The menu entry File, Unit notifications allows the user to view notifications for all units produced in the currently opened project. In the example below, the Android DEX plugin has generated a notification indicating that the Android app contained multiple DEX files, and that those were merged successfully: Notifications are generated at the discretion of the analysis modules. They can be classified in one of nine levels: Type Description AREA_OF_INTEREST A generic type to signify an area of interest within a unit. CORRUPTION Input corruption has been detected. DEPRECATED_FEATURE The unit has detected features that have been deprecated. ERROR A generic type to signify an error in the unit. INFO A generic type similar to AREA_OF_INTEREST. MALICIOUS The intent is malicious. POTENTIALLY_HARMFUL This type indicates usage of a feature not recommended by guidelines due to its potential dangerousness. UNSUPPORTED_FEATURE Some input cannot be parsed because of a limitation within the unit itself. WARNING A generic type to signify a warning in the unit. Note See this reference page for additional details on notification types.","title":"Notifications"},{"location":"misc.html#exporting-output","text":"Users may export analyzed data via one the sub-commands in the File, Export menu entries: Export some or all decompilations. Export all binary units to multiple files on disk Export the active fragment to raw text or html (with coloration similar to JEB's text views). Make sure to focus a code view or a decompiled code view before attempting to run this command. This command is accessible via the File, Export menu entry.","title":"Exporting Output"},{"location":"misc.html#project-properties","text":"The properties of a project can be examined by right-clicking the project node in the Project Explorer view, via the File menu, or by using the Alt+Enter key combo when the project node is selected. The name is customizable. The default name is always derived from the primary artifact, with a JDB2 extension. This extension stands for \"JEB Database Version 2\", and represent a serialized version of your project which users can save and load on their JEB version 2 software. The creation and modification timestamps are read-only. The user-notes are obviously writable and saved with the JDB2.","title":"Project Properties"},{"location":"misc.html#artifact-properties","text":"Similarly to Project properties, the properties of an artifact can be examined by right-clicking the artifact node in the Project Explorer view, via the File menu, or by using the Alt+Enter key combo when the artifact node is selected.","title":"Artifact Properties"},{"location":"misc.html#unit-properties","text":"Similar to Project and Artifact properties, the properties of a unit can be examined by right-clicking the corresponding unit node in the Project Explorer view, via the File menu, or by using the Alt+Enter key combo when the unit node is selected. The unit name is customizable, however, we recommend users to not change unit names . The unit type corresponds to the module type that created the unit (in this example, 'apk') The creation timestamp is the time at which the unit was created from its parent artifact or unit The status field indicates potential problems: N/A means the unit was processed properly, and its contents can be examined; other string messages can be reported by modules to indicate processing error, or simply, lack of processing in the case of lazy processing.","title":"Unit Properties"},{"location":"misc.html#listing-parsers","text":"The full list of input processor plugins (whose term was simplified to parsers in the UI) loaded within your JEB instance context can be seen by running the File, Engines, Parsers command. Parsers can be selectively disabled if you would like JEB. For example, if you would like JEB to not process ZIP files as such (i.e., treat them as plain binary files), you may disable the zip parser. API Technically speaking, parsers are JEB plugins that implement the IUnitIdentifier interface. Refer to the Developing with JEB section of this guide for more information.","title":"Listing Parsers"},{"location":"misc.html#adding-artifacts","text":"Commonly, most projects will contain a single artifact file, such as a binary executable or an application file. However, you may add as many artifacts as you want to a project Select the menu entry File, Add an Artifact to add an artifact to an existing project. The newly added artifact will be processed, and added to the current project tree:","title":"Adding Artifacts"},{"location":"misc.html#reparsing-data","text":"This advanced feature is available by right-clicking a unit in the Project Explorer view, and selecting Parse at... : Reparsing allows a user to (re)parse a unit or parts of a unit by specifying explicitly what the input data should be parsed as. For instance, you may have input data identified as XML data, and initially parsed as such - therefore yielding an XML unit. However, you may discover that this XML data contains bytes that would correspond to a ZIP file (eg, starting with PK... ). By reparsing the XML data at the given ZIP header offset using the ZIP module, you ask JEB to process that data as ZIP and create a ZIP unit out of it: Reparsing can be helpful when dealing with complicated, obfuscated, or multi-layered files.","title":"Reparsing Data"},{"location":"native.html","text":"JEB is fully-equipped to perform native code analysis of binary files compiled for Windows (PE), Linux and variants (ELF), or most other platforms, including headless firmware files. TODO This section is a work-in-progress and being actively worked on. In the meantime, find additional documentation about JEB's native analysis pipeline (code analysis and decompilation) on our blog: List of posts tagged Native Code . Decompilers # JEB Pro ships with analysis modules, including decompilers, for: Intel x86 32-bit (all x86 - SSE/AVX support coming in JEB 4) Intel x86 64-bit (all x86 - SSE/AVX support coming in JEB 4) ARM 32-bit (and common ISA extensions) ARM 64-bit (v8 / aarch64) MIPS 32-bit Also provided is a disassembler for Atmel AVR, although we are not shipping an AVR decompiler at the moment. Siglibs # JEB supports the creation of signature libraries ( siglibs ) for library code recognition. JEB Pro includes complete library signature sets for: Android NDK libraries (ARM/ARM64). Common libraries (libc, libc++, zlib, etc.) are signed from NDK v11 up to the latest version (v20 as of 11/19). Microsoft Visual Studio libraries (x86/x86-64). C runtime libraries and standard C++ libraries are signed from Visual Studio 2003 up to Visual Studio 2019. Note Users can generate their own signature libraries: Native Signatures Generation (blog) ; Android NDK signatures presentation Android NDK Library Signatures (blog) Typelibs # JEB supports the creation of type libraries ( typelibs ) for common Windows and Linux subsystems, including: Android NDK on ARM 32-bit Android NDK on ARM 64-bit Android NDK on x86 32-bit Android NDK on x86 64-bit Windows win32 on Intel x86 32-bit Windows win32 on Intel x86 64-bit Windows win32 on ARM 32-bit Windows win32 on ARM 64-bit Windows DDK on Intel x86 32-bit Windows DDK on Intel x86 64-bit Linux glibc on Intel x86 32-bit Linux glibc on ARM 32-bit Linux glibc on MIPS 32-bit Note Users can generate their own type libraries: Native Types and Typelibs (blog) Native Code Actions # Common native code actions can Be found in the Native menu: Section to be completed","title":"Native Code Analysis"},{"location":"native.html#decompilers","text":"JEB Pro ships with analysis modules, including decompilers, for: Intel x86 32-bit (all x86 - SSE/AVX support coming in JEB 4) Intel x86 64-bit (all x86 - SSE/AVX support coming in JEB 4) ARM 32-bit (and common ISA extensions) ARM 64-bit (v8 / aarch64) MIPS 32-bit Also provided is a disassembler for Atmel AVR, although we are not shipping an AVR decompiler at the moment.","title":"Decompilers"},{"location":"native.html#siglibs","text":"JEB supports the creation of signature libraries ( siglibs ) for library code recognition. JEB Pro includes complete library signature sets for: Android NDK libraries (ARM/ARM64). Common libraries (libc, libc++, zlib, etc.) are signed from NDK v11 up to the latest version (v20 as of 11/19). Microsoft Visual Studio libraries (x86/x86-64). C runtime libraries and standard C++ libraries are signed from Visual Studio 2003 up to Visual Studio 2019. Note Users can generate their own signature libraries: Native Signatures Generation (blog) ; Android NDK signatures presentation Android NDK Library Signatures (blog)","title":"Siglibs"},{"location":"native.html#typelibs","text":"JEB supports the creation of type libraries ( typelibs ) for common Windows and Linux subsystems, including: Android NDK on ARM 32-bit Android NDK on ARM 64-bit Android NDK on x86 32-bit Android NDK on x86 64-bit Windows win32 on Intel x86 32-bit Windows win32 on Intel x86 64-bit Windows win32 on ARM 32-bit Windows win32 on ARM 64-bit Windows DDK on Intel x86 32-bit Windows DDK on Intel x86 64-bit Linux glibc on Intel x86 32-bit Linux glibc on ARM 32-bit Linux glibc on MIPS 32-bit Note Users can generate their own type libraries: Native Types and Typelibs (blog)","title":"Typelibs"},{"location":"native.html#native-code-actions","text":"Common native code actions can Be found in the Native menu: Section to be completed","title":"Native Code Actions"},{"location":"settings.html","text":"This section describes settings and additional configuration panels offered by the UI client. Theme # JEB ships with three themes: a default theme: which will be light if the system rendered the application widgets with a white or light colored background (as is the default on most operating systems) which will be dark if the application widgets provided by the operating system were dark a Dark theme a Light (~sepia) fall-back theme Toggle from Default to Dark to Light via the Edit, Theme command, or the MOD1+Shift+Alt+T keyboard shortcut (MOD1= Ctrl on Windows/Linux, Command on macOS). Note The fall-back light theme was added mostly for macOS users running JEB with recent JDK (>8) whose system is configured in Dark Mode but prefer running JEB with lighter colors. Default theme Default theme on a Dark Mode system Dark Theme Light Theme Styles and Fonts # The Edit menu (or the Application menu on Mac) allows users to customize the styles of interactive item as well as the code font used by most JEB views. Make sure to select a fixed font. JEB tries its best to select the most appropriate font on your system. If that fails, and you wish to select a font manually, we recommend Consolas on Windows, Menlo/Monaco on Mac, or DejaVu Sans Mono on Linux. Unicode JEB supports Unicode. While the aforementioned fonts have good support for a variety of common non-ASCII planes (CJK, Cyrillic, etc.), you might need to use a different font to properly examine strings written in exotic locales. Keyboard Shortcuts # Most JEB command handlers can be triggered by keyboard shortcuts. The default shortcuts are visible when visualizing menu items. To customize keyboard shortcuts: in JEB's bin/ folder, copy jeb-shortcuts.cfg.TEMPLATE to jeb-shortcuts.cfg edit jeb-shortcuts.cfg : uncomment the command lines for which you wish to use custom keyboard shortcuts Refer to the jeb-shortcuts.cfg.TEMPLATE file in your bin/ folder for details: #------------------------------------------------------------------------------ # JEB Custom Keyboard Shortcuts #------------------------------------------------------------------------------ # 1) Rename or copy this file to jeb-shortcuts.cfg # 2) Uncomment and add your own keyboard shortcuts for the actions for which you'd like to override the default shortcuts # Example: by default, Jump is mapped to the 'G' key; the following line (minus the # character) can be used to remap the action to CTRL+J: #jump=Ctrl+J # *** CUSTOMIZABLE HANDLERS *** #runScript= #runLastScript= #share= ... Example: Changing the shortcut for the 'Comment' action to ';' (instead of '/') Locale # The UI client front-end is available in English as well as 10 additional languages. Select your preferred language via the Edit menu: Note The back-end components (modules and plugins) are not localized at the moment. Only front-end components were localized. Non-English locales having partial support at the moment are: Language Support English default French 70% Chinese 70% Japanese 70% Korean 70% Russian 70% German 50% Italian 50% Portuguese 50% Spanish 50% Turkish 50% Simple Options # Simple options are accessible via the Edit or Application menu. Two panels, General and Development , offer a partial view of JEB's configuration files, described in upcoming sections. General options # Set-up your packaged plugins directory. Packaged plugins are third-party Jar modules that add functionality to JEB: they can be parsers, disassemblers, decompilers, debuggers, code analyzers, etc. Third-party plugins can be loaded on Pro builds only. Customize your auto-update options. http and socks proxy are supported. Development options # The Development mode enables verbose logging for increased insight into the program. The plugin classpath and classname widgets allow setting up non-packaged Java plugins, which makes developing them easier. Reference # Front-end options # See this document . Back-end options # See this document .","title":"Settings"},{"location":"settings.html#theme","text":"JEB ships with three themes: a default theme: which will be light if the system rendered the application widgets with a white or light colored background (as is the default on most operating systems) which will be dark if the application widgets provided by the operating system were dark a Dark theme a Light (~sepia) fall-back theme Toggle from Default to Dark to Light via the Edit, Theme command, or the MOD1+Shift+Alt+T keyboard shortcut (MOD1= Ctrl on Windows/Linux, Command on macOS). Note The fall-back light theme was added mostly for macOS users running JEB with recent JDK (>8) whose system is configured in Dark Mode but prefer running JEB with lighter colors. Default theme Default theme on a Dark Mode system Dark Theme Light Theme","title":"Theme"},{"location":"settings.html#styles-and-fonts","text":"The Edit menu (or the Application menu on Mac) allows users to customize the styles of interactive item as well as the code font used by most JEB views. Make sure to select a fixed font. JEB tries its best to select the most appropriate font on your system. If that fails, and you wish to select a font manually, we recommend Consolas on Windows, Menlo/Monaco on Mac, or DejaVu Sans Mono on Linux. Unicode JEB supports Unicode. While the aforementioned fonts have good support for a variety of common non-ASCII planes (CJK, Cyrillic, etc.), you might need to use a different font to properly examine strings written in exotic locales.","title":"Styles and Fonts"},{"location":"settings.html#keyboard-shortcuts","text":"Most JEB command handlers can be triggered by keyboard shortcuts. The default shortcuts are visible when visualizing menu items. To customize keyboard shortcuts: in JEB's bin/ folder, copy jeb-shortcuts.cfg.TEMPLATE to jeb-shortcuts.cfg edit jeb-shortcuts.cfg : uncomment the command lines for which you wish to use custom keyboard shortcuts Refer to the jeb-shortcuts.cfg.TEMPLATE file in your bin/ folder for details: #------------------------------------------------------------------------------ # JEB Custom Keyboard Shortcuts #------------------------------------------------------------------------------ # 1) Rename or copy this file to jeb-shortcuts.cfg # 2) Uncomment and add your own keyboard shortcuts for the actions for which you'd like to override the default shortcuts # Example: by default, Jump is mapped to the 'G' key; the following line (minus the # character) can be used to remap the action to CTRL+J: #jump=Ctrl+J # *** CUSTOMIZABLE HANDLERS *** #runScript= #runLastScript= #share= ... Example: Changing the shortcut for the 'Comment' action to ';' (instead of '/')","title":"Keyboard Shortcuts"},{"location":"settings.html#locale","text":"The UI client front-end is available in English as well as 10 additional languages. Select your preferred language via the Edit menu: Note The back-end components (modules and plugins) are not localized at the moment. Only front-end components were localized. Non-English locales having partial support at the moment are: Language Support English default French 70% Chinese 70% Japanese 70% Korean 70% Russian 70% German 50% Italian 50% Portuguese 50% Spanish 50% Turkish 50%","title":"Locale"},{"location":"settings.html#simple-options","text":"Simple options are accessible via the Edit or Application menu. Two panels, General and Development , offer a partial view of JEB's configuration files, described in upcoming sections.","title":"Simple Options"},{"location":"settings.html#general-options","text":"Set-up your packaged plugins directory. Packaged plugins are third-party Jar modules that add functionality to JEB: they can be parsers, disassemblers, decompilers, debuggers, code analyzers, etc. Third-party plugins can be loaded on Pro builds only. Customize your auto-update options. http and socks proxy are supported.","title":"General options"},{"location":"settings.html#development-options","text":"The Development mode enables verbose logging for increased insight into the program. The plugin classpath and classname widgets allow setting up non-packaged Java plugins, which makes developing them easier.","title":"Development options"},{"location":"settings.html#reference","text":"","title":"Reference"},{"location":"settings.html#front-end-options","text":"See this document .","title":"Front-end options"},{"location":"settings.html#back-end-options","text":"See this document .","title":"Back-end options"},{"location":"views.html","text":"To visualize a unit, double-click on its node in the Project Explorer panel, or right-click and select Open, View . The view for a unit is a placeholder for one or more fragments , representing unit documents . For example, a DEX unit (which is the analysis result of an Android DEX file by the DEX plugin) is rendered by multiple fragments, including: A Description static text view A Hex Dump view An Assembly interactive text view (as well as Its associated Graph view) A Strings interactive table view A Code Hierarchy interactive tree view Note Some types of documents provide addressing support. Addressing support is a necessary requirement to enable interactive actions such as navigation and cross-referencing, as will be discussed later. The following sub-sections provide examples of common fragments and views encountered when analyzing binary files: Description Documents # The Description document is a standard buffer of text provided by all units. It contains a small body of text presenting various characteristics of the unit, including whether or not it contains children units. Hex Dump Documents # The Hex Dump document is a hexadecimal representation of the input artifact. This document can efficiently represent artifacts of a size up to 2^63 bytes. Helper widgets are provided for easy visualization of unpacked byte sequences. Text Documents # Units commonly provide interactive text documents to represent their contents. Text documents are addressable. Those views can efficiently represent arbitrarily large bodies of text - up to billions of lines if necessary. The navigation bar, vertically positioned on the right-hand side of the document by default, allows navigating the document. Examples include: assembly documents, xml documents, decompiled code documents, etc. Navigation bar # By default, the navigation bar of a text document is a vertical bar located on the right side. It can be positioned horizontally as well, refer to this Client setting . The green line represents the location of your viewport within the document, i.e., the first line on screen. The yellow arrow represents the caret position. In the example above, the caret is located well outside the viewport. The orange line is mostly of use to plugin developers: it indicates which portion of the document is currently loaded in memory. The bar can be zoomed in and out using mouse scrolling. Hovering over an area of the bar will roughly indicate what text is located at that position: click to navigate there. The bar above was zoomed in. The vertical line in red indicates what portion of the document is now represented by the entire bar . It allows for finer fast navigation in long disassembly listings. Finally, and most importantly, the bar can receive visual contributions from units and documents. It is for example used by code library recognition plugins to highlight parts of the document which contain library code. Below, an example of the bar (set horizontally for clarity) when analyzing a ShadowHammer malware sample with Visual Studio 2010 signatures on : In this case, the cyan color represents library code. Table Documents # Units may provide table documents to represent their contents. Table documents are addressable. Tree Documents # Units may provide tree documents to represent their contents. Tree documents are addressable. Interactive Trees # Code hierarchies are interactive trees that allow navigation to code items, such as methods or routines. Static Table Trees # Parsed certificate can be represented as static table tree documents. For example, the APK module produces such documents. Another example of a table tree (for which each node is a row within a table) is the global structure of a PDF document produced by the PDF plugin. Mime-typed Documents # A unit may issue mime-typed documents. It is up to front-end clients to implement rendering engines for some of those types. For example, the official UI client render various image types. Custom Documents # Specialized units, such as debugger or native code units, offer access to specific data that does not fit in standard document categories. It is up to the front-end to render whatever is deemed necessary. For example, the UI client produces 6 or 7 specialized views to represent debugger units (such as breakpoints, threads, locals, memory, ..). Specialized views are described in sections dealing with specialized units, e.g. debuggers or native disassemblers .","title":"Common Views"},{"location":"views.html#description-documents","text":"The Description document is a standard buffer of text provided by all units. It contains a small body of text presenting various characteristics of the unit, including whether or not it contains children units.","title":"Description Documents"},{"location":"views.html#hex-dump-documents","text":"The Hex Dump document is a hexadecimal representation of the input artifact. This document can efficiently represent artifacts of a size up to 2^63 bytes. Helper widgets are provided for easy visualization of unpacked byte sequences.","title":"Hex Dump Documents"},{"location":"views.html#text-documents","text":"Units commonly provide interactive text documents to represent their contents. Text documents are addressable. Those views can efficiently represent arbitrarily large bodies of text - up to billions of lines if necessary. The navigation bar, vertically positioned on the right-hand side of the document by default, allows navigating the document. Examples include: assembly documents, xml documents, decompiled code documents, etc.","title":"Text Documents"},{"location":"views.html#navigation-bar","text":"By default, the navigation bar of a text document is a vertical bar located on the right side. It can be positioned horizontally as well, refer to this Client setting . The green line represents the location of your viewport within the document, i.e., the first line on screen. The yellow arrow represents the caret position. In the example above, the caret is located well outside the viewport. The orange line is mostly of use to plugin developers: it indicates which portion of the document is currently loaded in memory. The bar can be zoomed in and out using mouse scrolling. Hovering over an area of the bar will roughly indicate what text is located at that position: click to navigate there. The bar above was zoomed in. The vertical line in red indicates what portion of the document is now represented by the entire bar . It allows for finer fast navigation in long disassembly listings. Finally, and most importantly, the bar can receive visual contributions from units and documents. It is for example used by code library recognition plugins to highlight parts of the document which contain library code. Below, an example of the bar (set horizontally for clarity) when analyzing a ShadowHammer malware sample with Visual Studio 2010 signatures on : In this case, the cyan color represents library code.","title":"Navigation bar"},{"location":"views.html#table-documents","text":"Units may provide table documents to represent their contents. Table documents are addressable.","title":"Table Documents"},{"location":"views.html#tree-documents","text":"Units may provide tree documents to represent their contents. Tree documents are addressable.","title":"Tree Documents"},{"location":"views.html#interactive-trees","text":"Code hierarchies are interactive trees that allow navigation to code items, such as methods or routines.","title":"Interactive Trees"},{"location":"views.html#static-table-trees","text":"Parsed certificate can be represented as static table tree documents. For example, the APK module produces such documents. Another example of a table tree (for which each node is a row within a table) is the global structure of a PDF document produced by the PDF plugin.","title":"Static Table Trees"},{"location":"views.html#mime-typed-documents","text":"A unit may issue mime-typed documents. It is up to front-end clients to implement rendering engines for some of those types. For example, the official UI client render various image types.","title":"Mime-typed Documents"},{"location":"views.html#custom-documents","text":"Specialized units, such as debugger or native code units, offer access to specific data that does not fit in standard document categories. It is up to the front-end to render whatever is deemed necessary. For example, the UI client produces 6 or 7 specialized views to represent debugger units (such as breakpoints, threads, locals, memory, ..). Specialized views are described in sections dealing with specialized units, e.g. debuggers or native disassemblers .","title":"Custom Documents"},{"location":"webassembly.html","text":"Info This manual page assumes familiarity with common JEB actions and views . We also assume a minimal amount of knowledge of WebAssembly code and low-level details. For readers that would like to get up to speed with the basics of wasm from a reverse-engineering point of view, we recommend reading our technical paper Reversing WebAssembly Note The wasm decompiler update shipping with JEB 4, whose pre-release is planned for Q2 2020, fills up several gaps present in the first version of the decompiler, e.g. floating point support, casting and reinterpret opcodes, etc. JEB Pro can be used to analyze and decompile WebAssembly binary modules (wasm). The decompiler produces C-like code. Three modules, relying on the Native Code Analysis Pipeline, handle WebAssembly binaries: a wasm binary parser, a disassembler extension, and a decompiler extension. A Project Explorer view with wasm module and wasm bytecode units After opening a wasm binary in JEB, it will be recognized and processed as such by the WebAssembly plugin: - The top-level unit node, under the blue-dot artifact node, represents the module itself. - Its first child node is named \"wasmbc image\", and represents a memory view of the entire WebAssembly module, with code and data. The module unit # Overview fragment The Overview fragment displays standard information. Note the following interesting facts: The word-size is set to 32-bit, as the plugin assumes a wasm32 environment. The endianness is little endian. The start of image is set to 0, and the virtual image size to 2Gb: the entire module will be sparsely mapped within this memory range. Wasm binaries do not embed standard metadata that would hold compilation timestamps (they could be added to a custom section though). Sections fragment The Sections fragment represents an unmodified list of wasm sections. The in-memory size and offset are irrelevant and set to zero. Note that the example above shows a custom dylink section, most likely indicating a binary compiled with emcc and the flag SIDE_MODULE=1 . The Segments and Symbols tabs detail how the wasm plugin laid out and transformed the elements of the wasm module in order to allow the underlying code plugin to process it. Pseudo segments # wasm module pseudo-segments The concept of mappable segments does not exist per-say in WebAssembly. However, in order to allow JEB code plugins (disassemblers, decompilers, etc.) to function, the wasm plugin creates the following pseudo sections: .data starts at address 0 and maps the single Memory section (along with the Data elements that initialize it) .table starts at address 0x4000000 and holds a table of pointers to the functions referenced in the Table section (initialized by the Element section) .code starts at address 0x50000000 and contains the bytecode of all internal functions, in order of index: the first function body of size S0 is at address 0x50000000, the second at address 0x50000000+S0, the third at 0x50000000+S0+S1, etc. .globals starts at address 0x60000000 and maps the internal globals as standard global variables; practically, wasm' globals (accessible by {SET,GET}_GLOBAL operators) and wasm' memory bytes (accessible by load/store operators) are being treated as equals by JEB. .imports starts at address 0x70000000 contains pointer references to the imported (external) function section entries and global section entries The image is set to be mapped in the [0, 0x80000000) range. Sections are sparsely mapped; only used bytes are allocated. The start addresses are flexible and can be adjusted if needed Symbols # wasm module pseudo-symbols Symbols generated by the wasm plugin are of four types, and can have a variety of attributes: FUNCTION for internal functions PTRUNCTION for imported functions and referenced internal functions VARIABLE for globals PTRVARIABLE for imported globals Code View # The interactive disassembly window shows the pseudo virtual memory representing the entire WebAssembly module, as explained in the above section. The screenshot below shows the disassembly area of an internal function. Note that JEB's representation of a function's bytecode is linear and matches the underlying binary code. The green columns prefixing the instruction indicate the current block depth and current operand stack height, pre-execution. wasm bytecode code view, showing a disassembly snippet The snapshot below shows the beginning of the .data virtual segment, representing the WebAssembly Data section. The Code view is interactive. However, code modification (i.e., tampering with routine bodies) is forbidden since they would introduce inconsistencies in the function index space. wasm bytecode code view, showing a data area Decompilation # The WebAssembly decompiler plugin for JEB uses JEB's decompilation pipeline to produce pseudo C code. As such, the plugin consists of a wasm-to-IR converter and additional analyzer extensions. Slots on the operand stack are converted to standard, routine context IR variables. As of the time of writing, the wasm decompiler has the following limitations: The global, advanced analysis normally provided the decompiler is partially disabled (the advanced analysis is responsible, for instance, to discover register values and callsite targets during a fast static analysis phase, and subsequently annotate the assembly listing). There is no support for floating point operation conversion. Memory stack frames, due to their dynamic (and optional) nature in WebAssembly are currently not accessible and customizable. Those limitations will be addressed as the decompiler plugin matures. wasm bytecode disassembly and corresponding decompiled code","title":"WebAssembly Analysis"},{"location":"webassembly.html#the-module-unit","text":"Overview fragment The Overview fragment displays standard information. Note the following interesting facts: The word-size is set to 32-bit, as the plugin assumes a wasm32 environment. The endianness is little endian. The start of image is set to 0, and the virtual image size to 2Gb: the entire module will be sparsely mapped within this memory range. Wasm binaries do not embed standard metadata that would hold compilation timestamps (they could be added to a custom section though). Sections fragment The Sections fragment represents an unmodified list of wasm sections. The in-memory size and offset are irrelevant and set to zero. Note that the example above shows a custom dylink section, most likely indicating a binary compiled with emcc and the flag SIDE_MODULE=1 . The Segments and Symbols tabs detail how the wasm plugin laid out and transformed the elements of the wasm module in order to allow the underlying code plugin to process it.","title":"The module unit"},{"location":"webassembly.html#pseudo-segments","text":"wasm module pseudo-segments The concept of mappable segments does not exist per-say in WebAssembly. However, in order to allow JEB code plugins (disassemblers, decompilers, etc.) to function, the wasm plugin creates the following pseudo sections: .data starts at address 0 and maps the single Memory section (along with the Data elements that initialize it) .table starts at address 0x4000000 and holds a table of pointers to the functions referenced in the Table section (initialized by the Element section) .code starts at address 0x50000000 and contains the bytecode of all internal functions, in order of index: the first function body of size S0 is at address 0x50000000, the second at address 0x50000000+S0, the third at 0x50000000+S0+S1, etc. .globals starts at address 0x60000000 and maps the internal globals as standard global variables; practically, wasm' globals (accessible by {SET,GET}_GLOBAL operators) and wasm' memory bytes (accessible by load/store operators) are being treated as equals by JEB. .imports starts at address 0x70000000 contains pointer references to the imported (external) function section entries and global section entries The image is set to be mapped in the [0, 0x80000000) range. Sections are sparsely mapped; only used bytes are allocated. The start addresses are flexible and can be adjusted if needed","title":"Pseudo segments"},{"location":"webassembly.html#symbols","text":"wasm module pseudo-symbols Symbols generated by the wasm plugin are of four types, and can have a variety of attributes: FUNCTION for internal functions PTRUNCTION for imported functions and referenced internal functions VARIABLE for globals PTRVARIABLE for imported globals","title":"Symbols"},{"location":"webassembly.html#code-view","text":"The interactive disassembly window shows the pseudo virtual memory representing the entire WebAssembly module, as explained in the above section. The screenshot below shows the disassembly area of an internal function. Note that JEB's representation of a function's bytecode is linear and matches the underlying binary code. The green columns prefixing the instruction indicate the current block depth and current operand stack height, pre-execution. wasm bytecode code view, showing a disassembly snippet The snapshot below shows the beginning of the .data virtual segment, representing the WebAssembly Data section. The Code view is interactive. However, code modification (i.e., tampering with routine bodies) is forbidden since they would introduce inconsistencies in the function index space. wasm bytecode code view, showing a data area","title":"Code View"},{"location":"webassembly.html#decompilation","text":"The WebAssembly decompiler plugin for JEB uses JEB's decompilation pipeline to produce pseudo C code. As such, the plugin consists of a wasm-to-IR converter and additional analyzer extensions. Slots on the operand stack are converted to standard, routine context IR variables. As of the time of writing, the wasm decompiler has the following limitations: The global, advanced analysis normally provided the decompiler is partially disabled (the advanced analysis is responsible, for instance, to discover register values and callsite targets during a fast static analysis phase, and subsequently annotate the assembly listing). There is no support for floating point operation conversion. Memory stack frames, due to their dynamic (and optional) nature in WebAssembly are currently not accessible and customizable. Those limitations will be addressed as the decompiler plugin matures. wasm bytecode disassembly and corresponding decompiled code","title":"Decompilation"},{"location":"workspace.html","text":"When starting the UI client without specifying an input file, JEB will display an empty workspace that's using a three-part layout: Project explorer on the left side Logger and Console at the bottom Empty area in the center Starting an Analysis # To start an analysis, open a file (or reload a saved analysis stored in a .jdb2 file) via the File menu. A new project will be created, the input file will be processed and analyzed. Example: Processing an APK file # If your input file was an Android application, the app is processed by various Android analysis plugins: The APK plugin takes care of unbundling the app, decoding the manifest and resources The DEX plugin performs the analysis and disassembly of the DEX bytecode file (or files) The XML parser analyzes XML resources The Certificate plugin analyzes the certificate ... and so on. JEB performs recursive analysis on input artifacts and units, using the loaded parser plugins . The project explorer tree should display a Bytecode node, representing the DEX unit (more on the concept of units later). The DEX views should be opened automatically by the UI client, as they are detected as the principal views of an APK artifact. Your workspace should look like: The workspace can be customized by the user: Views can be dragged and dropped, resized, stacked and docked with other views Views can be detached and placed in separate windows - something particularly useful for multi-monitor setups. Terminology # The Project Explorer contains three types of nodes: The top-most entity accessible within the UI client is a project . Currently, the UI client can only handle a single project per session. A project contains various artifacts , which represent data to be analyzed. Artifacts are usually files read from the local file system The analysis of artifacts yield units (and sub-units ). E.g., the analysis of an Android DEX file artifact will yield at least one DEX unit representing the bytecode of that DEX file. Users of the graphical client interact with units through views that contain fragments representing various aspects of a unit. Fragments are rendered in tabs, selectable at the bottom of a view. Most units are interactive . Users can interact with them through a variety of ways, including via actions , available in the similarly-named menu. The screen capture below summarizes common elements present and visible in the workspace when analyzing a file: Back-end JEB objects # The Project Explorer elements are representing back-end components documented in the API reference . The image below summarizes a project's top-most components hierarchically:","title":"Workspace"},{"location":"workspace.html#starting-an-analysis","text":"To start an analysis, open a file (or reload a saved analysis stored in a .jdb2 file) via the File menu. A new project will be created, the input file will be processed and analyzed.","title":"Starting an Analysis"},{"location":"workspace.html#example-processing-an-apk-file","text":"If your input file was an Android application, the app is processed by various Android analysis plugins: The APK plugin takes care of unbundling the app, decoding the manifest and resources The DEX plugin performs the analysis and disassembly of the DEX bytecode file (or files) The XML parser analyzes XML resources The Certificate plugin analyzes the certificate ... and so on. JEB performs recursive analysis on input artifacts and units, using the loaded parser plugins . The project explorer tree should display a Bytecode node, representing the DEX unit (more on the concept of units later). The DEX views should be opened automatically by the UI client, as they are detected as the principal views of an APK artifact. Your workspace should look like: The workspace can be customized by the user: Views can be dragged and dropped, resized, stacked and docked with other views Views can be detached and placed in separate windows - something particularly useful for multi-monitor setups.","title":"Example: Processing an APK file"},{"location":"workspace.html#terminology","text":"The Project Explorer contains three types of nodes: The top-most entity accessible within the UI client is a project . Currently, the UI client can only handle a single project per session. A project contains various artifacts , which represent data to be analyzed. Artifacts are usually files read from the local file system The analysis of artifacts yield units (and sub-units ). E.g., the analysis of an Android DEX file artifact will yield at least one DEX unit representing the bytecode of that DEX file. Users of the graphical client interact with units through views that contain fragments representing various aspects of a unit. Fragments are rendered in tabs, selectable at the bottom of a view. Most units are interactive . Users can interact with them through a variety of ways, including via actions , available in the similarly-named menu. The screen capture below summarizes common elements present and visible in the workspace when analyzing a file:","title":"Terminology"},{"location":"workspace.html#back-end-jeb-objects","text":"The Project Explorer elements are representing back-end components documented in the API reference . The image below summarizes a project's top-most components hierarchically:","title":"Back-end JEB objects"},{"location":"dev/1-getting-started-with-parsers.html","text":"JEB Plugin Development Tutorial part 1/8 The JEB API provides the ability to develop parser plugins (referred to as parsers ) for any file type. All native JEB plugins use that same API. A parser can process binary data, textual data, or even the output of other parsers, which is the case for debugger or decompiler plugins. This series of tutorials will help developers understand the major features and organization of the JEB API, and will guide them through the development of their own parsers and plugins. We will use the official front-end - the UI client - throughout this series, although extensions development is in no way constricted to the use of a particular front-end. Load a parser # There are two ways to load plugins. Release model # Copy the jar plugin to your plugins folder. You can configure your plugins folder via the Edit, Options menu (or Preferences on Mac). Refer to that section for additional details. If you are using third-party (aka, non native) plugins, the release model is easy to use. For example, head over to our GitHub account. You will find a few open-source parsers, such as an Android OAT parser . Instead of compiling them from source, you may decide to use the pre-compiled jars, available in the release section. With the release model, the classname is defined in the Jar manifest. There is nothing to configure in the options. If you have a jar plugin that you would like to use, simply drop it in the plugins folder . Then, restart JEB. Your plugin will be automatically loaded. Development model # In that case, you need to specify the classpath of your plugin, as well as its classname (that is, the fully-qualified name of the plugin class, as we will describe later). You can modify these options in the same dialog box, in the Development tab: The development model is ideal when actively developing a plugin, and dealing with compiled Java classfiles that have not been packaged yet. Check if a parser is loaded # As we explained earlier in this guide, You can check if your parser is loaded by opening the parsers dialog: Note that you may also disable parsers, by ticking or unticking the checkbox in front of the parser type. Develop a new parser # JEB plugins are developed in Java. We recommend you to use the Eclipse IDE for plugins development. Create a new Java project In Eclipse: File, New, Java Project - use the default settings Add the API to your project. The API can be included by adding the Jar reference to your build path In Eclipse: right click on your project, select Build path, Add external archives . The API file is contained in the JEB application under bin/cl/jeb.jar . Link the javadoc to jeb.jar: it is located in doc/apidoc.zip In Eclipse: right click on your project and select Build path, configure build path. Expand jeb.jar and edit the javadoc location Set the Archive path textbobx to point to your apidoc.zip file Set the Path within Archive textbox to reference Create a new class that implements IPlugin : it will be the entry point of your project. In Eclipse: the project is automatically compiled in a bin/ directory For example: package com.jeb.sample ; import com.pnfsoftware.jeb.core.IPlugin ; // simplest plugin type public class SamplePlugin implements IPlugin { @Override public IPluginInformation getPluginInformation () { return new PluginInformation ( \"Sample\" , \"Description\" , \"PNF Software\" , Version . create ( 1 , 0 )); } } Open JEB and add your project bin folder to the Plugin Classpath entries and add the classname: com.jeb.sample.SamplePlugin . Restart JEB, you should see a message in the Logger panel: Development plugin loaded: class com.jeb.sample.SamplePlugin This means that your project is correctly configured and that you can start the development of your plugin!","title":"Part 1: Getting Started with Parsers"},{"location":"dev/1-getting-started-with-parsers.html#load-a-parser","text":"There are two ways to load plugins.","title":"Load a parser"},{"location":"dev/1-getting-started-with-parsers.html#release-model","text":"Copy the jar plugin to your plugins folder. You can configure your plugins folder via the Edit, Options menu (or Preferences on Mac). Refer to that section for additional details. If you are using third-party (aka, non native) plugins, the release model is easy to use. For example, head over to our GitHub account. You will find a few open-source parsers, such as an Android OAT parser . Instead of compiling them from source, you may decide to use the pre-compiled jars, available in the release section. With the release model, the classname is defined in the Jar manifest. There is nothing to configure in the options. If you have a jar plugin that you would like to use, simply drop it in the plugins folder . Then, restart JEB. Your plugin will be automatically loaded.","title":"Release model"},{"location":"dev/1-getting-started-with-parsers.html#development-model","text":"In that case, you need to specify the classpath of your plugin, as well as its classname (that is, the fully-qualified name of the plugin class, as we will describe later). You can modify these options in the same dialog box, in the Development tab: The development model is ideal when actively developing a plugin, and dealing with compiled Java classfiles that have not been packaged yet.","title":"Development model"},{"location":"dev/1-getting-started-with-parsers.html#check-if-a-parser-is-loaded","text":"As we explained earlier in this guide, You can check if your parser is loaded by opening the parsers dialog: Note that you may also disable parsers, by ticking or unticking the checkbox in front of the parser type.","title":"Check if a parser is loaded"},{"location":"dev/1-getting-started-with-parsers.html#develop-a-new-parser","text":"JEB plugins are developed in Java. We recommend you to use the Eclipse IDE for plugins development. Create a new Java project In Eclipse: File, New, Java Project - use the default settings Add the API to your project. The API can be included by adding the Jar reference to your build path In Eclipse: right click on your project, select Build path, Add external archives . The API file is contained in the JEB application under bin/cl/jeb.jar . Link the javadoc to jeb.jar: it is located in doc/apidoc.zip In Eclipse: right click on your project and select Build path, configure build path. Expand jeb.jar and edit the javadoc location Set the Archive path textbobx to point to your apidoc.zip file Set the Path within Archive textbox to reference Create a new class that implements IPlugin : it will be the entry point of your project. In Eclipse: the project is automatically compiled in a bin/ directory For example: package com.jeb.sample ; import com.pnfsoftware.jeb.core.IPlugin ; // simplest plugin type public class SamplePlugin implements IPlugin { @Override public IPluginInformation getPluginInformation () { return new PluginInformation ( \"Sample\" , \"Description\" , \"PNF Software\" , Version . create ( 1 , 0 )); } } Open JEB and add your project bin folder to the Plugin Classpath entries and add the classname: com.jeb.sample.SamplePlugin . Restart JEB, you should see a message in the Logger panel: Development plugin loaded: class com.jeb.sample.SamplePlugin This means that your project is correctly configured and that you can start the development of your plugin!","title":"Develop a new parser"},{"location":"dev/2-creating-simple-parser.html","text":"JEB Plugin Development Tutorial part 2/8 The source code for part 2 of this sample plugin is located on GitHub: Clone this repo : git clone https://github.com/pnfsoftware/jeb2-plugindemo-js.git Switch to the tutorial2 branch: git checkout tutorial2 Sample file # In this parser development tutorial, we will consider a simple Javascript parser. Let's start with a definition of a test file: # Javascript function a () { alert ( \"a called\" ); } function b () { var b = \"b called\" ; alert ( b ); } Parser Objective # Our parser will split the input JavaScript file into several parts, one for each JavaScript function(). Defined variables will will be displayed in a supplementary tab in a table. This initial goal is to detect and display the contents of the file. The secondary goal is to define and manage several views, and show how to use the delegation mechanism. Generic Parser # First, let's open this js file without modifying anything in JEB. JEB analyzes the input artifact and built the project as following: The top-level project represents your current workspace. The artifact represents the file that was opened. (If you choose \"File, Add an Artifact...\" from the menu, a new artifact will be added at the same level.) The children of the artifact are the units . Their icon can be specified, if none, you will see the default one . JEB provides a default generic parser that displays any file. It contains two fragments: a Description panel with generic information related to unit an Hex Dump view which displays the content of the object as hexadecimal. Detect the js file # Upon loading a file, the first step JEB takes is ask all parsers if they are able to handle the input artifact (in our case, a file). So, the first step is to add the detection for this JavaScript (js) file. For the sake of making this tutorial simple, we will suppose that all our js files start with a \"#Javascript\" tag. In part 1 , we learned that IPlugin is the entry point of the plugin; however, it only defines a getPluginInformation() method. Let's start to check all classes/interfaces that extend IPlugin (in Eclipse, right click on IPlugin, Open Type Hierarchy ). What we have here: our own plugin SamplePlugin class IEnginesPlugin for Engines plugins (refer to separate tutorial) IUnitIdentifier for Parser plugins. To free developers from the task of implementing all methods of IUnitIdentifier, the abstract class AbstractUnitIdentifier is provided. Let's extend it instead of IPlugin or IUnitIdentifier. We see that only two methods are not implemented: canIdentify : used to detect if the parser should to be used (the one we were looking for!) prepare : used to create an IUnit that will perform the processing Let's check canIdentify parameters in the API: IInput is a reference to the input file or stream, we can read data from here. IUnitCreator is the parent that created this unit (parsers are producing units or type IUnit). We will use this parameter in the tutorial explaining how delegation works. canIdentify could use IInput.getHeader, IInput.getStream or other method to detect specific file type. Here, we will use AbstractUnitIdentifier.checkBytes which provides an easy way to check header as you can see: private final static byte [] JS_HEADER = \"#Javascript\" . getBytes (); @Override public boolean canIdentify ( IInput input , IUnitCreator parent ) { return checkBytes ( input , 0 , JS_HEADER ); } We are now ready, let's start JEB. Note: you may see the following error in the logger: Unit plugin class com.jeb.sample.SamplePlugin must have a public no-argument constructor This means that you did not provide a default constructor without argument. Let's use this one: public SamplePlugin () { super ( \"Javascript\" , 0 ); } Open test.js. You should see this: The default parser did not create the generic unit for js file! That's because there is nothing defined in the prepare method. Keep on reading. Build a unit # Look back at the prepare method. It should return an IUnit . The IUnit will be the main processing class, so it is recommended to build a dedicated class. Just like we did for IPlugin, we will use one of the default convenience abstract classes provided: AbstractUnit . public class SampleUnit extends AbstractUnit { public SampleUnit ( String name , IInput input , IUnitProcessor unitProcessor , IUnitCreator parent , IPropertyDefinitionManager pdm ) { super ( \"js\" , name , unitProcessor , parent , pdm ); } @Override public boolean process () { // indicates that the processing is already done: process won't be called again in future setProcessed ( true ); // default is false. True indicates that processing is successful. return true ; } } and the code of the caller: @Override public IUnit prepare ( String name , IInput input , IUnitProcessor unitProcessor , IUnitCreator parent ) { return new SampleUnit ( name , input , unitProcessor , parent , pdm ); } You can test your parser: Not very exciting. The content of the file is not even displayed. AbstractUnit is a simple unit with the description panel. Its constructor does not use the IInput. Let's try something else: what are all available subclasses that we have: Let's use another default implementation: AbstractBinaryUnit . public class SampleUnit extends AbstractBinaryUnit { public SampleUnit ( String name , IInput input , IUnitProcessor unitProcessor , IUnitCreator parent , IPropertyDefinitionManager pdm ) { super ( null , input , \"js\" , name , unitProcessor , parent , pdm ); } } So, now we have 2 tabs for a single unit. Each tab is a representation of a JEB Document. Default documents for a Binary Unit are Description and Hex Dump. They both display text. Note: the description Document is a default document that is always attached to a unit. You can modify its content by overriding IUnit.getDescription. Add a Document # JEB provides the ability for units to produce all sorts of documents to be represented by clients. There are three types of documents, and default implementations are provided: Text buffers (for arbitrary long line-based documents) Tables Trees and table trees Let's start with the simplest document: a text document. We will use the provided AsciiDocument implementation. The display is delegated to an IUnitFormatter. This display can be modified by overriding the IUnit.getFormatter method. @Override public IUnitFormatter getFormatter () { return new UnitFormatterAdapter ( new AbstractUnitRepresentation ( \"javascript raw code\" , true ) { @Override public IGenericDocument getDocument () { return new AsciiDocument ( getInput ()); } }); } The result is what we expected:","title":"Part 2: Creating a Simple Parser"},{"location":"dev/2-creating-simple-parser.html#sample-file","text":"In this parser development tutorial, we will consider a simple Javascript parser. Let's start with a definition of a test file: # Javascript function a () { alert ( \"a called\" ); } function b () { var b = \"b called\" ; alert ( b ); }","title":"Sample file"},{"location":"dev/2-creating-simple-parser.html#parser-objective","text":"Our parser will split the input JavaScript file into several parts, one for each JavaScript function(). Defined variables will will be displayed in a supplementary tab in a table. This initial goal is to detect and display the contents of the file. The secondary goal is to define and manage several views, and show how to use the delegation mechanism.","title":"Parser Objective"},{"location":"dev/2-creating-simple-parser.html#generic-parser","text":"First, let's open this js file without modifying anything in JEB. JEB analyzes the input artifact and built the project as following: The top-level project represents your current workspace. The artifact represents the file that was opened. (If you choose \"File, Add an Artifact...\" from the menu, a new artifact will be added at the same level.) The children of the artifact are the units . Their icon can be specified, if none, you will see the default one . JEB provides a default generic parser that displays any file. It contains two fragments: a Description panel with generic information related to unit an Hex Dump view which displays the content of the object as hexadecimal.","title":"Generic Parser"},{"location":"dev/2-creating-simple-parser.html#detect-the-js-file","text":"Upon loading a file, the first step JEB takes is ask all parsers if they are able to handle the input artifact (in our case, a file). So, the first step is to add the detection for this JavaScript (js) file. For the sake of making this tutorial simple, we will suppose that all our js files start with a \"#Javascript\" tag. In part 1 , we learned that IPlugin is the entry point of the plugin; however, it only defines a getPluginInformation() method. Let's start to check all classes/interfaces that extend IPlugin (in Eclipse, right click on IPlugin, Open Type Hierarchy ). What we have here: our own plugin SamplePlugin class IEnginesPlugin for Engines plugins (refer to separate tutorial) IUnitIdentifier for Parser plugins. To free developers from the task of implementing all methods of IUnitIdentifier, the abstract class AbstractUnitIdentifier is provided. Let's extend it instead of IPlugin or IUnitIdentifier. We see that only two methods are not implemented: canIdentify : used to detect if the parser should to be used (the one we were looking for!) prepare : used to create an IUnit that will perform the processing Let's check canIdentify parameters in the API: IInput is a reference to the input file or stream, we can read data from here. IUnitCreator is the parent that created this unit (parsers are producing units or type IUnit). We will use this parameter in the tutorial explaining how delegation works. canIdentify could use IInput.getHeader, IInput.getStream or other method to detect specific file type. Here, we will use AbstractUnitIdentifier.checkBytes which provides an easy way to check header as you can see: private final static byte [] JS_HEADER = \"#Javascript\" . getBytes (); @Override public boolean canIdentify ( IInput input , IUnitCreator parent ) { return checkBytes ( input , 0 , JS_HEADER ); } We are now ready, let's start JEB. Note: you may see the following error in the logger: Unit plugin class com.jeb.sample.SamplePlugin must have a public no-argument constructor This means that you did not provide a default constructor without argument. Let's use this one: public SamplePlugin () { super ( \"Javascript\" , 0 ); } Open test.js. You should see this: The default parser did not create the generic unit for js file! That's because there is nothing defined in the prepare method. Keep on reading.","title":"Detect the js file"},{"location":"dev/2-creating-simple-parser.html#build-a-unit","text":"Look back at the prepare method. It should return an IUnit . The IUnit will be the main processing class, so it is recommended to build a dedicated class. Just like we did for IPlugin, we will use one of the default convenience abstract classes provided: AbstractUnit . public class SampleUnit extends AbstractUnit { public SampleUnit ( String name , IInput input , IUnitProcessor unitProcessor , IUnitCreator parent , IPropertyDefinitionManager pdm ) { super ( \"js\" , name , unitProcessor , parent , pdm ); } @Override public boolean process () { // indicates that the processing is already done: process won't be called again in future setProcessed ( true ); // default is false. True indicates that processing is successful. return true ; } } and the code of the caller: @Override public IUnit prepare ( String name , IInput input , IUnitProcessor unitProcessor , IUnitCreator parent ) { return new SampleUnit ( name , input , unitProcessor , parent , pdm ); } You can test your parser: Not very exciting. The content of the file is not even displayed. AbstractUnit is a simple unit with the description panel. Its constructor does not use the IInput. Let's try something else: what are all available subclasses that we have: Let's use another default implementation: AbstractBinaryUnit . public class SampleUnit extends AbstractBinaryUnit { public SampleUnit ( String name , IInput input , IUnitProcessor unitProcessor , IUnitCreator parent , IPropertyDefinitionManager pdm ) { super ( null , input , \"js\" , name , unitProcessor , parent , pdm ); } } So, now we have 2 tabs for a single unit. Each tab is a representation of a JEB Document. Default documents for a Binary Unit are Description and Hex Dump. They both display text. Note: the description Document is a default document that is always attached to a unit. You can modify its content by overriding IUnit.getDescription.","title":"Build a unit"},{"location":"dev/2-creating-simple-parser.html#add-a-document","text":"JEB provides the ability for units to produce all sorts of documents to be represented by clients. There are three types of documents, and default implementations are provided: Text buffers (for arbitrary long line-based documents) Tables Trees and table trees Let's start with the simplest document: a text document. We will use the provided AsciiDocument implementation. The display is delegated to an IUnitFormatter. This display can be modified by overriding the IUnit.getFormatter method. @Override public IUnitFormatter getFormatter () { return new UnitFormatterAdapter ( new AbstractUnitRepresentation ( \"javascript raw code\" , true ) { @Override public IGenericDocument getDocument () { return new AsciiDocument ( getInput ()); } }); } The result is what we expected:","title":"Add a Document"},{"location":"dev/3-documents-delegation.html","text":"JEB Plugin Development Tutorial part 3/8 The source code for part 3 of this sample plugin is located on GitHub: Clone this repo : git clone https://github.com/pnfsoftware/jeb2-plugindemo-js.git Switch to the tutorial3 branch: git checkout tutorial3 Process the input # In the previous part, we built a single document that displays the whole JavaScript file. Imagine we have large functions that we would like to split using the following simple rule: one function per document . Let's detail the flow of execution around IUnit : When opening a new file, all the IPlugin.canIdentify methods are called. If identified, the method IPlugin.prepare is called, which will create a new unit. When opening the unit, if the unit was not previously processed, the method IUnit.process method will be called. At last, IUnit.getFormatter is used to display the result of processing. The process method is where the heavy-lifting of your parser should be located. If you need to pre-process data, you may call the process method in IUnitIdentifier.prepare . Since we don't need it for now, we won't do it. So let's start with implementing process() . First, we need to extract the JavaScript and split this test block into two functions. For the sake of this tutorial, we will use Mozilla Rhino to deal with JavaScript lexing and parsing. You can download it here . First, add rhino-*.jar to your eclipse project (you can attach the javadoc to this .jar, the process is like adding javadoc to jeb.jar). Then, use the following snippet to extract the Functions from JavaScript: private static final ILogger logger = GlobalLog . getLogger ( SampleUnit . class ); private AstRoot root = null ; private List < FunctionNode > functions = new ArrayList < FunctionNode > (); @Override public boolean process () { // parse the javascript IRFactory factory = new IRFactory (); try { BufferedReader reader = new BufferedReader ( new InputStreamReader ( getInput (). getStream ())); reader . readLine (); // ignore first line with #Javascript root = factory . parse ( reader , null , 0 ); } catch ( IOException e ) { logger . catching ( e ); return false ; } // save functions List < AstNode > statements = root . getStatements (); for ( AstNode statement : statements ) { if ( statement . getType () == Token . FUNCTION ) { functions . add (( FunctionNode ) statement ); } } // done setProcessed ( true ); return true ; } As you can see here, process() is only extracting data: FunctionNode objects are saved in the functions list. Note: JEB provides global logging facility that you can use anytime to send messages in the Logger panel. Do not hesitate to use it to investigate your code. We also recommend you enable the Development Mode in the Options panel: this will allow logging of debug and trace messages. import com.pnfsoftware.jeb.util.logging.GlobalLog ; import com.pnfsoftware.jeb.util.logging.ILogger ; public class Xxx { private static final ILogger logger = GlobalLog . getLogger ( Xxx . class ); ... Add a Document per function # Now, let's modify the getFormatter method to change rendering, adding as many tabs (documents) as defined functions. @Override public IUnitFormatter getFormatter () { UnitFormatterAdapter adapter = new UnitFormatterAdapter ( new AbstractUnitRepresentation ( \"javascript raw code\" , true ) { @Override public IGenericDocument getDocument () { return new AsciiDocument ( getInput ()); } }); if ( functions != null ) { for ( final FunctionNode function : functions ) { adapter . addDocumentPresentation ( new AbstractUnitRepresentation ( function . getName ()) { @Override public IGenericDocument getDocument () { return new AsciiDocument ( new BytesInput ( function . toSource (). getBytes ())); } }); } } return adapter ; } We called the method UnitFormatterAdapter.addDocumentPresentation to add more documents. Note: since AsciiDocument requires an IInput as entry, we used the most appropriate implementation: Now, start JEB. Note You will probably see this exception: java.lang.NoClassDefFoundError: org/mozilla/javascript/IRFactory . Remember that js.jar was not added to JEB classpath. Add it to your plugin classpath (in the Options panel - refer to Part 1 of this tutorial). If all works well, you shall to see two additional tabs: Delegate to another Unit # These new documents are great but what if we have lots of functions? We will have lots of tabs and it will become unreadable. One solution would be to add these FunctionNodes as children unit of the test.js unit node. We can delegate the creation of those units to the unit processor. Here is a short explanation of delegation: assume have a zip file containing pdf, apk, js... You do not want to write a single parser that manages all those file types. A better approach is to have a Zip parser that will delegate parsing of its contents. That puts the Unit Processor in charge of finding the best Unit that match the file type: DEX Unit, Pdf Unit... and even our new Javascript Unit. Info More on delegation here . So how to do it? You need to slightly modify process(): // save functions List < AstNode > statements = root . getStatements (); for ( AstNode statement : statements ) { if ( statement . getType () == Token . FUNCTION ) { FunctionNode function = ( FunctionNode ) statement ; functions . add ( function ); IUnit jsUnit = getUnitProcessor (). process ( function . getName (), new BytesInput ( function . toSource (). getBytes ()), this ); if ( jsUnit != null ) { addChildUnit ( jsUnit ); } } } You should be able to see a generic binary output for a and b . Assignment # Build a simple JavascriptPlugin that takes advantage of the delegation. The solution lies in branch tutorial3 of this sample plugin repository. Do not forget to register the parser plugin's classname in the options panel. You should obtain something like this:","title":"Part 3: Documents and Delegation"},{"location":"dev/3-documents-delegation.html#process-the-input","text":"In the previous part, we built a single document that displays the whole JavaScript file. Imagine we have large functions that we would like to split using the following simple rule: one function per document . Let's detail the flow of execution around IUnit : When opening a new file, all the IPlugin.canIdentify methods are called. If identified, the method IPlugin.prepare is called, which will create a new unit. When opening the unit, if the unit was not previously processed, the method IUnit.process method will be called. At last, IUnit.getFormatter is used to display the result of processing. The process method is where the heavy-lifting of your parser should be located. If you need to pre-process data, you may call the process method in IUnitIdentifier.prepare . Since we don't need it for now, we won't do it. So let's start with implementing process() . First, we need to extract the JavaScript and split this test block into two functions. For the sake of this tutorial, we will use Mozilla Rhino to deal with JavaScript lexing and parsing. You can download it here . First, add rhino-*.jar to your eclipse project (you can attach the javadoc to this .jar, the process is like adding javadoc to jeb.jar). Then, use the following snippet to extract the Functions from JavaScript: private static final ILogger logger = GlobalLog . getLogger ( SampleUnit . class ); private AstRoot root = null ; private List < FunctionNode > functions = new ArrayList < FunctionNode > (); @Override public boolean process () { // parse the javascript IRFactory factory = new IRFactory (); try { BufferedReader reader = new BufferedReader ( new InputStreamReader ( getInput (). getStream ())); reader . readLine (); // ignore first line with #Javascript root = factory . parse ( reader , null , 0 ); } catch ( IOException e ) { logger . catching ( e ); return false ; } // save functions List < AstNode > statements = root . getStatements (); for ( AstNode statement : statements ) { if ( statement . getType () == Token . FUNCTION ) { functions . add (( FunctionNode ) statement ); } } // done setProcessed ( true ); return true ; } As you can see here, process() is only extracting data: FunctionNode objects are saved in the functions list. Note: JEB provides global logging facility that you can use anytime to send messages in the Logger panel. Do not hesitate to use it to investigate your code. We also recommend you enable the Development Mode in the Options panel: this will allow logging of debug and trace messages. import com.pnfsoftware.jeb.util.logging.GlobalLog ; import com.pnfsoftware.jeb.util.logging.ILogger ; public class Xxx { private static final ILogger logger = GlobalLog . getLogger ( Xxx . class ); ...","title":"Process the input"},{"location":"dev/3-documents-delegation.html#add-a-document-per-function","text":"Now, let's modify the getFormatter method to change rendering, adding as many tabs (documents) as defined functions. @Override public IUnitFormatter getFormatter () { UnitFormatterAdapter adapter = new UnitFormatterAdapter ( new AbstractUnitRepresentation ( \"javascript raw code\" , true ) { @Override public IGenericDocument getDocument () { return new AsciiDocument ( getInput ()); } }); if ( functions != null ) { for ( final FunctionNode function : functions ) { adapter . addDocumentPresentation ( new AbstractUnitRepresentation ( function . getName ()) { @Override public IGenericDocument getDocument () { return new AsciiDocument ( new BytesInput ( function . toSource (). getBytes ())); } }); } } return adapter ; } We called the method UnitFormatterAdapter.addDocumentPresentation to add more documents. Note: since AsciiDocument requires an IInput as entry, we used the most appropriate implementation: Now, start JEB. Note You will probably see this exception: java.lang.NoClassDefFoundError: org/mozilla/javascript/IRFactory . Remember that js.jar was not added to JEB classpath. Add it to your plugin classpath (in the Options panel - refer to Part 1 of this tutorial). If all works well, you shall to see two additional tabs:","title":"Add a Document per function"},{"location":"dev/3-documents-delegation.html#delegate-to-another-unit","text":"These new documents are great but what if we have lots of functions? We will have lots of tabs and it will become unreadable. One solution would be to add these FunctionNodes as children unit of the test.js unit node. We can delegate the creation of those units to the unit processor. Here is a short explanation of delegation: assume have a zip file containing pdf, apk, js... You do not want to write a single parser that manages all those file types. A better approach is to have a Zip parser that will delegate parsing of its contents. That puts the Unit Processor in charge of finding the best Unit that match the file type: DEX Unit, Pdf Unit... and even our new Javascript Unit. Info More on delegation here . So how to do it? You need to slightly modify process(): // save functions List < AstNode > statements = root . getStatements (); for ( AstNode statement : statements ) { if ( statement . getType () == Token . FUNCTION ) { FunctionNode function = ( FunctionNode ) statement ; functions . add ( function ); IUnit jsUnit = getUnitProcessor (). process ( function . getName (), new BytesInput ( function . toSource (). getBytes ()), this ); if ( jsUnit != null ) { addChildUnit ( jsUnit ); } } } You should be able to see a generic binary output for a and b .","title":"Delegate to another Unit"},{"location":"dev/3-documents-delegation.html#assignment","text":"Build a simple JavascriptPlugin that takes advantage of the delegation. The solution lies in branch tutorial3 of this sample plugin repository. Do not forget to register the parser plugin's classname in the options panel. You should obtain something like this:","title":"Assignment"},{"location":"dev/4-tables-trees.html","text":"JEB Plugin Development Tutorial part 4/8 The interfaces ITextDocument , ITableDocument and ITreeDocument are designed to provide buffered data: data is not generated nor displayed entirely (which could lead to performance/memory problem). It is split into Parts (eg, ITableDocumentPart ). When implementing an IXxxDocument , you can choose to render the full model (for instance if the model is relatively small) or just one or more parts. A client requests as many parts as they see fit. Those indications are hints; ultimately, your plugin has the final say in how many parts it decides to return. Now, let's check two types of documents that we haven't seen yet: Table and Tree . Table # For simple tables, you can use StaticTableDocument . See below an example of a Table having 2 columns, and containing 2 rows. private ITableDocument getStatisticsTable () { List < TableRow > rows = new ArrayList <> (); rows . add ( new TableRow ( new Cell ( \"Length\" ), new Cell ( Integer . toString ( root . getLength ())))); rows . add ( new TableRow ( new Cell ( \"Type\" ), new Cell ( Integer . toString ( root . getType ())))); return new StaticTableDocument ( Arrays . asList ( \"Property\" , \"Value\" ), rows ); } Assignment Update the getFormatter() method accordingly to include new Documents (use the IUnitFormatter.addPresentation() method). The result should look like: Tree # For simple trees, you can use StaticTreeDocument . See below an example of a Tree that displays all function parameters. private ITreeDocument getFunctionsTree () { List < Node > treeRoot = new ArrayList <> (); try { if ( functions != null ) { for ( FunctionNode function : functions ) { treeRoot . add ( buildFunctionNode ( function )); } } } catch ( Exception e ) { logger . catching ( e ); } return new StaticTreeDocument ( treeRoot ); } private Node buildFunctionNode ( FunctionNode function ) { Node functionNode = new Node ( function . getName ()); if ( function . getParamCount () > 0 ) { for ( AstNode var : function . getParams ()) { functionNode . addChild ( new Node ((( Name ) var ). getIdentifier ())); } } return functionNode ; }","title":"Part 4: Tables and Trees"},{"location":"dev/4-tables-trees.html#table","text":"For simple tables, you can use StaticTableDocument . See below an example of a Table having 2 columns, and containing 2 rows. private ITableDocument getStatisticsTable () { List < TableRow > rows = new ArrayList <> (); rows . add ( new TableRow ( new Cell ( \"Length\" ), new Cell ( Integer . toString ( root . getLength ())))); rows . add ( new TableRow ( new Cell ( \"Type\" ), new Cell ( Integer . toString ( root . getType ())))); return new StaticTableDocument ( Arrays . asList ( \"Property\" , \"Value\" ), rows ); } Assignment Update the getFormatter() method accordingly to include new Documents (use the IUnitFormatter.addPresentation() method). The result should look like:","title":"Table"},{"location":"dev/4-tables-trees.html#tree","text":"For simple trees, you can use StaticTreeDocument . See below an example of a Tree that displays all function parameters. private ITreeDocument getFunctionsTree () { List < Node > treeRoot = new ArrayList <> (); try { if ( functions != null ) { for ( FunctionNode function : functions ) { treeRoot . add ( buildFunctionNode ( function )); } } } catch ( Exception e ) { logger . catching ( e ); } return new StaticTreeDocument ( treeRoot ); } private Node buildFunctionNode ( FunctionNode function ) { Node functionNode = new Node ( function . getName ()); if ( function . getParamCount () > 0 ) { for ( AstNode var : function . getParams ()) { functionNode . addChild ( new Node ((( Name ) var ). getIdentifier ())); } } return functionNode ; }","title":"Tree"},{"location":"dev/5-development-tips.html","text":"JEB Plugin Development Tutorial part 5/8 This tutorial aggregates a collection of tips that can help you during plugin development. Logging # Creating Loggers # Creating a new logger with the JEB API is simple: private static final ILogger logger = GlobalLog . getLogger ( MyClass . class ); It is good practice to create one logger per class. Loggers can be customized one by one, or globally via the GlobalLog factory. Using Loggers # There are several level of logs (error, warning, info, ...) and the logger methods use 2 parameters: the message to display the parameters of the message, as it is done for String.format() method. logger . info ( \"Hello %s\" , \"World\" ); Enabling Debug and Trace levels # By default, debug and trace logs are not displayed. You can activate them by ticking the Development mode in the Options menu: Logging destinations # By default, JEB sends log data to the Logger view in the UI client. Additional sinks can be added, such as buffers or output streams. For instance, if you would like to collect all logs to a file named jeb-test-output.log in your TEMP folder, your plugin could execute the following: String foldername = System . getProperty ( \"java.io.tmpdir\" ); File folder = foldername != null ? new File ( foldername ): TestData . getTestDataRoot (); File file = new File ( folder , \"jeb-test-output.log\" ); GlobalLog . addDestinationStream ( new PrintStream ( file )); Note Be careful, GlobalLog is a global factory object, that impacts the entire application. Debugging # If you are familiar with Eclipse and development tools in general, you know how useful proper debugging facility are: the program can be stopped and paused, current variables can be examined, etc. It is especially handy when troubleshooting a corner-case problem in your plugin. JEB can be debugged using a method called remote debugging . What you need to do is: Configure JEB to listen for debug connections Connect Eclipse to JEB Debugging setup: step-by-step # Start JEB using the following command-line from your JEB base directory: Windows/Linux java -Xdebug -Xrunjdwp:transport=dt_socket,address=8001,server=y,suspend=y -jar bin/app/jeb.jar.jar macOS java -XstartOnFirstThread -Xdebug -Xrunjdwp:transport=dt_socket,address=8001,server=y,suspend=y -jar bin/app/jeb.jar JEB is not started yet: it is waiting for a debugger connection on port 8001 Go to Eclipse: Select Run, Debug Configuration... Create a new entry in Remote Java Application and change the port to 8001 (keep the host as localhost ) Select Debug JEB should be launched and you may be able to stop when putting breakpoints in code. In practice, the true entry-point of a plugin is its no-argument constructor. You may decide to place a breakpoint there. You may also choose to stop in the canIdentify() method, which is appropriate for processor plugins such as this sample JavaScript parser.","title":"Part 5: Development Tips"},{"location":"dev/5-development-tips.html#logging","text":"","title":"Logging"},{"location":"dev/5-development-tips.html#creating-loggers","text":"Creating a new logger with the JEB API is simple: private static final ILogger logger = GlobalLog . getLogger ( MyClass . class ); It is good practice to create one logger per class. Loggers can be customized one by one, or globally via the GlobalLog factory.","title":"Creating Loggers"},{"location":"dev/5-development-tips.html#using-loggers","text":"There are several level of logs (error, warning, info, ...) and the logger methods use 2 parameters: the message to display the parameters of the message, as it is done for String.format() method. logger . info ( \"Hello %s\" , \"World\" );","title":"Using Loggers"},{"location":"dev/5-development-tips.html#enabling-debug-and-trace-levels","text":"By default, debug and trace logs are not displayed. You can activate them by ticking the Development mode in the Options menu:","title":"Enabling Debug and Trace levels"},{"location":"dev/5-development-tips.html#logging-destinations","text":"By default, JEB sends log data to the Logger view in the UI client. Additional sinks can be added, such as buffers or output streams. For instance, if you would like to collect all logs to a file named jeb-test-output.log in your TEMP folder, your plugin could execute the following: String foldername = System . getProperty ( \"java.io.tmpdir\" ); File folder = foldername != null ? new File ( foldername ): TestData . getTestDataRoot (); File file = new File ( folder , \"jeb-test-output.log\" ); GlobalLog . addDestinationStream ( new PrintStream ( file )); Note Be careful, GlobalLog is a global factory object, that impacts the entire application.","title":"Logging destinations"},{"location":"dev/5-development-tips.html#debugging","text":"If you are familiar with Eclipse and development tools in general, you know how useful proper debugging facility are: the program can be stopped and paused, current variables can be examined, etc. It is especially handy when troubleshooting a corner-case problem in your plugin. JEB can be debugged using a method called remote debugging . What you need to do is: Configure JEB to listen for debug connections Connect Eclipse to JEB","title":"Debugging"},{"location":"dev/5-development-tips.html#debugging-setup-step-by-step","text":"Start JEB using the following command-line from your JEB base directory: Windows/Linux java -Xdebug -Xrunjdwp:transport=dt_socket,address=8001,server=y,suspend=y -jar bin/app/jeb.jar.jar macOS java -XstartOnFirstThread -Xdebug -Xrunjdwp:transport=dt_socket,address=8001,server=y,suspend=y -jar bin/app/jeb.jar JEB is not started yet: it is waiting for a debugger connection on port 8001 Go to Eclipse: Select Run, Debug Configuration... Create a new entry in Remote Java Application and change the port to 8001 (keep the host as localhost ) Select Debug JEB should be launched and you may be able to stop when putting breakpoints in code. In practice, the true entry-point of a plugin is its no-argument constructor. You may decide to place a breakpoint there. You may also choose to stop in the canIdentify() method, which is appropriate for processor plugins such as this sample JavaScript parser.","title":"Debugging setup: step-by-step"},{"location":"dev/6-releasing-plugin.html","text":"JEB Plugin Development Tutorial part 6/8 When your plugin is ready, you may be looking into some way to share it. It is not convenient to hand out classfiles, not to mention changing Classpath and Classnames in the JEB Options panel. The solution is to package your plugin: this page shows you how to build a jar file containing your JEB plugin. Ant Build File # First, make sure to have a JEB_HOME environment variable pointing to your JEB directory. Then, use the following Ant build.xml file to build the sample JavaScript plugin. <?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?> <project basedir= \".\" default= \"build\" name= \"jebplugin\" > <property name= \"jebjar\" value= \"${env.JEB_HOME}/bin/cl/jeb.jar\" /> <property name= \"jebpath\" value= \"/home/clucas/jeb-2.0.6.201508260620/bin/cl/jeb.jar\" /> <property name= \"outfile\" value= \"out/JebJavascriptPlugin.jar\" /> <property name= \"entryclass\" value= \"com.jeb.sample.JavascriptPlugin\" /> <property name= \"extcp_build\" value= \"lib/js.jar\" /> <property name= \"extcp_manifest\" value= \"lib/js.jar\" /> <target name= \"build\" depends= \"compile,package\" /> <target name= \"compile\" > <delete dir= \"bin\" /> <mkdir dir= \"bin\" /> <javac debug= \"true\" debuglevel= \"source,lines,vars\" destdir= \"bin\" includeantruntime= \"false\" source= \"1.7\" target= \"1.7\" > <src path= \"src\" /> <classpath> <pathelement location= \"${jebpath}\" /> <pathelement path= \"${extcp_build}\" /> </classpath> </javac> </target> <target name= \"package\" > <delete file= \"${outfile}\" /> <jar destfile= \"${outfile}\" > <manifest> <attribute name= \"Class-Path\" value= \"${extcp_manifest}\" /> <attribute name= \"JebPlugin-entryclass\" value= \"${entryclass}\" /> </manifest> <fileset dir= \"bin\" /> <fileset dir= \".\" includes= \"README.md\" /> </jar> </target> </project> Building the Plugin # You can run the build.xml directly from eclipse or execute the Ant command. It will generate a jar which has 2 specific entries in the manifest: Class-Path to indicate the required external libraries. JebPlugin-entryclass to indicate the classname, ie your plugin entry-point Copy both JebJavascriptPlugin.jar and js.jar to your plugin folder. You can remove the classpath and classnames entries related to JavascriptPlugin and js.jar. Note The best approach is to have one project per plugin. Assignment: Split the project and generate JavascriptPlugin.jar and HashJavascriptPlugin.jar. Remove all classpaths and classnames to check that it works. Generic Build Template # The following Ant template can be customized for your own plugins needs: <?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?> <!-- Sample Ant build file used to build and package a JEB plugin. - Requirements: set up the JEB_HOME environment variable to point to your JEB installation folder. - Customize the outfile, entryclass, extcp_build, and extcp_manifest properties. --> <project basedir= \".\" default= \"build\" name= \"jebplugin\" > <fail message= \"Set the plugin version number: ant -Dversion=x.y.z\" > <condition> <not> <isset property= \"version\" /> </not> </condition> </fail> <echo message= \"Plugin version: ${version}\" /> <property environment= \"env\" /> <echo message= \"JEB_HOME: ${env.JEB_HOME}\" /> <property name= \"jebjar\" value= \"${env.JEB_HOME}/bin/cl/jeb.jar\" /> <echo message= \"JEB Core expected at location: ${jebjar}\" /> <fail message= \"Please set JEB_HOME environment variable to point to your JEB installation folder\" > <condition> <not> <available file= \"${jebjar}\" /> </not> </condition> </fail> <property name= \"debuglevel\" value= \"source,lines,vars\" /> <property name= \"target\" value= \"1.7\" /> <property name= \"source\" value= \"1.7\" /> <!-- Mandatory properties --> <property name= \"outfile\" value= \"CUSTOMIZE\" /> <property name= \"entryclass\" value= \"CUSTOMIZE\" /> <!-- External libraries, for build process (semi-colon separated) --> <property name= \"extcp_build\" value= \"\" /> <!-- External libraries, for Manifest (space separated) --> <property name= \"extcp_manifest\" value= \"\" /> <target name= \"build\" depends= \"clean,compile,package\" /> <target name= \"audit\" depends= \"clean,compile-audit\" /> <target name= \"clean\" > <delete dir= \"bin\" /> <mkdir dir= \"bin\" /> </target> <target name= \"compile\" > <delete dir= \"bin\" /> <mkdir dir= \"bin\" /> <javac debug= \"true\" debuglevel= \"${debuglevel}\" destdir= \"bin\" includeantruntime= \"false\" source= \"${source}\" target= \"${target}\" encoding= \"UTF-8\" > <src path= \"src/main/java\" /> <classpath> <pathelement location= \"${jebjar}\" /> <pathelement path= \"${extcp_build}\" /> </classpath> </javac> </target> <target name= \"package\" > <delete file= \"${outfile}\" /> <jar destfile= \"${outfile}\" > <manifest> <attribute name= \"Class-Path\" value= \"${extcp_manifest}\" /> <attribute name= \"JebPlugin-entryclass\" value= \"${entryclass}\" /> <attribute name= \"JebPlugin-version\" value= \"${version}\" /> </manifest> <fileset dir= \"bin\" /> <!-- copy resources --> <fileset dir= \"src/main/java\" excludes= \"**/*.java\" /> <fileset dir= \".\" includes= \"README.md\" /> </jar> </target> </project>","title":"Part 6: Releasing a Plugin"},{"location":"dev/6-releasing-plugin.html#ant-build-file","text":"First, make sure to have a JEB_HOME environment variable pointing to your JEB directory. Then, use the following Ant build.xml file to build the sample JavaScript plugin. <?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?> <project basedir= \".\" default= \"build\" name= \"jebplugin\" > <property name= \"jebjar\" value= \"${env.JEB_HOME}/bin/cl/jeb.jar\" /> <property name= \"jebpath\" value= \"/home/clucas/jeb-2.0.6.201508260620/bin/cl/jeb.jar\" /> <property name= \"outfile\" value= \"out/JebJavascriptPlugin.jar\" /> <property name= \"entryclass\" value= \"com.jeb.sample.JavascriptPlugin\" /> <property name= \"extcp_build\" value= \"lib/js.jar\" /> <property name= \"extcp_manifest\" value= \"lib/js.jar\" /> <target name= \"build\" depends= \"compile,package\" /> <target name= \"compile\" > <delete dir= \"bin\" /> <mkdir dir= \"bin\" /> <javac debug= \"true\" debuglevel= \"source,lines,vars\" destdir= \"bin\" includeantruntime= \"false\" source= \"1.7\" target= \"1.7\" > <src path= \"src\" /> <classpath> <pathelement location= \"${jebpath}\" /> <pathelement path= \"${extcp_build}\" /> </classpath> </javac> </target> <target name= \"package\" > <delete file= \"${outfile}\" /> <jar destfile= \"${outfile}\" > <manifest> <attribute name= \"Class-Path\" value= \"${extcp_manifest}\" /> <attribute name= \"JebPlugin-entryclass\" value= \"${entryclass}\" /> </manifest> <fileset dir= \"bin\" /> <fileset dir= \".\" includes= \"README.md\" /> </jar> </target> </project>","title":"Ant Build File"},{"location":"dev/6-releasing-plugin.html#building-the-plugin","text":"You can run the build.xml directly from eclipse or execute the Ant command. It will generate a jar which has 2 specific entries in the manifest: Class-Path to indicate the required external libraries. JebPlugin-entryclass to indicate the classname, ie your plugin entry-point Copy both JebJavascriptPlugin.jar and js.jar to your plugin folder. You can remove the classpath and classnames entries related to JavascriptPlugin and js.jar. Note The best approach is to have one project per plugin. Assignment: Split the project and generate JavascriptPlugin.jar and HashJavascriptPlugin.jar. Remove all classpaths and classnames to check that it works.","title":"Building the Plugin"},{"location":"dev/6-releasing-plugin.html#generic-build-template","text":"The following Ant template can be customized for your own plugins needs: <?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?> <!-- Sample Ant build file used to build and package a JEB plugin. - Requirements: set up the JEB_HOME environment variable to point to your JEB installation folder. - Customize the outfile, entryclass, extcp_build, and extcp_manifest properties. --> <project basedir= \".\" default= \"build\" name= \"jebplugin\" > <fail message= \"Set the plugin version number: ant -Dversion=x.y.z\" > <condition> <not> <isset property= \"version\" /> </not> </condition> </fail> <echo message= \"Plugin version: ${version}\" /> <property environment= \"env\" /> <echo message= \"JEB_HOME: ${env.JEB_HOME}\" /> <property name= \"jebjar\" value= \"${env.JEB_HOME}/bin/cl/jeb.jar\" /> <echo message= \"JEB Core expected at location: ${jebjar}\" /> <fail message= \"Please set JEB_HOME environment variable to point to your JEB installation folder\" > <condition> <not> <available file= \"${jebjar}\" /> </not> </condition> </fail> <property name= \"debuglevel\" value= \"source,lines,vars\" /> <property name= \"target\" value= \"1.7\" /> <property name= \"source\" value= \"1.7\" /> <!-- Mandatory properties --> <property name= \"outfile\" value= \"CUSTOMIZE\" /> <property name= \"entryclass\" value= \"CUSTOMIZE\" /> <!-- External libraries, for build process (semi-colon separated) --> <property name= \"extcp_build\" value= \"\" /> <!-- External libraries, for Manifest (space separated) --> <property name= \"extcp_manifest\" value= \"\" /> <target name= \"build\" depends= \"clean,compile,package\" /> <target name= \"audit\" depends= \"clean,compile-audit\" /> <target name= \"clean\" > <delete dir= \"bin\" /> <mkdir dir= \"bin\" /> </target> <target name= \"compile\" > <delete dir= \"bin\" /> <mkdir dir= \"bin\" /> <javac debug= \"true\" debuglevel= \"${debuglevel}\" destdir= \"bin\" includeantruntime= \"false\" source= \"${source}\" target= \"${target}\" encoding= \"UTF-8\" > <src path= \"src/main/java\" /> <classpath> <pathelement location= \"${jebjar}\" /> <pathelement path= \"${extcp_build}\" /> </classpath> </javac> </target> <target name= \"package\" > <delete file= \"${outfile}\" /> <jar destfile= \"${outfile}\" > <manifest> <attribute name= \"Class-Path\" value= \"${extcp_manifest}\" /> <attribute name= \"JebPlugin-entryclass\" value= \"${entryclass}\" /> <attribute name= \"JebPlugin-version\" value= \"${version}\" /> </manifest> <fileset dir= \"bin\" /> <!-- copy resources --> <fileset dir= \"src/main/java\" excludes= \"**/*.java\" /> <fileset dir= \".\" includes= \"README.md\" /> </jar> </target> </project>","title":"Generic Build Template"},{"location":"dev/7-unit-interactivity.html","text":"JEB Plugin Development Tutorial part 7/8 The source code for part 7 of this sample plugin is located on GitHub: Clone this repo : git clone https://github.com/pnfsoftware/jeb2-plugindemo-js.git Switch to the tutorial7 branch: git checkout tutorial7 Syntax Highlighting # Let's dive deeper and implement the first thing we want to get from an editor: syntax highlighting. This will allow us to uncover more corners of the JEB API. We will need to add item highlights on some parts of the text. Remember our sample, we will use only a single part: function a () { alert ( \"a called\" ); } A standard editor highlights keywords: they are specific words (reserved, most of the time) that are related to a language. In JavaScript, they are \"function\", \"var\", \"if\", \"else\"... Other interesting artifacts that could be highlighted are strings. In this tutorial, we will highlight functions, variables and strings surrounded by double-quotes. We want to modify only the display, not interact with the model (eg, renaming, formatting), so we will only look at ITextDocument . It has two important features: it builds ITextDocumentPart it has a coordinate to/from address conversion system. We will see this later. Let's concentrate on the ITextDocumentPart . The interface defines two methods: one returns a list of ILine objects: the part is split into lines. the other one returns a list of IAnchor objects. Anchors act the same as chapters for a book: an anchor indicates the beginning of a new section. If you don't need it, you can use a single anchor for the entire document. Remember that a part represents a part of the document (for buffered document) or can include the whole document. So the list of lines can be all the lines or just the lines of a part. We won't treat buffered document in this tutorial to keep things simple. Once again, let's check only the most important object, ILine . It contains: a CharSequence : the text line a List of ITextItem . As said in the API: A text item is used to identify a particular sequence of characters. This looks like what we were looking for. We will need to add ITextItem to our current model. The TextItem default implementation can be used. It takes as argument: the start offset of the keyword the length of the keyword an ItemClassIdentifiers identifier to apply a specific semantic and eventually, style, to your element. You can configure the display of these styles in the Edit, Fonts and Style... panel. Assignment Clone the sample code and checkout the tutorial7 branch. It already displays functions using a special ItemClassIdentifiers. Try to do the same for the var keyword and string constants. Notifications # JEB is a security-oriented product: its aim is to help you analyze malicious code and pin-point potential areas of interest. Notifications can be used to show areas that are noteworthy; styles can be attached to notifications to highlight their corresponding elements on rendering. Notifications are global to a unit, they should be generated when the processor plugin process() -es the input. For the sake of this tutorial, we want to highlight the usage of function \"alert\" because it can block the UI unreasonably. The AbstractUnit interface exposes the following method: public addtNotifications(IUnitNotification unit); We will use the default implementation: UnitNotification . In the process() method of your JavaScript plugin, add the following snippet: root . visit ( new NodeVisitor () { @Override public boolean visit ( AstNode node ) { switch ( node . getType ()) { case Token . EXPR_VOID : case Token . EXPR_RESULT : break ; case Token . CALL : visitTarget ((( FunctionCall ) node ). getTarget ()); break ; default : break ; } return true ; } private void visitTarget ( AstNode target ) { if ( target . getType () == Token . NAME ) { if ((( Name ) target ). getIdentifier (). equals ( \"alert\" )) { // Add notification addNotification ( new UnitNotification ( NotificationType . POTENTIALLY_HARMFUL , String . format ( \"alert is detected at position %d\" , target . getAbsolutePosition ()))); } } } } ); The visit() method recursively process all the elements. When we have a JavaScript function call, we check the name and add a notification if the function is \"alert\". Now, you should see something new in the UI: If you want to see all notifications as soon as the file is opened in JEB, you will need to slightly modify your code. Since the process() method is only called on opening an IUnit, the best is to call it directly after IUnit creation: public IUnit prepare ( String name , IInput input , IUnitProcessor unitProcessor , IUnitCreator parent ) { IUnit sampleUnit = new SampleUnit ( name , input , unitProcessor , parent , pdm ); sampleUnit . process (); // forces children calculation return sampleUnit ; } Always be careful to add this line somewhere in the process() method to indicate that the processing should not be done once again: setProcessed ( true ); Now, we see something interesting on the screenshot: there is an address column that is blank. IUnitNotification defines an address binding which can be used to jump to the related section. Let's see how to use it. Addressing # To be able to jump to a correct Address , we need to define a binding from Unit addressing (address) to a position in a Document (coordinates). ITextDocument uses ICoordinates : it contains the anchor id, a line number relative to the anchor, and the position (column offset) in the line. Addresses, however, are user-defined (in this context, the user is the plugin developer): it is up to user to define them and their granularity. For instance, you can choose to support addresses: at function level/ element level. For example: \"function a\", \"function a / statement 1\" at byte level. For example, using absolute byte address in file: \"0x1A\", \"0x89\" at any other level. For example, at each line, each character for that line, etc. The important aspect of addresses is that an address must not be directly tied to a Document (your implementation of Document can change: if you add a beautifier, if you decide to format your document on a single line, if you use a tree/table for your representation, etc.). Of course, there should still be a way to make the link between the two addressing systems: Note Refer to the technical draft \"Positioning within inputs, units, and documents\" for additional details on addressing. At last, an address must identify an object/position in a unique way. Otherwise, you wouldn't know where to jump. For our sample JavaScript plugin, we will use the addressing using AstNode.getAbsolutePosition() . When jumping from Notification Panel, we have the current address (Absolute position), and we will jump to an ICoordinates in the ITextDocument. So the main method to implement is: public ICoordinates addressToCoordinates(String address); Assignment Implement the addressToCoordinates method. There is also another column in the Notification Panel called \"Label\": it represents the label of the address. You can indicate here a human readable label: for example, the name of the function. To display label, we need to inherit from IInteractiveUnit and implement String getAddressLabel(String address) to see changes in the Notification Panel. Assignment Implement the getAddressLabel method. A solution to the assignments can be found by checking out the branch tutorial7_solution of the sample code . You may have noticed that IInteractiveUnit provides a lot of methods. We will focus on it in the next part!","title":"Part 7: Interactivity"},{"location":"dev/7-unit-interactivity.html#syntax-highlighting","text":"Let's dive deeper and implement the first thing we want to get from an editor: syntax highlighting. This will allow us to uncover more corners of the JEB API. We will need to add item highlights on some parts of the text. Remember our sample, we will use only a single part: function a () { alert ( \"a called\" ); } A standard editor highlights keywords: they are specific words (reserved, most of the time) that are related to a language. In JavaScript, they are \"function\", \"var\", \"if\", \"else\"... Other interesting artifacts that could be highlighted are strings. In this tutorial, we will highlight functions, variables and strings surrounded by double-quotes. We want to modify only the display, not interact with the model (eg, renaming, formatting), so we will only look at ITextDocument . It has two important features: it builds ITextDocumentPart it has a coordinate to/from address conversion system. We will see this later. Let's concentrate on the ITextDocumentPart . The interface defines two methods: one returns a list of ILine objects: the part is split into lines. the other one returns a list of IAnchor objects. Anchors act the same as chapters for a book: an anchor indicates the beginning of a new section. If you don't need it, you can use a single anchor for the entire document. Remember that a part represents a part of the document (for buffered document) or can include the whole document. So the list of lines can be all the lines or just the lines of a part. We won't treat buffered document in this tutorial to keep things simple. Once again, let's check only the most important object, ILine . It contains: a CharSequence : the text line a List of ITextItem . As said in the API: A text item is used to identify a particular sequence of characters. This looks like what we were looking for. We will need to add ITextItem to our current model. The TextItem default implementation can be used. It takes as argument: the start offset of the keyword the length of the keyword an ItemClassIdentifiers identifier to apply a specific semantic and eventually, style, to your element. You can configure the display of these styles in the Edit, Fonts and Style... panel. Assignment Clone the sample code and checkout the tutorial7 branch. It already displays functions using a special ItemClassIdentifiers. Try to do the same for the var keyword and string constants.","title":"Syntax Highlighting"},{"location":"dev/7-unit-interactivity.html#notifications","text":"JEB is a security-oriented product: its aim is to help you analyze malicious code and pin-point potential areas of interest. Notifications can be used to show areas that are noteworthy; styles can be attached to notifications to highlight their corresponding elements on rendering. Notifications are global to a unit, they should be generated when the processor plugin process() -es the input. For the sake of this tutorial, we want to highlight the usage of function \"alert\" because it can block the UI unreasonably. The AbstractUnit interface exposes the following method: public addtNotifications(IUnitNotification unit); We will use the default implementation: UnitNotification . In the process() method of your JavaScript plugin, add the following snippet: root . visit ( new NodeVisitor () { @Override public boolean visit ( AstNode node ) { switch ( node . getType ()) { case Token . EXPR_VOID : case Token . EXPR_RESULT : break ; case Token . CALL : visitTarget ((( FunctionCall ) node ). getTarget ()); break ; default : break ; } return true ; } private void visitTarget ( AstNode target ) { if ( target . getType () == Token . NAME ) { if ((( Name ) target ). getIdentifier (). equals ( \"alert\" )) { // Add notification addNotification ( new UnitNotification ( NotificationType . POTENTIALLY_HARMFUL , String . format ( \"alert is detected at position %d\" , target . getAbsolutePosition ()))); } } } } ); The visit() method recursively process all the elements. When we have a JavaScript function call, we check the name and add a notification if the function is \"alert\". Now, you should see something new in the UI: If you want to see all notifications as soon as the file is opened in JEB, you will need to slightly modify your code. Since the process() method is only called on opening an IUnit, the best is to call it directly after IUnit creation: public IUnit prepare ( String name , IInput input , IUnitProcessor unitProcessor , IUnitCreator parent ) { IUnit sampleUnit = new SampleUnit ( name , input , unitProcessor , parent , pdm ); sampleUnit . process (); // forces children calculation return sampleUnit ; } Always be careful to add this line somewhere in the process() method to indicate that the processing should not be done once again: setProcessed ( true ); Now, we see something interesting on the screenshot: there is an address column that is blank. IUnitNotification defines an address binding which can be used to jump to the related section. Let's see how to use it.","title":"Notifications"},{"location":"dev/7-unit-interactivity.html#addressing","text":"To be able to jump to a correct Address , we need to define a binding from Unit addressing (address) to a position in a Document (coordinates). ITextDocument uses ICoordinates : it contains the anchor id, a line number relative to the anchor, and the position (column offset) in the line. Addresses, however, are user-defined (in this context, the user is the plugin developer): it is up to user to define them and their granularity. For instance, you can choose to support addresses: at function level/ element level. For example: \"function a\", \"function a / statement 1\" at byte level. For example, using absolute byte address in file: \"0x1A\", \"0x89\" at any other level. For example, at each line, each character for that line, etc. The important aspect of addresses is that an address must not be directly tied to a Document (your implementation of Document can change: if you add a beautifier, if you decide to format your document on a single line, if you use a tree/table for your representation, etc.). Of course, there should still be a way to make the link between the two addressing systems: Note Refer to the technical draft \"Positioning within inputs, units, and documents\" for additional details on addressing. At last, an address must identify an object/position in a unique way. Otherwise, you wouldn't know where to jump. For our sample JavaScript plugin, we will use the addressing using AstNode.getAbsolutePosition() . When jumping from Notification Panel, we have the current address (Absolute position), and we will jump to an ICoordinates in the ITextDocument. So the main method to implement is: public ICoordinates addressToCoordinates(String address); Assignment Implement the addressToCoordinates method. There is also another column in the Notification Panel called \"Label\": it represents the label of the address. You can indicate here a human readable label: for example, the name of the function. To display label, we need to inherit from IInteractiveUnit and implement String getAddressLabel(String address) to see changes in the Notification Panel. Assignment Implement the getAddressLabel method. A solution to the assignments can be found by checking out the branch tutorial7_solution of the sample code . You may have noticed that IInteractiveUnit provides a lot of methods. We will focus on it in the next part!","title":"Addressing"},{"location":"dev/8-more-interactivity.html","text":"JEB Plugin Development Tutorial part 8/8 The source code for part 8 of this sample plugin is located on GitHub: Clone this repo : git clone https://github.com/pnfsoftware/jeb2-plugindemo-js.git Switch to the tutorial8 branch: git checkout tutorial8 User Actions # CanExecute # JEB provides the ability to interact with the units. Those units are called interactive units . The simplest way to interact with units is through well-known actions . The actions have to be implemented by the plugin developer. An action has an ActionContext as a parameter, which allows the plugin to retrieve: the action id: one defined in the Actions class. It indicates which action is involved (Comment, Rename...) the address: the current position in the document the item id: we will discuss it later. First, why are all these actions grayed out? Because canExecuteAction() does not return true - yet. public boolean canExecuteAction ( ActionContext actionContext ) { logger . info ( \"%s called with address %s and actionId %d\" , \"canExecuteAction\" , actionContext . getAddress (), actionContext . getActionId ()); return false ; } As you can see in the logs, this method is called each time you move the caret in the document. What if we try to return true instead of false? As expected, all actions become clickable. Note that you can also use the toolbar icons or, even better, the keyboard shortcuts. Nothing happens when you click on any action: it is up to the plugin developer to implement the desired feature. We will implement a simple action: renaming of a String . (Note: we could as well rename functions, methods, variables... but we need to check in the model where they are used to replace all occurrences, consistently. The added complexity is out-of-scope in this API introduction tutorial.) First, we need to activate the rename feature when we are on a String: Assignment Save the string references and test if the caret in on a String. PrepareExecution # When clicking on the \"Rename\" action button, the method IInteractiveUnit.prepareExecution() is called. Its goal is to prepare the execution of the code and, in the case of renaming, it also provides the initial value that we want to edit: it is called before displaying the following pop up: You need to return true in the prepareExecution method to indicate that the processing should continue. The prepareExecution method has one more parameter of type IActionData . To fill up the name field, we need to retrieve the correct Action Data type: Use ActionRenameData to prefill the rename field with its current value. public boolean prepareExecution ( ActionContext actionContext , IActionData actionData ) { if ( actionContext . getActionId () == Actions . RENAME ) { StringLiteral string = getElementAt ( actionContext . getAddress (), strings ); if ( string != null ) { (( ActionRenameData ) actionData ). setCurrentName ( string . getValue ()); return true ; } } return false ; } Note that IActionData embeds a generic map to pass discretionary objects from prepareExecution to executeAction method. ExecuteAction # The executeAction method is the last step: it performs the action and modifies the model. What should we modify now? IInput : this is a pointer to original file, it makes no sense. AstRoot : this is our kind-of model, but there is no way to retrieve the input data (the toString() method has a specific implementation and the toSource() auto-formats and remove comments. IUnit is the central part of your plugin: it is responsible for updating the model and keep coherence regarding all its document. But there is something wrong with the initial design: we don't save a reference Document in the Unit. Documents shall at least work with the same object as IUnit, and at least have a reference on their IUnit in order to retrieve the data (this is a good practice in JEB). Therefore, we will now modify our unit to keep references of all lines (using a List ). One problem that will remain is the mandatory conversion at the ITextDocumentPart level: public List <? extends ILine > getLines The getLines method is called each time you scroll/move around the document, so it would be too costly to recalculate the list of ILines each time it is called. It must be buffered and refreshed on changes: the unit must notify its Documents when the model changes. To make notifications work, you must: Register the notified element: public class JavascriptDocument extends EventSource implements ITextDocument , IEventListener { public JavascriptDocument ( JavascriptUnit unit ) { this . unit = unit ; unit . addListener ( this ); refreshPart (); } // ... public void onEvent ( IEvent e ) { if ( e . getType () == J . UnitChange ) { refreshPart (); this . notifyListeners ( e ); } } } Call the notify method in the executeAction method (on success): notifyListeners ( new JebEvent ( J . UnitChange )); Note Refer to the technical draft \"Staying informed of unit changes\" for more details about unit changes tracking within documents. Assignment Finish the renaming implementation. Navigation # JEB natively manages navigation feature with four predefined actions selectable from menu or directly with shortcuts: Jump To : move caret to a specific address. It uses the ITextDocument.addressToCoordinates() that we already implemented for Notifications. Navigate Forward / Navigate Backward : move caret to the previous/next position (caret position history is saved each time you jump) Follow : jump to an address bound to the current element. The best example is on a function call: you can jump to its definition Assignment Implement Jump To for function names Now, let's look at Follow . We can see that it is active only when we set the caret on strings, var, function... this is because the Follow feature is bound to Items, more precisely, the IActionableItem . When clicking on Follow , if the caret is positioned on an Item, the function IInteractiveUnit.getAddressOfItem() is called. Assignment Implement Follow for function name (it should work on the latest b();) A solution to the assignments can be found by checking out the branch tutorial8 of the sample code .","title":"Part 8: More on Interactivity"},{"location":"dev/8-more-interactivity.html#user-actions","text":"","title":"User Actions"},{"location":"dev/8-more-interactivity.html#canexecute","text":"JEB provides the ability to interact with the units. Those units are called interactive units . The simplest way to interact with units is through well-known actions . The actions have to be implemented by the plugin developer. An action has an ActionContext as a parameter, which allows the plugin to retrieve: the action id: one defined in the Actions class. It indicates which action is involved (Comment, Rename...) the address: the current position in the document the item id: we will discuss it later. First, why are all these actions grayed out? Because canExecuteAction() does not return true - yet. public boolean canExecuteAction ( ActionContext actionContext ) { logger . info ( \"%s called with address %s and actionId %d\" , \"canExecuteAction\" , actionContext . getAddress (), actionContext . getActionId ()); return false ; } As you can see in the logs, this method is called each time you move the caret in the document. What if we try to return true instead of false? As expected, all actions become clickable. Note that you can also use the toolbar icons or, even better, the keyboard shortcuts. Nothing happens when you click on any action: it is up to the plugin developer to implement the desired feature. We will implement a simple action: renaming of a String . (Note: we could as well rename functions, methods, variables... but we need to check in the model where they are used to replace all occurrences, consistently. The added complexity is out-of-scope in this API introduction tutorial.) First, we need to activate the rename feature when we are on a String: Assignment Save the string references and test if the caret in on a String.","title":"CanExecute"},{"location":"dev/8-more-interactivity.html#prepareexecution","text":"When clicking on the \"Rename\" action button, the method IInteractiveUnit.prepareExecution() is called. Its goal is to prepare the execution of the code and, in the case of renaming, it also provides the initial value that we want to edit: it is called before displaying the following pop up: You need to return true in the prepareExecution method to indicate that the processing should continue. The prepareExecution method has one more parameter of type IActionData . To fill up the name field, we need to retrieve the correct Action Data type: Use ActionRenameData to prefill the rename field with its current value. public boolean prepareExecution ( ActionContext actionContext , IActionData actionData ) { if ( actionContext . getActionId () == Actions . RENAME ) { StringLiteral string = getElementAt ( actionContext . getAddress (), strings ); if ( string != null ) { (( ActionRenameData ) actionData ). setCurrentName ( string . getValue ()); return true ; } } return false ; } Note that IActionData embeds a generic map to pass discretionary objects from prepareExecution to executeAction method.","title":"PrepareExecution"},{"location":"dev/8-more-interactivity.html#executeaction","text":"The executeAction method is the last step: it performs the action and modifies the model. What should we modify now? IInput : this is a pointer to original file, it makes no sense. AstRoot : this is our kind-of model, but there is no way to retrieve the input data (the toString() method has a specific implementation and the toSource() auto-formats and remove comments. IUnit is the central part of your plugin: it is responsible for updating the model and keep coherence regarding all its document. But there is something wrong with the initial design: we don't save a reference Document in the Unit. Documents shall at least work with the same object as IUnit, and at least have a reference on their IUnit in order to retrieve the data (this is a good practice in JEB). Therefore, we will now modify our unit to keep references of all lines (using a List ). One problem that will remain is the mandatory conversion at the ITextDocumentPart level: public List <? extends ILine > getLines The getLines method is called each time you scroll/move around the document, so it would be too costly to recalculate the list of ILines each time it is called. It must be buffered and refreshed on changes: the unit must notify its Documents when the model changes. To make notifications work, you must: Register the notified element: public class JavascriptDocument extends EventSource implements ITextDocument , IEventListener { public JavascriptDocument ( JavascriptUnit unit ) { this . unit = unit ; unit . addListener ( this ); refreshPart (); } // ... public void onEvent ( IEvent e ) { if ( e . getType () == J . UnitChange ) { refreshPart (); this . notifyListeners ( e ); } } } Call the notify method in the executeAction method (on success): notifyListeners ( new JebEvent ( J . UnitChange )); Note Refer to the technical draft \"Staying informed of unit changes\" for more details about unit changes tracking within documents. Assignment Finish the renaming implementation.","title":"ExecuteAction"},{"location":"dev/8-more-interactivity.html#navigation","text":"JEB natively manages navigation feature with four predefined actions selectable from menu or directly with shortcuts: Jump To : move caret to a specific address. It uses the ITextDocument.addressToCoordinates() that we already implemented for Notifications. Navigate Forward / Navigate Backward : move caret to the previous/next position (caret position history is saved each time you jump) Follow : jump to an address bound to the current element. The best example is on a function call: you can jump to its definition Assignment Implement Jump To for function names Now, let's look at Follow . We can see that it is active only when we set the caret on strings, var, function... this is because the Follow feature is bound to Items, more precisely, the IActionableItem . When clicking on Follow , if the caret is positioned on an Item, the function IInteractiveUnit.getAddressOfItem() is called. Assignment Implement Follow for function name (it should work on the latest b();) A solution to the assignments can be found by checking out the branch tutorial8 of the sample code .","title":"Navigation"},{"location":"dev/android-scripting.html","text":"This section will focus on writing JEB Python scripts specifically to aid in the analysis of Android applications. TODO This document is a work-in-progress. UI client specificities # Manipulating DEX # IDexUnit and associated classes # Accessing the Java AST #","title":"Scripting for Android Reversing"},{"location":"dev/android-scripting.html#ui-client-specificities","text":"","title":"UI client specificities"},{"location":"dev/android-scripting.html#manipulating-dex","text":"","title":"Manipulating DEX"},{"location":"dev/android-scripting.html#idexunit-and-associated-classes","text":"","title":"IDexUnit and associated classes"},{"location":"dev/android-scripting.html#accessing-the-java-ast","text":"","title":"Accessing the Java AST"},{"location":"dev/introducing-jeb-extensions.html","text":"JEB offers a rich API that can be used to develop: Front-end clients , such as: The official UI client Headless clients for automation pipelines Plugins (aka back-end modules ): Processor plugins such as disassemblers, decompilers, debuggers, or any other type of analyzer Many processor plugins fall in the category of parsers and are sometimes referred as such Engines plugins such as second-pass code analyzers, working on results produced by other plugins, or helpers Scripts : Python scripts for automating simple tasks Python scripts that can interact with graphical clients that implement the UI-API (the UI client does) Capabilities # Only professional licenses offer full API access. However, all licenses allow script execution from within the UI client: Licenses Type UI client Other Clients (e.g. command-line) Non-Pro UI scripts no Pro UI scripts + plugins scripts + plugins High-level Architecture # Grasping the high-level concepts of how pieces fit together within JEB will make you a more efficient extensions developer. At the highest-level, JEB is separated into back-end and front-end components: The back-end components are responsible for processing input artifacts. They provide an execution environment for native and third-party plugins, including input artifact processor plugins, such as file parsers. The front-end components are responsible for processing input commands and rendering back-end results. A variety of front-ends may be created using the API exposed by the back-end. Note All JEB distributions ship with the UI client front-end that runs on all major desktop operating systems. The diagram below shows the relationship between back-end and front-end components: High-level architecture diagram Depending on their license type, users may be able to develop third-party plugins and instruct the back-end to load them. This enables power users to craft input processors that cater to their specific needs (e.g., a disassembler for an exotic or virtual CPU). You may verify your API usage capabilities by starting JEB with the -c --license command line flag. Application Programming Interfaces # The JEB API offers power-users ways to: write clients such as command-line processors (headless) write extensions, from simple scripts in Python to advanced analysis modules in Java The JEB API reference documentation is available online as well as offline, within your JEB software package (file doc/apidoc.zip ). Scripts vs Plugins # Scripts ... Implement IScript Are called by users to achieve small tasks Example: modify some code, navigate somewhere, display some info, etc. Have to to be written in Python (and are run within a Jython VM) Ideal for rapid development and prototyping Are executed by JEB on-demand In UI client, can be executed via the File menu Plugins ... Implement IPlugin ( IUnitIdentifier for processor plugins, IEnginesPlugin for engines plugins) Are designed to process input (for processor plugins) or do other tasks (for engines plugins) Example: disassemble or decompile code, do complex file parsing, etc. Must be written in Java Ideal for complex, large code bases Are loaded by JEB at start-up time List of loaded plugins can be seen in the File menu Executing Scripts # All versions of JEB can execute client scripts within the UI client. Scripts should be dropped in your scripts/ directory (or any other directory specified in your .ScriptsFolder client option ). Use the File, Script, Run Script... menu command to execute a script. The last run script can be executed again by pressing the F2 key. Client scripts are written in Python, and are executed within a 2.7 Jython VM (a Java implementation of the Python VM) Scripts, like any extension, use the JEB API. Client scripts executed inside the UI client also have access to the UI-API , located in the package com.pnfsoftware.jeb.client.ui . Classes of the UI-API allow graphical manipulation of views, fragments, items, etc. (This API is optionally implemented by clients; the desktop client implements it.) You will find a large collection of sample scripts on our public GitHub repository . Executing Engines Plugins # All third-party plugins must be dropped in your coreplugins/ directory (or any other directory specified in your .PluginsFolder back-end option ). Use the File, Engines, Execute, ... menu command to execute an engines plugin. Note Engines plugins are JEB plugins that implement the IEnginesPlugin interface. The full list of engines plugins loaded within your JEB instance context can be seen by running the File, Engines, Plugins command. You may double-click a plugin to execute it. A collection of open-source plugins can be found on our public GitHub repository .","title":"Introducing JEB Extensions"},{"location":"dev/introducing-jeb-extensions.html#capabilities","text":"Only professional licenses offer full API access. However, all licenses allow script execution from within the UI client: Licenses Type UI client Other Clients (e.g. command-line) Non-Pro UI scripts no Pro UI scripts + plugins scripts + plugins","title":"Capabilities"},{"location":"dev/introducing-jeb-extensions.html#high-level-architecture","text":"Grasping the high-level concepts of how pieces fit together within JEB will make you a more efficient extensions developer. At the highest-level, JEB is separated into back-end and front-end components: The back-end components are responsible for processing input artifacts. They provide an execution environment for native and third-party plugins, including input artifact processor plugins, such as file parsers. The front-end components are responsible for processing input commands and rendering back-end results. A variety of front-ends may be created using the API exposed by the back-end. Note All JEB distributions ship with the UI client front-end that runs on all major desktop operating systems. The diagram below shows the relationship between back-end and front-end components: High-level architecture diagram Depending on their license type, users may be able to develop third-party plugins and instruct the back-end to load them. This enables power users to craft input processors that cater to their specific needs (e.g., a disassembler for an exotic or virtual CPU). You may verify your API usage capabilities by starting JEB with the -c --license command line flag.","title":"High-level Architecture"},{"location":"dev/introducing-jeb-extensions.html#application-programming-interfaces","text":"The JEB API offers power-users ways to: write clients such as command-line processors (headless) write extensions, from simple scripts in Python to advanced analysis modules in Java The JEB API reference documentation is available online as well as offline, within your JEB software package (file doc/apidoc.zip ).","title":"Application Programming Interfaces"},{"location":"dev/introducing-jeb-extensions.html#scripts-vs-plugins","text":"Scripts ... Implement IScript Are called by users to achieve small tasks Example: modify some code, navigate somewhere, display some info, etc. Have to to be written in Python (and are run within a Jython VM) Ideal for rapid development and prototyping Are executed by JEB on-demand In UI client, can be executed via the File menu Plugins ... Implement IPlugin ( IUnitIdentifier for processor plugins, IEnginesPlugin for engines plugins) Are designed to process input (for processor plugins) or do other tasks (for engines plugins) Example: disassemble or decompile code, do complex file parsing, etc. Must be written in Java Ideal for complex, large code bases Are loaded by JEB at start-up time List of loaded plugins can be seen in the File menu","title":"Scripts vs Plugins"},{"location":"dev/introducing-jeb-extensions.html#executing-scripts","text":"All versions of JEB can execute client scripts within the UI client. Scripts should be dropped in your scripts/ directory (or any other directory specified in your .ScriptsFolder client option ). Use the File, Script, Run Script... menu command to execute a script. The last run script can be executed again by pressing the F2 key. Client scripts are written in Python, and are executed within a 2.7 Jython VM (a Java implementation of the Python VM) Scripts, like any extension, use the JEB API. Client scripts executed inside the UI client also have access to the UI-API , located in the package com.pnfsoftware.jeb.client.ui . Classes of the UI-API allow graphical manipulation of views, fragments, items, etc. (This API is optionally implemented by clients; the desktop client implements it.) You will find a large collection of sample scripts on our public GitHub repository .","title":"Executing Scripts"},{"location":"dev/introducing-jeb-extensions.html#executing-engines-plugins","text":"All third-party plugins must be dropped in your coreplugins/ directory (or any other directory specified in your .PluginsFolder back-end option ). Use the File, Engines, Execute, ... menu command to execute an engines plugin. Note Engines plugins are JEB plugins that implement the IEnginesPlugin interface. The full list of engines plugins loaded within your JEB instance context can be seen by running the File, Engines, Plugins command. You may double-click a plugin to execute it. A collection of open-source plugins can be found on our public GitHub repository .","title":"Executing Engines Plugins"},{"location":"dev/other-resources.html","text":"Technical drafts for developers: (available on Google Drive) Parser Delegation MVC and Unit Documents Positioning within Units Units Hierarchy Join us on Slack for interactive discussions if you have questions about the API.","title":"Additional Resources"},{"location":"dev/writing-client-scripts.html","text":"JEB supports the execution of Python scripts . Scripts should perform relatively small, light-weight actions They are written using the Python 2.7 syntax and features, and are executed by a Jython VM Prerequisite # A Jython stand-alone package is required to run scripts. JEB bundles the latest 2.7 package. Legacy If you are using JEB 2, download either Jython 2.7 (newer, slower to load) or Jython 2.5 (older and slimmer, faster to load) and drop it in your JEB scripts/ sub-directory. Features # Scripts can: use the standard JEB API use the Client API package if run within a client that implements the UI-API, use the JEB UI Client API A client script implements the IScript interface. Upon execution, the script run() entry-point method is provided an IClientContext or derived object, such as an IGraphicalClientContext for UI clients, such as the official UI desktop client. A Simple Script # Here is the simplest of all scripts: from com.pnfsoftware.jeb.client.api import IScript class JEBSampleScript ( IScript ): def run ( self , ctx ): print ( 'Hello, JEB version %s ' % ctx . getSoftwareVersion ()) print ( '- Arguments: %s ' % ctx . getArguments ()) print ( '- Base directory: %s ' % ctx . getBaseDirectory ()) Within the official desktop client, scripts can be executed via the File, Scripts menu item. Remember that heavy-lifting operations (such as parsing or background event-driven tasks) should be implemented by back-end plugins in Java. More scripts # Check out our GitHub repository for more sample scripts .","title":"Writing Client Scripts"},{"location":"dev/writing-client-scripts.html#prerequisite","text":"A Jython stand-alone package is required to run scripts. JEB bundles the latest 2.7 package. Legacy If you are using JEB 2, download either Jython 2.7 (newer, slower to load) or Jython 2.5 (older and slimmer, faster to load) and drop it in your JEB scripts/ sub-directory.","title":"Prerequisite"},{"location":"dev/writing-client-scripts.html#features","text":"Scripts can: use the standard JEB API use the Client API package if run within a client that implements the UI-API, use the JEB UI Client API A client script implements the IScript interface. Upon execution, the script run() entry-point method is provided an IClientContext or derived object, such as an IGraphicalClientContext for UI clients, such as the official UI desktop client.","title":"Features"},{"location":"dev/writing-client-scripts.html#a-simple-script","text":"Here is the simplest of all scripts: from com.pnfsoftware.jeb.client.api import IScript class JEBSampleScript ( IScript ): def run ( self , ctx ): print ( 'Hello, JEB version %s ' % ctx . getSoftwareVersion ()) print ( '- Arguments: %s ' % ctx . getArguments ()) print ( '- Base directory: %s ' % ctx . getBaseDirectory ()) Within the official desktop client, scripts can be executed via the File, Scripts menu item. Remember that heavy-lifting operations (such as parsing or background event-driven tasks) should be implemented by back-end plugins in Java.","title":"A Simple Script"},{"location":"dev/writing-client-scripts.html#more-scripts","text":"Check out our GitHub repository for more sample scripts .","title":"More scripts"},{"location":"dev/writing-engines-plugins.html","text":"Engines plugins, just like any JEB extension (parser, script, etc.) use the JEB API. They are loaded when JEB starts. Unlike parsers, their role is not to process input data to produce units; they are meant to perform pointed tasks. They can be called on-demand by clients. From a programmer's standpoint, engines plugins extend the IEnginesPlugin (whereas processor plugins extend the IUnitIdentifier interface). Sample Plugins # Sample plugins can be found on our GitHub account. Examples: Andhook : Android Cryptographic Primitives Hooking using the JEB Debuggers API ... Skeleton Plugin # Full source code: Sample plugin skeleton on GitHub public class SampleEnginesPlugin implements IEnginesPlugin { private static final ILogger logger = GlobalLog . getLogger ( SampleEnginesPlugin . class ); @Override public IPluginInformation getPluginInformation () { return new PluginInformation ( \"Sample Plugin\" , \"A sample JEB plugin\" , \"PNF Software\" , Version . create ( 1 , 0 )); } @Override public List <? extends IOptionDefinition > getExecutionOptionDefinitions () { return null ; } @Override public void execute ( IEnginesContext context ) { execute ( context , null ); } @Override public void execute ( IEnginesContext engctx , Map < String , String > executionOptions ) { logger . info ( \"Executing sample plugin\" ); } @Override public void dispose () { } }","title":"Writing Engines Plugins"},{"location":"dev/writing-engines-plugins.html#sample-plugins","text":"Sample plugins can be found on our GitHub account. Examples: Andhook : Android Cryptographic Primitives Hooking using the JEB Debuggers API ...","title":"Sample Plugins"},{"location":"dev/writing-engines-plugins.html#skeleton-plugin","text":"Full source code: Sample plugin skeleton on GitHub public class SampleEnginesPlugin implements IEnginesPlugin { private static final ILogger logger = GlobalLog . getLogger ( SampleEnginesPlugin . class ); @Override public IPluginInformation getPluginInformation () { return new PluginInformation ( \"Sample Plugin\" , \"A sample JEB plugin\" , \"PNF Software\" , Version . create ( 1 , 0 )); } @Override public List <? extends IOptionDefinition > getExecutionOptionDefinitions () { return null ; } @Override public void execute ( IEnginesContext context ) { execute ( context , null ); } @Override public void execute ( IEnginesContext engctx , Map < String , String > executionOptions ) { logger . info ( \"Executing sample plugin\" ); } @Override public void dispose () { } }","title":"Skeleton Plugin"},{"location":"dev/writing-front-ends.html","text":"JEB front-end are also referred to as \"JEB clients\" (or \"JEB third-party clients\", to contrast with the \"official UI desktop client\"). JEB back-end API makes writing new clients (aka, front-ends) an easy task. A client can be: An automated client (for testing, for an automation pipeline) A command-line client A graphical front-end (e.g., the official UI desktop client) ... Info Not all JEB licenses allow the creation of third-party clients. Verify this by checking your license information in the About dialog box. It should show any-client . Typically, JEB Pro licenses allow the execution of third-party clients. High-level Instructions # Use the provided source code template (see below) as a base for your client. The basic steps any client should take are the following: Use JebCoreService to retrieve an instance to ICoreContext Create an IEnginesContext Load a project within that context ( IRuntimeProject ) Add artifacts and process them ( ILiveArtifact ) Retrieve the products ( IUnit ) Proceed as usual with the units We recommend developers to read our tutorial series on parser development to get familiar with units Refer to the our simplified architecture diagrams to better visualize how those components are connected to one another. Source Template # Full source code: Command-line client skeleton on GitHub public class AutoClient { static final ILogger logger = GlobalLog . getLogger ( AutoClient . class ); static { GlobalLog . addDestinationStream ( System . out ); } // TODO: customize (should be replaced by the LicenseKey entry in your bin/jeb-client.cfg file) private static final String licenseKey = \"...\" ; // TODO: customize private static final String baseDir = \"...\" ; public static void main ( String [] argv ) throws Exception { if ( argv . length <= 0 ) { return ; } long t0 = System . currentTimeMillis (); String location = argv [ 0 ] ; List < File > files = AutoUtil . retrieveFiles ( location ); test ( files ); logger . info ( \"Done in %ds\" , ( System . currentTimeMillis () - t0 ) / 1000 ); } /** * Initialize a core. Create a context within that core. Then, for each input artifact, a * project is created and the artifact is loaded within that project. */ public static void test ( List < File > files ) throws Exception { // create or retrieve a core context (engines container) ICoreContext core = JebCoreService . getInstance ( licenseKey ); // create an engines context (project container) IFileDatabase projectdb = new JEB2FileDatabase ( baseDir ); IFileStore filestore = new SimpleFSFileStore ( baseDir ); BaseConfiguration cfg = new BaseConfiguration (); // TODO: customize (alternative is to read your configuration from .cfg file) cfg . setProperty ( \".DevPluginClasspath\" , \"...\" ); // TODO: customize cfg . setProperty ( \".DevPluginClassnames\" , \"...\" ); IConfiguration config = new CommonsConfigurationWrapper ( cfg ); IDataProvider dataProvider = new DataProvider ( null , projectdb , filestore , null , null , config ); IEnginesContext engctx = core . createEnginesContext ( dataProvider , null ); int i = 0 ; for ( File file : files ) { i ++ ; logger . info ( \"Testing file %d/%d : %s ...\" , i , files . size (), file . getName ()); // create or load a project (artifact container) IRuntimeProject prj = engctx . loadProject ( \"ProjectTest\" + i ); // process the artifact, get units ILiveArtifact art = prj . processArtifact ( new Artifact ( file . getName (), new FileInput ( file ))); // proceed with the units List < IUnit > units = art . getUnits (); // TODO: CUSTOMIZE -- this is the important part // Basic tests go here // example: for ( IUnit unit : units ) { logger . info ( \"Unit: %s\" , unit ); //if(unit instanceof Xyz) { // ... //} } engctx . unloadProject ( prj . getKey ()); } // close the engines JebCoreService . getInstance (). closeEnginesContext ( engctx ); } }","title":"Writing Front-Ends"},{"location":"dev/writing-front-ends.html#high-level-instructions","text":"Use the provided source code template (see below) as a base for your client. The basic steps any client should take are the following: Use JebCoreService to retrieve an instance to ICoreContext Create an IEnginesContext Load a project within that context ( IRuntimeProject ) Add artifacts and process them ( ILiveArtifact ) Retrieve the products ( IUnit ) Proceed as usual with the units We recommend developers to read our tutorial series on parser development to get familiar with units Refer to the our simplified architecture diagrams to better visualize how those components are connected to one another.","title":"High-level Instructions"},{"location":"dev/writing-front-ends.html#source-template","text":"Full source code: Command-line client skeleton on GitHub public class AutoClient { static final ILogger logger = GlobalLog . getLogger ( AutoClient . class ); static { GlobalLog . addDestinationStream ( System . out ); } // TODO: customize (should be replaced by the LicenseKey entry in your bin/jeb-client.cfg file) private static final String licenseKey = \"...\" ; // TODO: customize private static final String baseDir = \"...\" ; public static void main ( String [] argv ) throws Exception { if ( argv . length <= 0 ) { return ; } long t0 = System . currentTimeMillis (); String location = argv [ 0 ] ; List < File > files = AutoUtil . retrieveFiles ( location ); test ( files ); logger . info ( \"Done in %ds\" , ( System . currentTimeMillis () - t0 ) / 1000 ); } /** * Initialize a core. Create a context within that core. Then, for each input artifact, a * project is created and the artifact is loaded within that project. */ public static void test ( List < File > files ) throws Exception { // create or retrieve a core context (engines container) ICoreContext core = JebCoreService . getInstance ( licenseKey ); // create an engines context (project container) IFileDatabase projectdb = new JEB2FileDatabase ( baseDir ); IFileStore filestore = new SimpleFSFileStore ( baseDir ); BaseConfiguration cfg = new BaseConfiguration (); // TODO: customize (alternative is to read your configuration from .cfg file) cfg . setProperty ( \".DevPluginClasspath\" , \"...\" ); // TODO: customize cfg . setProperty ( \".DevPluginClassnames\" , \"...\" ); IConfiguration config = new CommonsConfigurationWrapper ( cfg ); IDataProvider dataProvider = new DataProvider ( null , projectdb , filestore , null , null , config ); IEnginesContext engctx = core . createEnginesContext ( dataProvider , null ); int i = 0 ; for ( File file : files ) { i ++ ; logger . info ( \"Testing file %d/%d : %s ...\" , i , files . size (), file . getName ()); // create or load a project (artifact container) IRuntimeProject prj = engctx . loadProject ( \"ProjectTest\" + i ); // process the artifact, get units ILiveArtifact art = prj . processArtifact ( new Artifact ( file . getName (), new FileInput ( file ))); // proceed with the units List < IUnit > units = art . getUnits (); // TODO: CUSTOMIZE -- this is the important part // Basic tests go here // example: for ( IUnit unit : units ) { logger . info ( \"Unit: %s\" , unit ); //if(unit instanceof Xyz) { // ... //} } engctx . unloadProject ( prj . getKey ()); } // close the engines JebCoreService . getInstance (). closeEnginesContext ( engctx ); } }","title":"Source Template"}]}